[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Daten und Information",
    "section": "",
    "text": "Vorwort\nWork in Progress\n\n\nCopyright\nDieses Werk ist lizenziert unter einer Creative Commons Namensnennung - Nicht-kommerziell - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz (CC-BY-NC-SA). Details zur Nutzungsbedingungen und dem Copyright finden sich unter createivecommons.org.\n2023, Christian Glahn, Zurich, Switzerland\n\n\n\n\n\nDie PDF Version liegt hier zum Download."
  },
  {
    "objectID": "kapitel/01-einleitung/kapitel.html#organisation-dieses-buchs",
    "href": "kapitel/01-einleitung/kapitel.html#organisation-dieses-buchs",
    "title": "1  Einleitung",
    "section": "1.1 Organisation dieses Buchs",
    "text": "1.1 Organisation dieses Buchs\n\n1.1.1 Ziele\n\n\n\nAbbildung 1.1: Inhaltliche Ziele\n\n\n\n\n1.1.2 Aufbau\nDieses Buch ist in vier Teile gegliedert:\n\nTeil I: Ausgangslage und Voraussetzungen\nTeil II: Datenquellen\nTeil III: Mathematik der Daten\nTeil IV: Deskriptive Datenanalyse\n\nDas Buch ist so aufgebaut, dass die einzelnen Kapitel aufeinander aufbauen und später als Referenz verwendet werden können. Das Buch konzentriert sich auf die zentralen Konzepte und Praktiken bei der Arbeit mit Daten. Es werden keine spezifischen Werkzeuge oder Programmiersprachen vorausgesetzt oder im Detail behandelt.\nDieses Buch kann auf zwei Arten gelesen und verwendet werden:\n\nAls Grobeinführung in die digitale Arbeit mit Daten. Diese Einführung richtet sich an Studierende und Praktiker, die sich einen Überblick über die Thematik und Konzepte verschaffen wollen.\nAls vertiefte Einführung in die digitale Arbeit mit Daten. Diese Einführung richtet sich an Studierende und Praktiker, die mit einem Data-Science-Studium beginnen oder sich auf erste Data-Science-Projekte vorbereiten wollen.\n\n\n\n\n\n\n\n\n\nKapitel\nGrobeinführung\nVertiefte Einführung\n\n\n\n\nEinleitung\nx\nx\n\n\nTastatur und Tastaturkürzel\nx\nx\n\n\nInformationstheorie\nbis und mit Abschnitt 3.2\nx\n\n\nDokumentation\n\nx\n\n\nDaten sammeln\nx\nx\n\n\nDaten organisieren\nx\nx\n\n\nVersionierung\n\nx\n\n\nDatentypen\nx\nx\n\n\nDateiformate\nbis und mit Abschnitt 9.6\nx\n\n\nVariablen, Funktionen und Operatoren\nbis und mit Abschnitt 10.5\nx\n\n\nZeichenketten\n\nx\n\n\nBoole’sche Operationen\nbis und mit Abschnitt 12.1.2\nx\n\n\nVektor-Operationen\nx\nx\n\n\nMatrix-Operationen\nbis und mit Beispiel 14.13\nx\n\n\n Daten kodieren\nx\nx\n\n\nIndizieren und Gruppieren\nx\nx\n\n\n Daten umformen\nx\nx\n\n\n Daten beschreiben\nx\nx\n\n\n Daten visualisieren\nbis und mit Abschnitt 19.3.4\nx"
  },
  {
    "objectID": "kapitel/01-einleitung/kapitel.html#begleitmaterial",
    "href": "kapitel/01-einleitung/kapitel.html#begleitmaterial",
    "title": "1  Einleitung",
    "section": "1.2 Begleitmaterial",
    "text": "1.2 Begleitmaterial\nZu diesem Buch gibt es die folgenden Begleitmaterialien mit Details und Anwendungsbeispielen für einzelne Programmiersprachen. Diese Begleitmaterialien sind so aufgebaut, dass sie direkt an die Inhalte dieses Buchs anknüpfen und die Abschnitte für die eine gewünschte Programmiersprache ergänzen und konkretisieren.\n\nDaten und Information - Data Sciece Grundlagen mit Excel\nDaten und Information - Data Sciece Grundlagen mit R"
  },
  {
    "objectID": "kapitel/01-tool-chain/tastatur.html#mac-tastatur",
    "href": "kapitel/01-tool-chain/tastatur.html#mac-tastatur",
    "title": "2  Tastatur und Tastaturkürzel",
    "section": "2.1 Mac Tastatur",
    "text": "2.1 Mac Tastatur\n\n\n\nMac-Tastatur beschriftet\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nEinige MacBookPro Modelle verfügen über einen sog. Touchbar an der Position, an welcher sich normalerweise die Funktionstasten befinden. Das Drücken der Fn-Taste wechselt die Darstellung aus dem jeweiligen App-Kontext zu virtuellen Funktionstasten. Bei Modellen mit Touchbar aus den Reihen vor 2020 fehlt eine Esc-Taste. Auch diese Taste können Sie mit der Fn-Taste im Touchbar aktivieren."
  },
  {
    "objectID": "kapitel/01-tool-chain/tastatur.html#windows-tastatur",
    "href": "kapitel/01-tool-chain/tastatur.html#windows-tastatur",
    "title": "2  Tastatur und Tastaturkürzel",
    "section": "2.2 Windows Tastatur",
    "text": "2.2 Windows Tastatur\n\n\n\nWindows-Tastatur beschriftet\n\n\nDie Windows-Taste: Diese Taste befindet sich links neben der Leerzeichen-Taste. Im Gegensatz zur Kommandotaste unter Mac hat die Windows-Taste keine zentrale Funktion im System. Viele Tastaturkürzel, die beim Mac über die Kommando-Taste ausgelöst werden, werden unter Windows über die Steuerungstaste bereitgestellt. Die Windows-Taste wird unter Windows fast ausschliesslich für Systemfunktionen verwendet.\nDie AltGr-Taste: Auf Ihren Tastaturen sehen Sie auf manchen Tasten zusätzliche Symbole. Diese Symbole können Sie unter Windows nur über die AltGr-Taste erzeugen. Das ist unter Windows die einzige Funktion der AltGr-Taste. Der Grund dafür ist, dass europäische Computertastaturen einen grösseren Zeichenumfang als eine US-Tastatur (die sog. ANSI Tastatur) haben. Weil alle Programmiersprachen die Symbole der US-Tastatur verwenden, müssen die europäischen Tastaturen diese Symbole zusätzlich bereitstellen. Unter MacOS sind diese Symbole über beide Alt-Tasten erreichbar."
  },
  {
    "objectID": "kapitel/01-tool-chain/tastatur.html#modifikatoren-und-abkürzungen",
    "href": "kapitel/01-tool-chain/tastatur.html#modifikatoren-und-abkürzungen",
    "title": "2  Tastatur und Tastaturkürzel",
    "section": "2.3 Modifikatoren und Abkürzungen",
    "text": "2.3 Modifikatoren und Abkürzungen\nGelegentlich benötigen wir Tastenkombinationen, bei denen wir mehrere Tasten gleichzeitig drücken. Dabei kommen die Tasten Hochstellen, Alt und Steuerung entweder einzeln oder kombiniert als Modifikatoren zum Einsatz.\n\n\n\n\n\n\nHinweis\n\n\n\nModifikatoren-Tasten haben keine eigene Bedeutung, sondern modifizieren die Bedeutung einer anderen Taste.\n\n\nDie folgenden Tasten sind immer Modifikatoren:\n\nHochstellen\nCAPS-Lock\nAlt / AltGr\nSteuerung\nFn\nKommando (Mac) / Win (Windows)\n\nUm nicht immer die Taste in ganzer Länge anzugeben, werden diese Modifikatoren abgekürzt. Die folgenden Buchstaben stehen für die folgenden Modifikatortasten.\n\n\n\nTaste\nSymbol\n\n\n\n\nHochstellen\nS\n\n\nAlt (Win) / option (Mac)\nM\n\n\nSteuerung\nC\n\n\n\nAlle anderen Tasten werden mit ihrem Namen angegeben.\nUm eine Tastaturkombination anzuzeigen, werden die zu drückenden Tasten mit + verknüpft. Z.B. M + C + q bedeutet, dass Sie die Tasten Alt, Steuerung und Q gleichzeitig drücken müssen.\n\n\n\n\n\n\nHinweis\n\n\n\nTasten die nacheinander gedrückt werden sollen, werden durch Leerzeichen getrennt. Z.B. C + q a bedeutet, dass Sie zuerst die Tasten Steuerung und Q gleichzeitig tippen und danach die Taste A drücken müssen."
  },
  {
    "objectID": "kapitel/01-tool-chain/tastatur.html#funktionstasten",
    "href": "kapitel/01-tool-chain/tastatur.html#funktionstasten",
    "title": "2  Tastatur und Tastaturkürzel",
    "section": "2.4 Funktionstasten",
    "text": "2.4 Funktionstasten\nAls Funktionstasten werden normalerweise die Tasten rechts neben der Esc-Taste bezeichnet. Diese Tasten sind oft mit F1-F12 beschriftet. Viele Anwendungen haben diese Tasten mit speziellen Funktionen belegt. Das gilt besonders für Excel.\nAuf modernen Laptops und vielen Desktoptastaturen sind diese Tasten standardmässig mit Gerätefunktionen wie z.B. Bildschirmhelligkeit oder Lautstärke belegt. Damit wir die eigentlichen Funktionstasten erreichen können, müssen wir deshalb mit der Fn-Taste die Standardfunktion auf die Anwendungsfunktion zurückstellen. Wenn in einer Anleitung steht, dass eine Funktion über eine Funktionstaste erreicht werden kann, dann ist implizit gemeint, dass gleichzeitig die Fn-Taste gedrückt werden muss."
  },
  {
    "objectID": "kapitel/01-tool-chain/tastatur.html#kontrollsequenzen",
    "href": "kapitel/01-tool-chain/tastatur.html#kontrollsequenzen",
    "title": "2  Tastatur und Tastaturkürzel",
    "section": "2.5 Kontrollsequenzen",
    "text": "2.5 Kontrollsequenzen\nKontrollsequenzen sind Tastaturkürzel, mit denen wir häufig verwendete Funktionen direkt über die Tastatur aktivieren können. Excel hat für fast jede Funktion im Menüband eine Kontrollsequenz festgelegt. Wir können also Excel auch ohne Maus, sondern ausschliesslich mit der Tastatur bedienen.\nDie meisten Kontrollsequenzen sind unter Windows und MacOS identisch. Der zentrale Unterschied ist jedoch, dass Windows die Steuerungstaste (Strg oder Ctrl) verwendet. Unter MacOS muss stattdessen die Kommandotaste (⌘ oder command, manchmal auch als Apfel-Taste bezeichnet) verwendet werden. Die Kommandotaste wird für Macs mit Cmd abgekürzt.\nDie wichtigsten systemweiten Kontrollsequenzen funktionieren praktisch mit jeder App und nicht nur in Excel:\n\n\n\nFunktion\nSequenz (Win)\nSequenz (Mac)\n\n\n\n\nKopieren\nC + c\nCmd + c\n\n\nEinfügen\nC + v\nCmd + v\n\n\nAusschneiden\nC + x\nCmd + x\n\n\nSpeichern\nC + s\nCmd + s\n\n\nRückgängig\nC + z\nCmd + z\n\n\n\nFür häufig verwendete Funktionen merken Sie sich die Kontrollsequenz. Dadurch können Sie Ihr Arbeitstempo steigern."
  },
  {
    "objectID": "kapitel/01-tool-chain/tastatur.html#sonderzeichen",
    "href": "kapitel/01-tool-chain/tastatur.html#sonderzeichen",
    "title": "2  Tastatur und Tastaturkürzel",
    "section": "2.6 Sonderzeichen",
    "text": "2.6 Sonderzeichen\nIn der Programmierung werden regelmässig Sonderzeichen verwendet, um bestimmte Funktionen auszulösen. Es hilft die Namen und Tastaturkürzel für diese Symbole zu kennen.\nDie am häufigsten auftauchenden Sonderzeichen sind:\n\n\n\nName (englisch)\nSymbol\nTasten (Win)\nTasten (Mac)\n\n\n\n\nApostroph (quote oder tick)\n'\n'\n'\n\n\nDach (caret)\n^\n^\n^\n\n\nAnführungszeichen (double-quote)\n\"\nS + 2\nS + 2\n\n\nSchrägstrich (slash)\n/\nS + 7\nS + 7\n\n\nAkzent (back-tick)\n`\nS + ^\nS + ^\n\n\nKaufmännisches Und (ampersand)\n&\nS + 6\nS + 6\n\n\nGatter (hash oder gate)\n#\nAltGr + 3\nM + 3\n\n\nEckige Klammer auf\n[\nAltGr + ü\nM + 5\n\n\nEckige Klammer zu\n]\nAltGr + !\nM + 6\n\n\nGeschweifte Klammer auf\n{\nAltGr + ä\nM + 8\n\n\nGeschweifte Klammer zu\n}\nAltGr + $\nM + 9\n\n\nSenkrechter Strich (pipe)\n\\|\nAltGr + 7\nM + 7\n\n\nRückstrich (backslash)\n\\\\\nAltGr + &lt;\nS + M + 7\n\n\nTilde\n~\nAltGr + ^\nM + n\n\n\nUnterstrich (low dash)\n_\nS + -\nS + -\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nMerken Sie sich die Bezeichnungen und Symbole, denn Sie werden sie regelmässig verwenden."
  },
  {
    "objectID": "kapitel/01-information/kapitel.html#shannons-informationsproblem",
    "href": "kapitel/01-information/kapitel.html#shannons-informationsproblem",
    "title": "3  Informationstheorie",
    "section": "3.1 Shannon’s Informationsproblem",
    "text": "3.1 Shannon’s Informationsproblem\nClaude Shannon befasste sich in den 1940er Jahren mit den Herausforderungen der (damals) modernen Kommunikationstechnologien Telegraphie und Telefon. Diese Technologien übertragen Nachrichten über einen Nachrichtenkanal. Ein solcher Kanal kann ein Kabel oder auch eine Funkfrequenz sein. Dieser Nachrichtenkanal wird als Medium bezeichnet.\n\nDefinition 3.1 Als Kommunikation wird das Übertragen von Informationen über ein Medium bezeichnet.\n\nDiese analogen Technologien haben das Problem, dass sich Signale über längere Distanzen abschwächen. Dieser Effekt ergibt sich aus dem “Medium”, dass für eine Kommunikation verwendet wird. Ein Kabel hat z.B. eine Dämpfung, die mit der Länge des Kabels steigt. Je länger ein Kabel wird, desto grösser wird die Dämpfung. Die Dämpfung hat zur Folge, dass ein Signal leiser wird. Dadurch geht ein Teil des ursprünglichen Signals verloren. Dieser Prozess wird als “Equivocation” bezeichnet.\n\n\n\n\n\n\nMerke\n\n\n\nDurch Equivokation gehen Informationen beim Übertragen verloren.\n\n\nEin zweites Problem analoger Kommunikationstechnologien sind äussere Störungen des Mediums. Wird z.B. ein Magnet an ein Kabel gehalten, werden die über das Kabel übertragenen Signale verzerrt. Solche Veränderungen des Signals werden als Rauschen (engl. Noise) bezeichnet. Rauschen entsteht auch zufällig mit zunehmender Länge eines Mediums.\n\n\n\n\n\n\nMerke\n\n\n\nDurch Rauschen wird fehlerhafte Information den Daten hinzugefügt.\n\n\nShannon hat vor diesem Hintergrund die folgende Fragestellung untersucht:\n\n\n\n\n\n\nProblem\n\n\n\nWie kann eine Nachricht ein Ziel erreichen, wenn die Daten durch Rauschen und Equivocation verändert werden?\n\n\nShannon (1948) gliedert diese Problemstellung in Teilprobleme, indem der Kommunikationsprozess in Teilschritte gegliedert wird. Dabei ist die “geschickte” Gliederung von Bedeutung. Shannon hat den Kommunikationsprozess in sieben Komponenten unterteilt, indem er die bekannten Störungen der Nachrichtenübertragungen verbunden hat.\n\nEine Informationsquelle, die Information erzeugt\nKodieren der Information in eine Nachricht für ein Medium\nDas Übertragen der Nachricht über einen Kanal\nDas Empfangen und Dekodieren der Nachricht\nEin Informationsziel, die Information aufnimmt\n\nZusätzlich muss das Rauschen des Kanals berücksichtigt werden. Später wurde das Modell um die Equivokation erweitert (Shannon, 1949). Sowohl das Rauschen als auch die Equivokation müssen eigenständig berücksichtigt werden, weil diese die Kommunikation unkontrolliert beeinflussen. Aus diese Überlegungen ergibt sich das Kommunikationschema in Abbildung 3.1.\n\n\n\n\n\nflowchart LR\n  a(Information) --&gt; b(Kodieren)\n  b --&gt; c(Medium)\n  c --&gt; f(Dekodieren)\n  \n  c --&gt; e(Equivokation)\n  r(Rauschen) --&gt; c\n\n  f --&gt; g(Information)\n\n\n\nAbbildung 3.1: Integriertes Kommunikationsmodell (Shannon, 1948; Shannon, 1949)\n\n\n\n\nShannon’s besondere Leistung war, dass er diese Elemente als mathematische Funktionen über Wahrscheinlichkeiten (d.h. Werte zwischen 0 und 1) formuliert und erkannt hat, dass Kommunikation dem Prinzip der Entropie folgt. Dieses Prinzip besagt, dass ein System mit einer niedrigen Entropie (d.h. einer geordneten Struktur) nur zu einer gleichbleibenden oder grösseren Entropie (d.h. zu mehr Unordnung) tendiert. Die Entropie vergrössert sich durch die Fehler bei der Kommunikation.\nDaraus ergibt sich für Shannon’s Theorie (Shannon, 1949) als direkte Konsequenz, dass Information und Daten über die folgende Funktion verbunden sind:\n\nI(D) = P(D) - \\epsilon\n\n\nD steht dabei für die empfangenen Daten und\n\\epsilon ist die Summe der Wahrscheinlichkeiten aller Störungen im Kommunikationsprozess.\n\n\n\\epsilon = P(S) + P(E) + P(N) + P(R) = \\sum_{a} P(n_a)\n\nMit\n\nS = Senden/Kodieren\nE = Equivocation\nN = Rauschen (Noise)\nR = Empfangen/Dekodieren (Receiving)\n\nUmgangssprachlich lassen sich diese Terme folgenderweise umschreiben:\n\nSatz 3.1 Information ergibt sich aus Daten nachdem alle Fehler und Störungen in den Daten entfernt wurden.\n\n\n3.1.1 Das Shannon Limit\nWeil P(D) ebenfalls eine Wahrscheinlichkeit ist, ergibt sich, dass Kommunikation nur dann möglich ist, solange die folgende Ungleichung gilt:\n\nP(D) \\ge \\epsilon\n\nEntsprechend wird \\epsilon in der Datenverarbeitung auch als Shannon Limit bezeichnet, weil dieser Term die absolute Grenze beschreibt, bis zu der eine fehlerfreie Kommunikation möglich ist.\n\n\n\n\n\n\nHinweis\n\n\n\nDiese Ungleichung besagt umgangssprachlich, dass Kommunikation nur möglich ist, solange weniger Fehler und Störungen als Daten übertragen werden.\n\n\nShannon hat nachgewiesen, dass jeder Kanal eine Grenze hat, ab der keine Datenübertragung mehr möglich ist."
  },
  {
    "objectID": "kapitel/01-information/kapitel.html#sec-infotheorie-datascience",
    "href": "kapitel/01-information/kapitel.html#sec-infotheorie-datascience",
    "title": "3  Informationstheorie",
    "section": "3.2 Informationstheorie in den Datenwissenschaften",
    "text": "3.2 Informationstheorie in den Datenwissenschaften\nClaude Shannon hat sich mit der technischen Kommunikation beschäftigt. Die Datenwissenschaften befassen sich mit dem Kodieren, dem Organisieren und dem Auswerten von Daten mit dem Ziel der Informationsgewinnung. Diese Schritte sind im Kern ein Kommunikationsprozess: Durch das Messen bestimmter Eigenschaften wird die Information der Realität als Daten erfasst. Anschliessend werden die gemessenen Daten zusammengefasst und strukturiert, damit sie abschliessend ausgewertet werden können. Das Messen entspricht dem Kodiere beim Senden, das Organisieren entspricht dem Datenmedium und die Auswertung entspricht dem Dekodieren."
  },
  {
    "objectID": "kapitel/01-information/kapitel.html#zahlensysteme",
    "href": "kapitel/01-information/kapitel.html#zahlensysteme",
    "title": "3  Informationstheorie",
    "section": "3.3 Zahlensysteme",
    "text": "3.3 Zahlensysteme\n\n\n\n\n\n\nHinweis\n\n\n\nAls Zahlensystem wird die Schreibweise für Zahlenwerte bezeichnet.\n\n\nIn der Regel verwenden wir das sog. Dezimalsystem, um Zahlen darzustellen. Das Dezimalsystem hat 10 mögliche Symbole, um Zahlenwerte abzubilden. Diese Symbole sind 1, 2, 3, 4, 5, 6, 7, 8, 9 und 0. Damit können wir mit einem Symbol Zahlenwerte zwischen 0 und 9 abbilden.\nGelegentlich lassen sich bestimmte Phänomene nicht gut im Dezimalsystem abbilden. Dadurch lassen sich Werte nur schwer interpretieren. In solchen Fällen hilft der Wechsel in ein anderes Zahlensystem.\n\n\n\n\n\n\nMerke\n\n\n\nDurch den Wechsel des Zahlensystems ändert sich nur die Darstellung, aber nicht der Wert einer Zahl!\n\n\n\nDefinition 3.2 Die Zahl, die als Grundlage für ein Zahlensystem dient, wird als Basis des Zahlensystems bezeichnet.\n\nBeim in der Schulmathematik üblichen Dezimalsystem ist die Basis 10.\n\nDefinition 3.3 Zahlensysteme kodieren Zahlenwerte zu einer gegebenen Basis.\n\n\n3.3.1 Die wichtigsten Zahlensysteme\n\nNamen und Beispiele von Zahlensystemen\n\n\n\n\n\n\n\nName\nBasis\nSymbole\n\n\n\n\nBinärsystem\n2 \n0, 1\n\n\nOktalsystem\n8\n 0, 1, 2, 3, 4, 5, 6, 7\n\n\n Dezimalsystem\n10\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n\n\n Duodezimalsystem\n12\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B\n\n\n Hexadezimalsystem\n16\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n\n\nSexagesimalsystem\n60\n-\n\n\n\nDas Duodezimalsystem und das Sexagesimalsystem treffen wir im Alltag bei Datums- und Zeitwerten, bei Winkeln sowie in der Musik an. Im Deutschen lässt sich das Duodezimalsystem noch an den Zahlworten elf (11) und zwölf (12) erkennen.\nDas binäre Zahlensystem stellt die Grundlage für digitale Computer dar, weil es nur zwei Werte für die Darstellung von Zahlen benötigt. D.h. alle Werte lassen sich als Vielfache von zweier-Potenzen abbilden. Claude Shannon hat bereits 1938 erkannt, dass diese Darstellung sich direkt die Zustände “ein” und “aus” von Schaltern übersetzen lässt, sodass sich alle Berechnungen mit Hilfe der Boolschen Algebra mit einfachen Schaltungen realisieren lassen. Daraus ergibt sich, dass das kleinste Bit der Informationstheorie sich im Binären-Zahlensystem abbilden lässt.\nDie Zahlensysteme Oktal und Hexadezimal sind für die Abbildung von Werten in Digitalcomputern von besonderer Bedeutung, weil es sich jeweils um ganzzahlige 2er Potenzen handelt.\n\n2er-Potenzen der wichtigsten Zahlensysteme digitaler Systeme\n\n\nName\nBasis\n2er-Potenz\n\n\n\n\nBinär\n2 \n2^1\n\n\nOktal\n8 \n2^3\n\n\nHexadezimal\n16 \n2^4=2^{2^2}\n\n\n\nDer Exponent der 2er-Potenz der Basis zeigt an, wie viele Stellen im Binärsystem (Bits) mit dem jeweiligen System abgebildet werden können. Ein Byte bildet per Konvention zwei Stellen im Hexadezimalsystem oder 8 Bit ab.\n\n\n\n\n\n\nHinweis\n\n\n\nHexadezimal-Werte werden recht häufig beim Programmieren verwendet, wie z.B. für das Kodieren von Buchstaben und Satzzeichen. Damit diese Werte leichter von Werten im Dezimalsystem unterschieden werden können, werden Werten im Hexadezimalsystem per Konvention die beiden Symbole 0x vorangestellt.\n\n\nBeispiele\n\nDarstellung von Zahlenwerten im Dezimal- und Hexadezimalsystem\n\n\nDezimal\nHexadezimal\n\n\n\n\n0\n0x0\n\n\n1\n 0x1\n\n\n2\n0x2\n\n\n3\n0x3\n\n\n4\n0x4\n\n\n 8\n 0x8\n\n\n 9\n 0x9\n\n\n10\n 0xA\n\n\n 15\n 0xF\n\n\n16\n 0x10\n\n\n\n\n\n3.3.2 Binärzahlen\n\n\n\n\n\n\nHinweis\n\n\n\nBinärzahlen kodieren Zahlenwerte zur Basis 2.\n\n\nDaraus folgt, dass für jede Ziffer genau zwei Symbole (Ziffern) zur Verfügung stehen: 0 und 1.\nWie in anderen Zahlensystemen entspricht eine Stelle im Binärsystem einer Potenz zur gegebenen Basis. Das ist bei Binärwerten 2. Jede Stelle für eine Ziffer kann also einer 2er-Potenz gleichgesetzt werden.\nDie Besonderheit des Binärsystems ist, dass alle Werte als Summe von 2er-Potenzen dargestellt werden können. Diese Summe wird als additive Darstellung bezeichnet.\n\nBinärzahlen und ihre additive Darstellung\n\n\nWert\nBinärwert\nAdditive Darstellung\nHexadezimal\n\n\n\n\n0\n0000\n0\n0\n\n\n1\n0001\n2^0\n1\n\n\n2\n0010\n2^1\n2\n\n\n3\n0011\n2^1 + 2^0\n3\n\n\n4\n0100\n2^2\n4\n\n\n5\n0101\n2^2 + 2^0\n5\n\n\n6\n0110\n2^2 + 2^1\n6\n\n\n7\n0111\n2^2 + 2^1 + 2^0\n7\n\n\n8\n1000\n2^3\n8\n\n\n9\n1001\n2^3 + 2^0\n9\n\n\n10\n1010\n2^3 + 2^1\nA\n\n\n11\n1011\n2^3 + 2^1 + 2^0\nB\n\n\n12\n1100\n2^3 + 2^2\nC\n\n\n13\n1101\n2^3 + 2^2 + 2^0\nD\n\n\n14\n1110\n2^3 + 2^2 + 2^1\nE\n\n\n15\n1111\n2^3 + 2^2 + 2^1 + 2^0\nF\n\n\n\nAus dieser Tabelle kann man ablesen, dass die Ziffer 1 im Binärsystem bedeutet, dass die 2er-Potenz an der entsprechenden Stelle aktiv ist.\nJede Ziffer im Binärsystem kann ausserdem als eigenständiges Symbol einer Nachricht verstanden werden. Weil im Binärsystem nur die beiden Ziffern 0 und 1 möglich sind, müssen beim Dekodieren nur diese Beiden Werte unterschieden werden. Jedes andere Zahlensystem kodiert Zahlen mit mehr als zwei Ziffern.\n\n3.3.2.1 2er-Potenzen und Speichergrössen\nNach diesem Prinzip werden auch die Kapazitäten von Datenspeichern als 2er-Potenzen beschrieben.\n\nSpeichergrössen in 2er-Potenzen\n\n\nName\nAbkürzung\ngespeicherte Byte\n\n\n\n\n Byte\n B\n2^0 = 1\n\n\nKilobyte\nKB\n2^{10} = 1024^1\n\n\nMegabyte\nMB\n2^{20} = 1024^2 = 1048576\n\n\nGigabyte\nGB\n2^{30} = 1024^3 = 1073741824\n\n\nTerabyte\nTB\n2^{40} = 1024^4 = 1099511627776\n\n\n\n\n\n\n\n\n\nWarnung\n\n\n\nDie wissenschaftliche Schreibweise ist kein eigenes Zahlensystem. Sie ist nur eine Vereinheitlichung der Schreibweise im Dezimalsystem, um sehr grosse und/oder sehr kleine Zahlen kompakt darstellen zu können.\n\n\n\n\n\n3.3.3 Winkelangaben als irrationales Zahlensystem\nWinkelangaben werden oft als Vielfache von \\pi angegeben. Diese Werte werden auch als Radiant anstatt als Grad bezeichnet. Dabei handelt es sich um ein Zahlensystem zur Basis \\pi.\n\n\\frac{\\pi}{6} = 30°\n\\frac{\\pi}{4} = 45°\n\\frac{\\pi}{3} = 60°\n\\frac{\\pi}{2}= 90°\n\\frac{2\\pi}{3}= 120°\n\\pi= 180°\n\\frac{3\\pi}{2}= 270°\n2\\pi= 360°\n\n\n\n3.3.4 Prinzip eines Zahlensystems\nDie in der Mathematik verwendeten Zahlensysteme sind sog. additive Zahlensysteme. Die Schreibweise wird durch Addition und Multiplikation mit der jeweiligen Basis bestimmt.\nDas Zählen funktioniert dabei wie folgt:\n\nEs wird bei 0 gestartet.\nDie nächste Ganzzahl wird durch Addition mit 1 erreicht.\nEs wird das nächste Ziffernsymbol ausgewählt.\nGibt es für die jeweilige Basis keine Ziffernsymbole für die Ganzzahl mehr, wird die nächsthöhere Stelle um 1 erhöht.\n\nBeispiele\n\nDarstellung von Zahlenwerten in verschiedenen Zahlensystemen\n\n\nDezimal\nBinär\nOktal\nHexadezimal\n\n\n\n\n0\n0\n0\n0x0\n\n\n1\n 1\n 1\n 0x1\n\n\n2\n10\n2\n0x2\n\n\n3\n 11\n3\n0x3\n\n\n4\n100\n4\n0x4\n\n\n 8\n 1000\n10\n 0x8\n\n\n 9\n 1001\n11\n 0x9\n\n\n10\n 1010\n12\n 0xA\n\n\n 15\n 1111\n 17\n 0xF\n\n\n16\n 10000\n100\n 0x10\n\n\n255\n 11111111\n377\n0xFF\n\n\n256\n 100000000\n400\n0x100"
  },
  {
    "objectID": "kapitel/01-information/kapitel.html#sec-wissenschaftliche-schreibweise",
    "href": "kapitel/01-information/kapitel.html#sec-wissenschaftliche-schreibweise",
    "title": "3  Informationstheorie",
    "section": "3.4 Wissenschaftliche Schreibweise von Zahlen",
    "text": "3.4 Wissenschaftliche Schreibweise von Zahlen\n\n\n\n\n\n\nHinweis\n\n\n\nAls wissenschaftliche Notation wird die Schreibweise von Zahlen mit Hilfe von Potenzen zur Basis 10 bezeichnet.\n\n\nBei der wissenschaftlichen Notation wird die erste Ziffer einer Zahl vor ein Komma gesetzt und alle restlichen Ziffern nach dem Komma. Anschliessend werden die restlichen Ziffern gezählt und als 10er-Potenz angegeben.\nBei kleinen Zahlen wird ähnlich vorgegangen: Die erste Ziffer ungleich 0 wird vor ein Komma gesetzt und alle folgenden Stellen danach. Anschliessend werden alle Nullen und die Ziffer vor dem Komma gezählt und als negative 10er-Potenz angegeben.\nNeben der ausführlichen wissenschaftlichen Schreibweise wird regelmässig eine abgekürzte Notation verwendet. In dieser Notation wird der Teil \\cdot 10 durch ein e oder E ersetzt. Dieses E steht für Exponent.\nBeispiele:\n\nBeispiele für die wissenschaftliche Notation verschiedener Zahlenwerte\n\n\n\n\n\n\n\nNormale Notation\n Wissenschaftliche Notation\nKurze wissenschaftliche Notation\n\n\n\n\n1\n1 \\cdot 10^0\n1e0\n\n\n10\n1 \\cdot 10^1\n1e1\n\n\n100\n1 \\cdot 10^2\n1e2\n\n\n523140000\n5.2314 \\cdot 10^8\n5.2314e8\n\n\n0.00000000007234\n7.234 \\cdot 10^-11\n7.234e-11\n\n\n\nDie Stärke der wissenschaftlichen Notation ist die Darstellung sehr grosser oder sehr kleiner Zahlen\nMit dieser Schreibweise lassen sich auch schnell Grössenunterschiede zwischen Werten abschätzen: Dazu wird die Differenz der 10er-Potenzen zweier Zahlen gebildet. Dazu wird die kleinere 10er-Potenz von der grösseren subtrahiert. Das Ergebnis ist wieder eine 10er-Potenz.\nBeispiel\n\nEine Differenz von 1 entspricht einem ungefähr 10-fachen Grössenunterschied.\nEine Differenz von 5 entspricht einem ungefähr 100000-fachen Grössenunterschied.\n\n\n3.4.1 Serialisierung\n\nDefinition 3.4 Ein Zahlenwert kann bei einer Darstellung zu einer Basis in mehreren Ziffern erfolgen. Diese Zifferndarstellung wird als Serialisierung bezeichnet.\n\nSerialisierung bedeutet, dass die Ziffern eines Werts in einer bestimmten Reihenfolge dargestellt werden. Jede Ziffer einer solchen Darstellung können wir uns als ein Symbol einer Nachricht vorstellen.\nWeil ein Zahlenwert in verschiedenen Zahlensystemen dargestellt werden kann, ergibt sich daraus der folgende Merksatz:\n\n\n\n\n\n\nMerke\n\n\n\nEin Zahlenwert kann mehrere zulässige Serialisierungen haben."
  },
  {
    "objectID": "kapitel/01-information/kapitel.html#sec-zeichenkodierung",
    "href": "kapitel/01-information/kapitel.html#sec-zeichenkodierung",
    "title": "3  Informationstheorie",
    "section": "3.5 Zeichenkodierung",
    "text": "3.5 Zeichenkodierung\nWir schreiben Texte nicht mit Zahlen, sondern mit Buchstaben, Satz- und Steuerzeichen. Im Computer werden Texte als Zahlen abgebildet. Dazu werden die einzelnen Zeichen eines Textes in Zahlenwerte übersetzt. Diese Übersetzung wird als Zeichenkodierung bezeichnet und wird per Konvention festgelegt.\nWeil sich Buchstaben und andere Zeichen nicht direkt als Zahlen übersetzen lassen, bedarf es eines Tricks. Dazu werden alle zu kodierenden Zeichen in einer Liste aufgeschrieben und anschliessend werden alle Zeichen durchnummeriert. Die Nummer des Zeichens wird als Zahlenwert stellvertretend für das jeweilige Zeichen.\n\n\n\n\n\n\nMerke\n\n\n\nMit dem Nummerieren von Symbolen lassen sich beliebige Symbole als Zahlenwerte kodieren.\n\n\nBei den meisten Zeichenkodierungen werden die einzelnen Zeichen so aufgereiht, dass die alphabetische und nummerische Reihenfolge in der Regel erhalten bleibt. Zeichenkodierungen sind standardisiert und müssen nicht mehr selbst entwickelt werden. Es gibt allerdings mehrere Standards, die sich in der Kodierung unterscheiden. Deshalb ist es notwendig, die verwendete Zeichenkodierung zu dokumentieren.\nHistorisch sind vier Kodierungen für die Praxis im deutschsprachigen Raum von Bedeutung.\n\nASCII - kodiert das Anglo-amerikanische Alphabet mit Ziffern und Satzzeichen in 7 Bit (Zahlen mit max. 7 Stellen binär), (American National Standards Institute, 1977).\nANSI - kodiert das Anglo-amerikanische Alphabet mit Ziffern und Satzzeichen in 8 Bit (Zahlen mit max. 8 Stellen binär).\nISO-8859 - kodiert verschiedene Schriftsysteme in 8 Bit (Zahlen mit max. 8 Stellen binär).\n\nISO-8859-1 (oder ISO Latin 1) - kodiert das westeuropäische Alphabet mit deutschen und französischen Umlauten (ISO/IEC JTC 1/SC 2/WG 3, 1998a).\nISO-8859-15 (oder ISO Latin 9) - Kodiert das westeuropäische Alphabet wie ISO-8859-1 aber mit dem Euro Symbol (€) (ISO/IEC JTC 1/SC 2/WG 3, 1998b)\n\nUTF-8 - kodiert alle gängigen und viele historische Schriftsysteme inkl. Emojis dynamisch mit 8 bis zu 32 Bit (ISO/IEC JTC 1/SC 2, 2020; The Unicode Consortium, 2022, Section 3.9).\n\nDiese Kodierungen sind bis zum Code 01111111 (oder 0x7F) identisch. Die Symbole in diesem Bereich werden deshalb als ASCII-Codes bezeichnet.\n\n\nTabelle 3.1: Vollständige ASCII-Kodierungstabelle (American National Standards Institute, 1977, S. 8)\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n0\nNUL\nDEL\nSPC\n0\n@\nP\n`\np\n\n\n1\nSOH\nDC1\n!\n1\nA\nQ\na\nq\n\n\n2\nSTX\nDC2\n”\n2\nB\nR\nb\nr\n\n\n3\nETX\nDC3\n#\n3\nC\nS\nc\ns\n\n\n4\nEOT\nDC4\n$\n4\nD\nT\nd\nt\n\n\n5\nENQ\nNAK\n%\n5\nE\nU\ne\nu\n\n\n6\nACK\nSYN\n&\n6\nF\nV\nf\nv\n\n\n7\nBEL\nETB\n’\n7\nG\nW\ng\nw\n\n\n8\nBS\nCAN\n(\n8\nH\nX\nh\nx\n\n\n9\nHT\nEM\n)\n9\nI\nY\ni\ny\n\n\nA\nLF\nSUB\n*\n:\nJ\nZ\nj\nz\n\n\nB\nVT\nESC\n+\n;\nK\n[\nk\n{\n\n\nC\nFF\nFS\n,\n&lt;\nL\n\\\nl\n|\n\n\nD\nCR\nGS\n-\n=\nM\n]\nm\n}\n\n\nE\nSO\nRS\n.\n&gt;\nN\n^\nn\n~\n\n\nF\nSI\nUS\n/\n?\nO\n_\no\nDEL\n\n\n\n\nNeben Buchstaben werden auch sog. nicht-druckbare Zeichen wie Buchstaben, Satzzeichen und Ziffern kodiert. Dazu gehören u.a. Leerzeichen, Tabulatoren und Zeilenumbrüche. Viele dieser besonderen Buchstaben haben heute keine Bedeutung mehr. In der folgenden Tabelle sind die aktuell verwendeten nicht-druckbaren Zeichen mit * markiert.\n\n\nTabelle 3.2: ASCII-Sonderzeichen (American National Standards Institute, 1977, S. 9)\n\n\n\n\n\n\n\nZeichen\nASCII-Code\nBedeutung\n\n\n\n\nNUL*\n0x00\nNULL (Nullzeichen, “Kein Wert”, “Ende einer Zeichenkette”)\n\n\nSOH\n0x01\nStart of Heading\n\n\nSTX\n0x02\nStart of Text\n\n\nETX\n0x03\nEnd of Text\n\n\nENQ\n0x05\nEnquiry\n\n\nEOT/EOF\n0x04\nEnd of Transmission/End of File (Dateiende)\n\n\nACK\n0x06\nAcknowledgement\n\n\nBEL*\n0x07\nBell (Klingelzeichen, wird meist ignoriert)\n\n\nBS\n0x08\nBackspace (Rückschritt/Rückwärtslöschen)\n\n\nHT*\n0x09\nHorizontal Tabulation (Horizontaler Tabulator)\n\n\nLF*\n0x0A\nLine Feed (Zeilenvorschub, Zeilenumbruch, Zeilenende)\n\n\nVT\n0x0B\nVertical Tabulation (Vertikaler Tabulator)\n\n\nFF\n0x0C\nForm Feed (Seitenvorschub)\n\n\nCR*\n0x0D\nCarriage Return (Wagenrücklauf, nur Windows)\n\n\nSO\n0x0E\nShift Out\n\n\nSI\n0x0F\nShift In\n\n\nDLE\n0x10\nData Link Escape\n\n\nDC1\n0x11\nDevice Control 1\n\n\nDC2\n0x12\nDevice Control 2\n\n\nDC3\n0x13\nDevice Control 3\n\n\nDC4\n0x14\nDevice Control 4\n\n\nNAK\n0x15\nNegative Acknowledgement\n\n\nSYN\n0x16\nSynchronous Idle\n\n\nETB\n0x17\nEnd of Transmission Block\n\n\nCAN\n0x18\nCancel\n\n\nEM\n0x19\nEnd of Medium\n\n\nSUB\n0x1A\nSubstitute (Dateiende/Datenende, nur Windows)\n\n\nESC\n0x1B\nEscape (Abbruch oder Funktionsänderung)\n\n\nFS\n0x1C\nFile Separator (Dateiende, veraltet)\n\n\nGS\n0x1D\nGroup Separator\n\n\nRS\n0x1E\nRecord Separator\n\n\nUS\n0x1F\nUnit Separator\n\n\nSPC*\n0x20\nSpace (Leerzeichen, Leerschlag)\n\n\nDEL\n0x7F\nDelete (Vorwärtslöschen)\n\n\n\n\nDie Zeichen für Löschen (BS und DEL) und Funktionsumstellung (ESC) finden sich nicht mehr in Zeichenketten und Dateien. Sie dienen inzwischen nur als Steuerzeichen für die Eingabe mit der Tastatur.\nDas Zeichen für das Dateiende (EOF bzw. unter Windows SUB) ist kein kodiertes Zeichen in einer Zeichenkette, sondern wird vom Betriebssystem gesetzt. Dieses Symbol findet sich nicht in einer Datei und sollte nicht eingefügt werden.\nNormalerweise werden nicht-druckbare Zeichen nicht in Zeichenketten dargestellt, obwohl sie in der Zeichenkette enthalten sind.\n\n3.5.1 Ziffernkodierung\nArabische Ziffern werden mit den Werten 0x30 (Ziffer 0) bis 0x39 (Ziffer 9) kodiert.\n\n\n\n\n\n\nMerke\n\n\n\nZiffern in Zeichenketten sind nicht gleichwertig mit den Ziffern in Zahlen.\n\n\nEine Zahl wird als eine Abfolge von Ziffern dargestellt. Wird ein Wert als Zahl dargestellt, dann werden die Ziffern entsprechend der gewählten Basis interpretiert. Werden Ziffern als Zeichenkette kodiert, dann entspricht der Wert der Ziffer der entsprechenden Kodierung. D.h.z.B. die Ziffer \"1\" in einer Zeichenkette hat nicht den Wert 1, sondern den Wert 49 (0x31). Folgen mehrere Ziffern aufeinander in einer Zeichenkette, dann werden die kodierten Zahlen aneinandergereiht. Die Ziffern \"123\" entsprechen deshalb nicht dem Wert 123, sondern dem Wert 3224115 (0x313233).\n\n\n\n\n\n\nHinweis\n\n\n\nExcel, R und Python konvertieren Ziffern in Zeichenketten oft automatisch in die richtigen Zahlenwerte, solange keine anderen Zeichen in der jeweiligen Zeichenketten kodiert wurden.\nNicht alle Programmiersprachen konvertieren Ziffern in Zeichenketten automatisch in Zahlenwerte."
  },
  {
    "objectID": "kapitel/01-information/kapitel.html#symbole-und-kompression",
    "href": "kapitel/01-information/kapitel.html#symbole-und-kompression",
    "title": "3  Informationstheorie",
    "section": "3.6 Symbole und Kompression",
    "text": "3.6 Symbole und Kompression\nDas zentrale Element von Shannon’s Informationstheorie sind Nachrichten, die aus Symbolen bestehen. Entsprechend trägt jedes Symbol zur Information einer Nachricht (N) bei. Shannon versteht unter dem Begriff Symbol sowohl Zahlen, Buchstaben, Worte als auch Wortfolgen. Dabei lassen sich Wortfolgen in mehrere Worte und Worte in Buchstaben aufteilen.\n\n\n\n\n\n\nHinweis\n\n\n\nEin Symbol, das nicht in einfachere Symbole unterteilt werden kann, wird als (Informations-) Bit bezeichnet.\n\n\nSich wiederholende Bits oder Bitfolgen können abgekürzt werden, indem die Bitfolge nur einmal zusammen mit Anzahl der Wiederholungen angegeben wird.\n\n\n\n\n\n\nHinweis\n\n\n\nDas Abkürzen einer Bitfolge wird als Kompression bezeichnet.\n\n\nVeranschaulichen wir uns das mit Hilfe der Nachricht \"aaaaaaaaaa\". Diese Bitfolge kann als [a]^{10} abgekürzt werden.\nDer Exponent zeigt uns, wie stark eine Bitfolge komprimiert wurde.\nMit diesem Wissen können wir die Nachricht \"ababababab\" komprimieren. Die Kompression ist in diesem Fall [ab]^5.\nDieses Spiel können wir weiter treiben: Die Nachricht \"aber aber \" lässt sich als [aber]^2 und die Nachricht \"aber hallo\" lässt sich als [aber hallo] ^1 komprimieren.\nDer Kompressionsgrad (K) ergibt sich aus der Länge der ursprünglichen Nachricht l(N) und der Kompression k:\n\nK = \\frac{k}{l(N)}\n\nIm Beispiel haben alle Nachrichten die Länge 10.\nDaraus ergeben sich die Kompressionsgrade für unterschiedliche, gleich lange Zeichenketten in Tabelle 3.3.\n\n\nTabelle 3.3: Kompressionsgrade verschiedener Zeichenketten\n\n\nNachricht\nKompressionsgrad\n\n\n\n\n\"aaaaaaaaaa\"\n1\n\n\n\"ababababab\"\n.5\n\n\n\"aber aber \"\n.2\n\n\n\"aber hallo\"\n.1\n\n\n\n\nDie Kompressionsgrade stehen im umgekehrten Verhältnis zum Informationsgehalt (I_g) einer Nachricht. Es gilt also:\n\nI_g = \\frac{1}{K} = \\frac{l(N)}{k}\n\n\n\n\n\n\n\nMerke\n\n\n\nJe stärker eine Nachricht komprimiert werden kann, desto weniger Information enthält sie.\nEine Nachricht mit dem Kompressionsgrad 1 wird als informationslos bezeichnet. Sie enthält also keine Information."
  },
  {
    "objectID": "kapitel/01-information/kapitel.html#merksatz-der-informationskodierung",
    "href": "kapitel/01-information/kapitel.html#merksatz-der-informationskodierung",
    "title": "3  Informationstheorie",
    "section": "3.7 Merksatz der Informationskodierung",
    "text": "3.7 Merksatz der Informationskodierung\nAusgehend von der Informationstheorie bestehen Nachrichten aus Symbolen. Symbole können Sätze, Worte, Wortkombinationen, Buchstaben oder Buchstabenfolgen sein. Ein Symbol repräsentiert einen Teil einer Nachricht.\n\nDefinition 3.5 Ein Symbol einer Nachricht wird als Bit (dt. Teil) bezeichnet.\n\nIn den vorherigen Abschnitten haben wir wichtige Erkenntnisse abgeleitet:\n\nSymbole können aus einfacheren Symbolen zusammengesetzt sein.\nZahlensysteme kodieren Zahlenwerte zu einer Basis.\nDie Basis eines Zahlensystems legt fest, wie viele Ziffern für Zahlenwerte zur Verfügung stehen.\nDie kleinste Basis für ein Zahlensystem ist 2.\nBeliebige Symbole als Zahlenwerte abgebildetet werden können.\nZiffern sind Symbole.\n\nDaraus ergibt sich der folgende Merksatz.\n\n\n\n\n\n\nMerke\n\n\n\nDas die einfachste Bit-Kodierung für eine Nachricht ist die Unterscheidung zwischen 0 und 1.\n\n\n\n\n\n\nAmerican National Standards Institute. (1977). Code for Information Interchange (ANSI X3.4-1977). https://nvlpubs.nist.gov/nistpubs/Legacy/FIPS/fipspub1-2-1977.pdf\n\n\nISO/IEC JTC 1/SC 2. (2020). Information technology — Universal coded character set (UCS) (ISO/IEC 10646:2020). https://www.iso.org/standard/76835.html\n\n\nISO/IEC JTC 1/SC 2/WG 3. (1998a). DIS 8859-1, 8-bit single-byte coded graphic character sets – Part 1: Latin alphabet No.1 (N 411). https://www.open-std.org/JTC1/sc2/wg3/docs/n411.pdf\n\n\nISO/IEC JTC 1/SC 2/WG 3. (1998b). ISO/IEC FCD 8859-15 Information technology – 8 –bit singlebyte coded graphic character sets – Part 15 : Latin Alphabet 0 (Covering the EURO symbol and full support for the French and Finish languages (N 404). https://www.open-std.org/JTC1/SC2/WG3/docs/n404.pdf\n\n\nShannon, C. E. (1948). A Mathematical Theory of Communication. The Bell System Technical Journal, 27, 379–423. https://doi.org/10.1002/j.1538-7305.1948.tb01338.x\n\n\nShannon, C. E. (1949). Communication Theory of Secrecy Systems. Bell System Technical Journal, 28(4), 656–715. https://doi.org/10.1002/j.1538-7305.1949.tb00928.x\n\n\nThe Unicode Consortium. (2022). Unicode. https://www.unicode.org/versions/latest/"
  },
  {
    "objectID": "kapitel/01-tool-chain/project_doc.html#technische-projektdokumentation",
    "href": "kapitel/01-tool-chain/project_doc.html#technische-projektdokumentation",
    "title": "4  Dokumentation",
    "section": "4.1 Technische Projektdokumentation",
    "text": "4.1 Technische Projektdokumentation\nDie technische Projektdokumentation dokumentiert die Organisation und Struktur eines Projekts und enthält alle relevanten Informationen, um die Dateien in einem git-Repository richtig zu interpretieren und die Arbeitsschritte zu reproduzieren.\nEine vollständige Projektdokumentation enthält die folgenden Teile.\n\nProjekthistorie\nEntscheidungen und Massnahmen\nProjektmotivation bzw. Ausgangslage\nRepository-Organisation\nTechnische Information zur Arbeit mit dem Projekt\nExterne Bibliotheken bzw. Abhängigkeiten.\nVertraulichkeit und Verwendungsrechte\n\nDie Versionierungsgeschichte wird von git automatisch erstellt. Die Commit-Meldungen dokumentieren die Massnahmen, welche in der zugehörenden Version umgesetzt wurden.\n\n4.1.1 Entscheidungen und Massnahmen\nWeil Die Commit-Meldungen nicht viel Platz zu dokumentation bieten, werden Entscheidungen in der Regels als Issues und Massnamen als Pull-Requests einer git-Hosting-Plattform dokumentiert. Dabei gilt, dass offene Issues oder Pull-Requests noch nicht und geschlossene Issues und Pull-Requests vollständig im Projekt umgesetzt wurden. Commit-Meldungen müssen dann nur noch auf die zugehörigen Issues referenzieren.\n\n\n4.1.2 Projektübersicht\nPer Konvention werden in der Datei README.md bzw. README die Ausgangslage und Motivation, technische Informationen sowie die Repository-Organisation dokumentiert. Diese Dokumentation ist notwendig, um mit dem Projekt arbeiten zu können. Zu den technischen Informationen gehören alle Informationen, die benötigt werden, um mit den Daten oder dem Code zu arbeiten.\nStrukturierte Daten müssen in der Projektübersicht dokumentiert werden. Die folgenden Informationen über die Daten sollten angegeben werden.\n\ndie Namen von Variablen\ndie Datentypen der Variablen\ndie Bedeutung der Variablen\n\nFür Code ist die Programmiersprache, eine Anleitung, um den Code laufen zu lassen, sowie ein Beispielaufruf anzugeben. Dieser Teil der Dokumentation hilft beim Aufsetzen des Projekts in einer neuen Arbeitsumgebung.\n\n\n4.1.3 Externe Abhängigkeiten\nIn Datenprojekten werden oft externe Bibliotheken, Module oder Pakete verwendet, die separat installiert werden müssen. Diese Komponenten bezeichnet man als externe Abhängigkeiten, die ebenfalls dokumentieren werden müssen, damit alle externen Abhängigkeiten in einer neuen Arbeitsumgebung korrekt installiert werden können. Dieser Teil der Projektdokumentation benötigt den Namen der verwendeten Bibliothek sowie die erforderliche Versionsnummer. Für meisten modernen Programmiersprachen existieren sog. Packetmanager, welche die externen Abhängigkeiten in einer Datei dokumentieren und installieren können.\nDie folgende Tabelle zeigt Paketmanager und die Datei für externe Abhängigkeiten in ausgewählten Programmiersprachen. Diese Liste ist nicht vollständig. Die Datein für externe Abhängigkeiten erfüllen die Dokumentation der externen Abhängigkeiten und können gleichzeitig für die Installation der externen Abhängigkeiten verwendet werden.\n\n\n\n\n\n\n\n\nProgrammiersprache\nPaketmanager\nDatei für externe Abhängigkeiten\n\n\n\n\nPython\npip\nrequirements.txt\n\n\nR\nrenv\nrenv.lock, renv/settings.json\n\n\nR\npak\npkg.lock\n\n\nJulia\nPkg\nProject.toml\n\n\nJavaScript\n npm\npackage.json\n\n\nJava\n Maven\npom.xml\n\n\nPHP\ncomposer\n composer.json\n\n\n\n\n\n4.1.4 Vertraulichkeit, Verwendung und Urheberschaft\nPer Konvention wird die Vertraulichkeit und Verwendungsrechte in der Datei LICENCE.md oder LICENSE dokumentiert. Dabei handelt es sich um ein rechtliches Dokument, dass oft von einer Organisation oder Auftraggeber vorgegeben wird oder, wie im Fall von Open Source Lizenzen, durch einen Verband erstellt wurden. Die Lizenzdatei wird in aller Regel in einem Projekt nicht oder nur sehr selten geändert.\n\n\n\n\n\n\nAchtung\n\n\n\nFehlt eine Lizenzdatei ist das Projekt nicht lizenzlos, sondern unterliegt dem gesetzlichen Urheberrecht am Wohnsitz der Projektbeteiligten. Damit ein Projekt lizenzlos veröffentlicht werden kann, muss dieses explizit in der Lizenzdatei festgehalten werden. Ein Beispiel für eine solchen Vermerk ist die sog. MIT Lizenz.\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nDie Verwendungsrechte externer Abhängigkeiten können die Verwendung des eigenen Projekts beeinflussen. Möglicherweise sind einzelne Module mit den Projektanforderungen nicht vereinbar und dürfen in diesen Fällen auch nicht im Projekt verwendet werden. Es ist deshlab wichtig, die Lizenzbedingungen aller externen Abhängigkeiten auf ihre rechtliche Kompatibilität mit dem eigenen Projekt zu prüfen.\n\n\ngit-Hosting-Plattformen bieten verschiedene Lizenzen beim Erstellen eines neuen Projekts an.\n\n\n\n\n\n\nAchtung\n\n\n\nProjekte, die mit Bezug auf die Daten und/oder die Auswertungsalgorithmen als vertraulich gelten, dürfen nicht in öffentlichen Projektrepositories verwaltet werden. In diesem Fall muss ein privates Repository verwendet werden. Unter Umständen ist eine Verwendung einer öffentlichen Plattform nicht möglich. In diesem Fall muss eine eigene git-Hosting-Plattform genutzt werden.\n\n\nNeben der Verwendung und Vertraulichkeit ist auch die Urheberschaft zu dokumentieren. Die Urheberschaft ist die Liste der Personen, die an einem Projekt mitgearbeitet haben. Traditionell wurde die Urheberschaft wird in der Regel in der Datei AUTHORS.md oder AUTHORS dokumentiert.\n\n\n\n\n\n\nTipp\n\n\n\ngit-Hosting-Plattformen erstellen inzwischen die Autorenliste automatisch aus den Commits. Zusätzlich wird auch der Umfang der Beiträge dokumentiert."
  },
  {
    "objectID": "kapitel/01-tool-chain/project_doc.html#labor--und-arbeitsbericht",
    "href": "kapitel/01-tool-chain/project_doc.html#labor--und-arbeitsbericht",
    "title": "4  Dokumentation",
    "section": "4.2 Labor- und Arbeitsbericht",
    "text": "4.2 Labor- und Arbeitsbericht\nEin Laborbericht dokumentiert den Ablauf und alle Ergebnisse eines Experiments oder einer Untersuchung. Ein Laborbericht ist eine technische Dokumentation einer Untersuchung oder eines Experiments. Diese Dokumentation ist der Beleg für die sachgemässe Durchführung einer Untersuchung. Bei Untersuchungen, die mehr als eine Arbeitssitzung oder -Schicht benötigen, sollten Laborberichte pro Sitzung bzw. Schicht erstellt werden.\n\n\n\n\n\n\nWarnung\n\n\n\nLaborberichte sind Teil von Complience-Anforderungen und werden oft von Auftraggebern oder Behörden verlangt. In diesen Anforderungen werden die zwingend zu dokumentierenden Teile festgelegt. Unterliegen bestimmte Untersuchungen einer Complience-Anforderung, dann müssen diese Anforderungen eingehalten werden, selbst wenn diese nicht explizit gefordert wurde. Stellt sich später heraus, dass ein vorliegender Laborbericht unvollständig ist oder falsche Angaben zur Durchführung enthält, dann kann dies unter Umständen als Urkundenfälschung gewertet werden.\n\n\nLaborberichte sollten am Besten während oder unmittelbar nach einer Untersuchung erstellt werden. Werden regelmässig Laborberichte erstellt, bietet sich die Verwendung einer Versionierung mit git an.\nBei der Verwendung von Laborberichten wird angenommen, dass undokumentierte Materialien nicht verwendet wurden und nicht dokumentierte Arbeitsschritte oder Ereignisse nicht stattgefunden haben. Ein fehlender oder unvollständiger Laborbericht entspricht einer nicht ordnungsgemäss durchgeführten Untersuchung.\nEin Laborbericht besteht aus den folgenden Teilen.\n\nTitel\nBeteiligte Untersucher\nDatum, Uhrzeit und Ort\nFragestellung bzw. Auftrag\nMaterialliste\nDetaillierter Versuchsaufbau\nVersuchsdurchführung bzw. Ablauf\nErgebnisse\nFehlerdiskussion\nBeobachtungen\nBesondere Ereignisse\n\n\n4.2.1 Materialliste\nDie Materialliste umfasst alle Materialien, die für die Durchführung des Experiments benötigt werden. Grundsätzlich müssen alle Materialien und Geräte, die für die Durchführung einer Untersuchtung verwendet werden, in der Materialliste aufgeführt werden müssen. Zu den Materialien gehören zum Beispiel:\n\nChemikalien und Reagenzien\nProben\nBehälter, Gefässe und Verbindungen\nMessgeräte\nKabel und Stecker\nWerkzeuge\nVerbrauchsmaterialien\nSchutzkleidung\nEntsorgungsmaterialien\n\nFalls eine Studie oder ein Experiment nicht in einer kontrollierten Laborumgebung durchgeführt wird, müssen auch die Umweltbedingungen am Untersuchungsort dokumentiert werden.\n\n\n4.2.2 Versuchsaufbau\nDer Versuchsaufbau beschreibt die Anordnung der Materialien und Geräte bei der Durchführung eines Experiments. Dieser Abschnitt beschreibt im Detail den Aufbau eines Versuchs oder einer Untersuchung, so dass diese später genau gleich wiederholt werden kann. Für den Versuchsaufbau werden zusätzlich Skizzen und Schaltpläne angegeben. Falls der Versuchsaufbau spezielle Software für die Durchführung benötigt, sind alle Komponenten und Einstellungen ebenfalls im Versuchsaufbau zu dokumentieren.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Software für die Auswertung ist kein Teil des Versuchsaufbaus.\n\n\nBei wiederholten Durchführungen mit dem gleichen Versuchsaufbau kann der Versuchsaufbau in einem separaten Dokument oder in einem separaten Abschnitt dokumentiert werden. Dieses Dokument ist dann für alle Versuchsdurchführungen mit dem gleichen Versuchsaufbau gültig und muss in allen zugehörigen Laborberichten referenziert werden.\n\n\n4.2.3 Durchführung und Ablauf\nDer Abschnitt Durchführung beschreibt die genaue Vorgehensweise einer Untersuchung oder eines Experiments. Dabei werden alle durchgeführten Arbeitsschritte in chronologischer Reihenfolge festgehalten. Die Beschreibung der Durchführung muss so genau sein, dass die Untersuchung oder das Experiment später genau gleich wiederholt werden kann.\nWenn besondere Vorsichtsmassnahmen bei der Durchführung notwendig sind, müssen diese ebenfalls im Abschnitt Durchführung dokumentiert werden.\nDie Entsorgung von Nebenprodukten und Abfällen ist Teil der Versuchsdurchführung. Die Entsorgung von Nebenprodukten und Abfällen wird oft in einem separaten Abschnitt dokumentiert.\nBei manchen Untersuchung ist ein besonderer Rückbau des Versuchsaufbaus notwendig. Der Rückbau des Versuchsaufbaus wird ebenfalls in der Versuchsdurchführung dokumentiert.\n\n\n4.2.4 Ergebnisse\nAlle gemessenen Ergebnisse eines Experiments oder einer Untersuchung müssen im Abschnitt Ergebnisse dokumentiert werden. Das gilt auch für Messwerte, die später nicht für die Auswertung verwendet werden. Die Ergebnisse werden in Tabellen und Diagrammen dargestellt. Die Tabellen und Diagramme müssen mit einer Nummer versehen werden und eine aussagekräftige Beschriftung haben. Die Tabellen mit den Messwerten sind immer verpflichtend. Diagramme sind optional.\n\n\n\n\n\n\nAchtung\n\n\n\nDie Ergebnisse müssen vollständig dokumentiert werden. Das bedeutet, dass alle Messwerte, die für die Auswertung nicht verwendet werden, trotzdem dokumentiert werden müssen.\n\n\nWeil die Messwerte später ausgewertet werden sollen, können die Tabellen in einer separaten Datei gespeichert werden. Diese Datei wird dann im Abschnitt Ergebnisse als Anhang referenziert. Sollte eine Untersuchung mehrere Tabellen erzeugt haben, dann sollten diese als eigenständige Anhänge geführt werden.\n\n\n4.2.5 Fehlerdiskussion\nDie Fehlerdiskussion eines Projektberichts umfasst die bekannten Fehlerquellen und Fehlerabschätzungen einer Studie. Dieser Teil dient zur Bestimmung der Messgüte der Einschätzung der präsentierten Ergebnisse.\nIn diesem Teil müssen auch methodische Fehler berichtet werden, falls diese die ordnungsgemässe Messung oder Auswertung beeinflussen.\nMessausfälle oder nicht durchgeführte Messungen sind nicht Teil der Fehlerdiskussion, sondern fallen in die Rubrik besondere Ereignisse und müssen dort berichtet werden.\n\n\n4.2.6 Besondere Ereignisse\nIn einem Laborbericht werden grundsätzlich alle besonderen Ereignisse dokumentiert. Besondere Ereignisse sind Ereignisse, die nicht zum normalen Ablauf gehören oder für das Experiment nicht zu erwarten waren. Beispiele für besondere Ereignisse sind:\n\nUngewöhnliche Messwerte und Messausfälle\nUngewöhnliche Geräusche, Gerüche oder Verfärbungen\nVerzögerungen und Unterbrechungen\nAusfall von Geräten\nWarnmeldungen\nDefekte oder fehlerhafte Geräte\nUnfälle und Verletzungen\nUnkontrolliertes oder ungeplantes Austreten von Flüssigkeiten oder Gasen\n\nFalls keine besonderen Ereignisse aufgetreten sind, können diese Teile weggelassen werden.\n\n\n4.2.7 Beobachtungen und Notizen\nLaborberichte sind eine wichtige Quelle für Innovation und Erkenntnisse. Deshalb sollten Beobachtungen, Erfahrungen und andere Notizen in Laborberichten festgehalten werden. Dadurch wird sichergestellt, dass dieser Teil der Dokumentation nicht von der Untersuchtung getrennt und so dekontextualisiert wird."
  },
  {
    "objectID": "kapitel/01-tool-chain/project_doc.html#projektbericht",
    "href": "kapitel/01-tool-chain/project_doc.html#projektbericht",
    "title": "4  Dokumentation",
    "section": "4.3 Projektbericht",
    "text": "4.3 Projektbericht\nEin Projektbericht dokumentiert die Ausgangslage, die Methode, die Ergebnisse und die Schlussfolgerungen eines Projekts.\nEin Projektbericht besteht immer aus den folgenden Teilen.\n\nTitel\nAutoren\nZusammenfassung (Abstract)\nEinleitung und Hintergrund\nForschungsfrage/Arbeitsauftrag\nMethode\nErgebnisse\nInterpretation (Diskussion)\nAusblick\nQuellenverzeichnis\n\nBei längeren Projektberichten muss zusätzlich ein Inhaltsverzeichnis, ein Abbildungsverzeichnis, ein Tabellenverzeichnis und ein Abkürzungsverzeichnis sowie eine Managementzusammenfassung erstellt.\n\n4.3.1 Einleitung und Hintergrund\nDie Einleitung legt den Kontext des Projekts fest. Dazu gehört die übergeordnete Problemstellung und die bekannten Fakten zum Thema. Die Problemstellung sollte so formuliert sein, dass auch interessierte Personen, die nicht mit dem Thema vertraut sind, die Ausgangslage verstehen können. Die Aufstellung der bekannten Fakten ist eine Zusammenfassung der Literatur zu dieser Problemstellung. Es kommt nicht selten vor, dass Querbezüge zu anderen Themen oder Problemstellungen hergestellt werden müssen. Auch diese Literatur muss in der Einleitung zusammengefasst werden.\nDie Literatur sollte so zusammengefasst werden, dass für die projektrelevante Aspekte, die in der Literatur identifiziert wurden, ein Absatz im Abschnitt gewidmet wird. Dabei müssen die entsprechenden Quellen referenziert werden. Falls mehrere Quellen die gleiche oder sehr ähnlich Aussagen treffen, dann können diese im gleichen Absatz zusammengefasst und gemeinsam referenziert werden.\n\n\n4.3.2 Forschungsfrage oder Arbeitsauftrag\nDer Abschnitt Forschungsfrage oder Arbeitsauftrag legt die konkrete Motivation des Projekts fest. Diese sollte durch den Kontext der bekannten Fakten und der Problemstellung in der Einleitung sachlich begründet sein.\nAls Frage formuliert liefert der Abschnitt Ausblick die Antwort auf diese Frage. Dadurch entsteht eine rhetorische Klammer im Projektbericht. Gleichzeitigt hiflt die Formulierung der Fragestellung bei der kontinuierlichen Überprüfung, ob die durchgeführten Schritte im Projekt auch zur Beantwortung der Fragestellung beitragen. Deshalb sollten auch Arbeitsaufträge, die nicht als Frage präsentiert werden, intern als Frages umformuliert werden.\n\n\n4.3.3 Methode\nDie Methode beschreibt das Vorgehen bei der Erhebung und Auswertung von Daten. Die Beschreibung muss eine Wiederholung oder das systematische Nachvollziehen der Untersuchung ermöglichen. In diesem Abschnitt sind alle Arbeitsschritte zu dokumentieren, die in den Abschnitten Ergebnisse und Interpretation zu den präsentierten Ergebnissen führen.\nDie Methode umfasst nur die systematische Vorgehensweise, aber keine technische Dokumentation der Auswertung. Hierzu sollte auf die technische Projektdokumentation verwiesen werden.\n\n\n4.3.4 Ergebnisse\nDer Abschnitt Ergebnisse fasst alle erhobenen Messungen zusammen. Dabei werden die Messwerte in Tabellen und Diagrammen dargestellt. Alle in diesem Abschnitt präsentierten Daten sollten sich direkt aus Laborberichten ableiten lassen.\nIm Abschnitt Ergebnisse werden selten die gemessenen Rohdaten als Tabelle präsentiert. Sollten die Rohdaten für die Interpretation bedeutsam sein, dann sollten diese Daten in einem Anhang getrennt präsentiert werden.\nDieser Abschnitt muss alle im Abschnitt Interpretation bzw. Diskussion verwendeten Daten enthalten. Für jede Aussage im Abschnitt Interpretation muss ein Bezug zu den Ergebnissen möglich sein.\nDieser Abschnitt enthält für empirischen Studien normalerweise keine Referenzen auf externe Quellen.\n\n\n4.3.5 Interpretation\nDie Interpretation umfasst die Bewertung der Ergebnisse. Dabei werden die Ergebnisse mit den Erwartungen aus der Einleitung verglichen. In diesem Abschnitt werden die Ergebnisse in den in der Einleitung hergestellten Kontext gestellt und die Schlussfolgerungen aus der Auswertung gezogen. In diesem Abschnitt werden die Argumente für die Beantwortung der Forschungsfrage bzw. des Arbeitsauftrags vorbereitet.\nDie Interpretation enthält keine neuen Daten, sondern nur eine Bewertung der Ergebnisse. Die Bewertung der Ergebnisse muss immer mit den Erwartungen aus der Einleitung und Fragestellung verglichen werden.\n\n\n4.3.6 Ausblick\nDer Ausblick beantwortet die Forschungsfrage bzw. den Arbeitsauftrag. Dabei werden die Ergebnisse der Untersuchung zusammengefasst und die Schlussfolgerungen daraus gezogen. Häufig werden die Schlussfolgerungen als Empfehlungen für die Praxis formuliert.\nFalls in einem Projekt unerwartete Ergebnisse auftraten oder Phänomene beobachtet wurde, die nicht durch as Projekt erklärt werden können, dann sollten Fragen für die weitere Forschung formuliert werden. Diese Fragen sollten als Forschungsfragen analog zum Abschnitt Forschungsfrage formuliert werden.\n\n\n\n\n\n\nTipp\n\n\n\nFalls über ein Teilprojekt berichtet wird, dann gelten die nächsten geplanten Projektfragen nicht als Fragen für die weitere Forschung.\n\n\n\n\n4.3.7 Zitieren und Quellenverzeichnis\nDas Zitieren von Quellen ist ein wichtiger Teil der wissenschaftlichen Arbeit. Das Zitieren von Quellen dient dazu, die Herkunft von Ideen, Aussagen und Ergebnissen zu dokumentieren. Das Referenzieren externer Quellen ist verpflichtend. Im Bericht wird auf die Quellen in einer Kurzform verweisen. Die vollständigen Angaben aller Quellen werden im Quellenverzeichnis aufgeführt.\nWie Quellen richtig referenziert werden, ist in sog. Zitierstandards festgelegt. Wichtige Zitierstandars sind der APA Styleguide (American Psychological Association, 2020), der Chicago Styleguide (The University Of Chicago Press Editorial Staff, 2017), der IEEE Styleguide (IEEE, 2018) oder der ACM Styleguide (Rodkin, 2023). In einem Projektbericht wird nur ein Zitierstandard verwendet. Es ist nicht vorgesehen, Zitierstandards zu mischen.\nEine wörtliche Übernahme einer anderen Quelle wird als Zitat bezeichnet. Zitate sollten sehr sparsam in Berichten verwendet werden. Zitate sind oft nur dann notwendig, wenn die wörtliche Übernahme einer Aussage oder eines Ergebnisses für die Argumentation erforderlich ist.\nWerden Ideen, Aussagen oder Ergebnisse aus einer externen Quelle verwendet, dann ist das eine Paraphrase und erfordert wie ein Zitat eine Referenz der Quelle. Bei Paraphrasen ist die Angabe der Seitenzahl nur dann notwendig, wenn die referenzierte Idee sich nicht direkt aus der Quelle ergibt. Das ist zum Beispiel der Fall, wenn die Quelle eine Monographie mit mehreren Studien ist und nur eine bestimmte Studie referenziert wird.\n\n\n\n\n\n\nAchtung\n\n\n\nWerden externe Quellen verwendet und nicht referenziert, dann handelt es sich um ein Plagiat. Plagiate sind ein schwerer Verstoss gegen die wissenschaftliche Integrität und das Urheberrecht. Bei Zertifizierungen sind Plagiate ausserdem ein Betrug. Das gilt auch für Paraphrasen ohne Referenz.\n\n\n\n\n4.3.8 Management-Zusammenfassung\nEine Management zusammenfassung ist eine Kurzfassung eines Projektberichts, die sich an die Entscheidungsträger richtet. Sie ist deutlich kürzer als die Zusammenfassung und enthält nur die wichtigsten Informationen des Projektberichts. In der Regel ist die Managementzusammenfassung nicht länger als eine Seite und ist Stichpunktartig formuliert.\nEine gute Managementzusammenfassung kann direkt in einer Präsentation verwendet werden. Als Richtlinie für eine Managementzusammenfassung sind sieben Punkte. Diese Punkte sollten die folgenden Fragen beantworten.\n\nWas ist das Problem?\nWie wurde gemessen?\nWas sind die wichtigsten Ergebnisse?\nWelche Schlussfolgerungen können gezogen werden?\nWelche Massnahmen werden empfohlen? (optional)\n\n\n\n\n\nAmerican Psychological Association. (2020). Publication manual of the American Psychological Association (7th ed.). American Psychological Association. https://doi.org/10.1037/0000165-000\n\n\nIEEE. (2018). IEEE Reference Guide. https://ieeeauthorcenter.ieee.org/wp-content/uploads/IEEE-Reference-Guide.pdf\n\n\nRodkin, C. (2023). ACM Citation Style and Reference Formats. https://www.acm.org/publications/authors/reference-formatting\n\n\nThe University Of Chicago Press Editorial Staff. (2017). The Chicago Manual of Style, 17th Edition. University of Chicago Press. https://doi.org/10.7208/cmos17"
  },
  {
    "objectID": "kapitel/02-daten-sammeln/kapitel.html#das-datenschema",
    "href": "kapitel/02-daten-sammeln/kapitel.html#das-datenschema",
    "title": "5  Daten sammeln",
    "section": "5.1 Das Datenschema",
    "text": "5.1 Das Datenschema\nWelche Daten in einem Datensatz erfasst wurden bzw. erfasst werden sollen, werden in einem Datenschema festgehalten. Das Datenschema hat zwei Funktionen.\n\nEs legt fest, welche Daten für einen Datensatz erhoben werden müssen. In dieser Funktion ist das Datenschema eine grobe Anleitung welche Daten gesammelt werden sollen.\nEs dokumentiert, welche Daten in einem Datenssatz vorliegen. Ein Datenschema hilft so Analysten, die Daten richtig zu auszuwerten und zu interpretieren.\n\nEin Datenschema legt Felder für die Ablage der beobachteten Daten fest.\nJedes Datenfeld erhält immer einen eindeutigen Namen für ein Datenfeld. Über den Namen können die im Datenfeld erfassten Daten zugegriffen werden. Die Namen von Datenfeldern dienen der einfacheren Handhabung bei der digitalen Auswertung. Deshalb sollten diese Namen möglichst einfach und gleichzeitig die Daten etwas beschreiben. Damit beim Auswerten weniger Fehler passieren, sollten Namen nur die Zeichen a-z, 0-9 und _ enthalten und mit einem Buchstaben beginnen.\nZusätzlich kann ein Datenfeld einen Wertebereich haben. Ein Wertebereich legt die zulässigen Werte für ein Datenfeld fest. Für die automatisierte Auswertung kann es hilfreich sein, auch das Skalenniveau (s. Kapitel 8.2) des Wertebereichs zu dokumentieren.\nFalls die Daten eine Masseinheit haben, muss diese auch dokumentiert werden.\nEs ist üblich, für jedes Datenfeld eine Kurzbeschreibung anzugeben. Diese Beschreibung gibt zusätzliche Hinweise über die erfassten Werte. Die Beschreibung ist rein informativ und richtet sich an Menschen, die Daten für das Schema erheben oder diese Daten auswerten.\nGrundsätzlich können alle Datenfelder frei bestimmt werden. Einige Datenfelder sind für fast jede Studie gegeben. Zu diesen Datenfelder gehören beispielsweise der Zeitpunkt der Beobachtung, der Ort der Beobachtung, die beobachtende Person und die Dauer der Beobachtung. Bei der technischen Datenerfassung können weitere Felder durch die verwendeten Werkzeuge automatisch bereitgestellt werden. Deshalb sollten die technischen Möglichkeiten vor einer Datenerhebung geprüft werden, um das mehrfache abfragen der gleichen Daten zu vermeiden."
  },
  {
    "objectID": "kapitel/02-daten-sammeln/kapitel.html#arten-von-daten",
    "href": "kapitel/02-daten-sammeln/kapitel.html#arten-von-daten",
    "title": "5  Daten sammeln",
    "section": "5.2 Arten von Daten",
    "text": "5.2 Arten von Daten\nBeim Daten sammeln werden drei Arten von Daten unterschieden:\n\nUnstrukturierte Daten\nStrukturierte Daten\nSemi-strukturierte Daten\n\n\n5.2.1 Unstrukturierte Daten\n\nDefinition 5.2 Unstrukturierte Daten haben keinen festgelegten Wertebereich.\n\nTypische unstrukturierte Daten sind Notizen, Transkripte gespochener Sprache oder Videos. Unstrukturierte Daten können Werte von Interesse enthalten, auf die jedoch nicht direkt zugegriffen werden kann.\nUnstrukturierte Daten haben den Vorteil, dass sie Ergebnisoffen ein. Dadurch sind unstrukturierte Daten offen für neue und unvorgesehene Information. Entsprechend werden Techniken, die unstrukturierte Daten erheben auch als offene Erhebungstechniken bezeichnet.\nDiese Offenheit hat ihren Preis, denn unstrukturierte Daten sind anfällig gegenüber Rauschen und Equivokation. Ausserdem können einzelne Werte nicht direkt aus unstrukturierte Daten abgelesen werden, sondern müssen (oft umständlich) aus den Daten extrahiert werden.\n\n\n\n\n\n\nHinweis\n\n\n\nUnstrukturierte Daten erfordern immer zusätzliche Arbeitsschritte, bevor mit den in ihnen vorhandenen Daten gearbeitet werden kann. Diese Arbeitsschritte zusammenfassend werden Kodieren (engl. coding) genannt. Das Kodieren unstrukturierter Daten führt einheitliche Markierungen, die sog. Annotationen, ein, die eine Struktur über die Daten legen.\n\n\nOhne vorbereitende Kodierung lassen sich unstrukturierte Daten kaum systematisch analysieren. Sehr häufig handelt es sich bei unstrukturierten Daten um Texte. Im Kapitel 11 werden einfache Techniken zum Verarbeiten von unstrukturierten Daten beschrieben.\n\n\n5.2.2 Strukturierte Daten\n\nDefinition 5.3 Strukturierte Daten haben einen festen Wertebereich.\n\nWeil strukturierte Daten einen festen Wertebereich haben, ist sichergestellt, dass nur Werte innerhalb dieses abgeschlossenen Bereichs gültig sind. Deshalb werden Techniken, mit denen strukturierte Daten erhoben gelten auch als geschlossene Erhebungstechniken.\nStrukturierte Daten basieren immer auf einer festen Wertebereich, die Information kodiert. In dieser Struktur werden die Daten nach ihrer Bedeutung und ihren zulässigen Wertebereichen organisiert. Die feste Struktur macht strukturierte Daten innerhalb der Struktur weniger anfällig gegenüber Rauschen als unstrukturierte Daten.\nWeil strukturierte Daten eine Struktur zur Informationskodierung vorgeben, lassen sich nur Informationen über diese Struktur kodieren. Das führt zu Equivokation, weil nur die Teile der Information kodiert werden können, die in den Wertebereichen zulässig sind.\nTabellen sind typische strukturierte Daten, die in Spalten und Zeilen organisiert sind.\nStrukturierte Daten sind nicht auf Tabellen beschränkt.\n\nListing 5.1: Strukturierte Daten im YAML-Format\nhamster: \n- name: Fred\n  gewicht: 175\n  zeit: 2023-04-11T10:20:30Z\n- name: Frida\n  gewicht: 160\n  zeit: 2023-04-12T09:10:11Z\n\n\n\n5.2.3 Semi-strukturierte Daten\nNeben diesen zwei Arten existieren noch sog. semi-strukturierte Daten. Semistrukturierte Daten folgen einer logischen Struktur, die allerdings nicht durchgehend strickt eingehalten wird.\n\nDefinition 5.4 Semi-strukturierte Daten sind unstrukturierte Daten, die Markierungen für Werte beinhalten.\n\nSemi-strukturierte Daten werden oft für das Einbetten strukturierter Daten in unstrukturierte Datenfelder verwendet.\nEin typisches Beispiel für semistrukturierte Daten sind Social-Media-Meldungen mit Hashtags und @-Nennungen. Mit dem Hash-Symbol (#) werden Themen und Inhalte hervorgehoben und mit dem @-Symbol werden Nutzende markiert. Durch die beiden Symbole wird eigendlich unstrukturierten Daten eine zusätzliche Struktur gegeben, auf welche zugegriffen werden kann. Eine Social-Media-Meldung kann keine, ein oder mehrere Hashtags und keine, eine oder mehrere Nennungen enthalten.\n\nListing 5.2: Tweet mit Hashtag (ZHAW, 2023)\nDas neue Laborgebäude auf dem ZHAW-Campus Reidbach \nin #Wädenswil wurde gestern eingeweiht. Genutzt wird der\nNeubau vom Institut für Lebensmittel- und Getränkeinnovation,\nwo unter einem Dach die gesamte Wertschöpfungskette von \nLebensmitteln erforscht wird. \nhttps://zhaw.ch/de/ueber-uns/aktuell/news/\ndetailansicht-news/event-news/\nlebensmittelforschung-unter-einem-dach-vereint/\n\nEin anderes Beispiel finden sich regelmässig in Bankmiteilungen im Feld “Verwendungszweck”. In diesem Feld werden oft zusätzliche Daten für die Kommunikation zwischen den Beteiligten einer Transaktion hinterlegt. Listing 5.3 zeigt semistrukturierte Daten im Verwendungszweck von Banktransaktionen, diese können für eine Analyse verwendet werden.\n\nListing 5.3: Semistrukturierte Daten\n1   PV2332 PG386.5 SV375.26 \n2   PG374.23\n3   Ref: 106030763221202, Knr: 783924\n\nIn diesem Beispiel sind einmal drei Werte, einmal ein Wert und einmal zwei Werte in einem Eintrag vorhanden. Dabei kommt die Buchstabenfolge PG einmal als zweiter Wert und einmal alleinstehend vor. Eine Behandlung als Tabelle dieser Werte ist wahrscheinlich nicht zielführend.\nDie Buchstabenfolgen PV, PG und SV sowie Ref: und Knr: erfüllen den gleichen Zweck, wie Symbole # und @ in Social-Media-Meldungen. Diese Markierungen sind Codes, die wichtige Daten hervorheben und relativ leicht identifizieren lassen. Die Codes nehmen das Kodieren unstrukturierter Daten vorweg.\nSolche Codes sind transaktionsspezifisch, so dass nicht alle Codes vorkommen müssen und bestimmte Codes nur bei bestimmten Transaktionen vorkommen oder die gleichen Codes in unterschiedlichen Transaktionen andere Bedeutungen haben. Oft folgen diese Codes einem eigenen Schema."
  },
  {
    "objectID": "kapitel/02-daten-sammeln/kapitel.html#daten-erheben",
    "href": "kapitel/02-daten-sammeln/kapitel.html#daten-erheben",
    "title": "5  Daten sammeln",
    "section": "5.3 Daten erheben",
    "text": "5.3 Daten erheben\nDie eigentliche Datensammlung kann manuell, technisch unterstützt oder automatisch erfolgen. Bei der manuellen Datenerhebung werden alle Daten von einer Person erfasst und festgehalten. Bei der technisch-unterstützten Datenerhebung helfen spezielle Erhebungswerkzeuge, die Datenerhebung zu vereinfachen, indem sie Werte überprüft werden oder automatisch erfasst werden. Bei der automatischen Datenerhebung werden Daten durch Sensoren erfasst und gespeichert.\n\n5.3.1 Manuelle Datenerhebung\nIn der Laborarbeit ist die Erfassung von Messwerten in Tabellen oder Listen üblich. Dabei werden die Werte von Hand direkt in eine Tabelle oder Liste eingetragen. So erfasste Tabellen oder Listen sind strukturierte Daten. Beim Eintragen der Daten muss darauf geachtet werden, dass die Werte an der richtigen Stelle eingetragen werden, weil solche Fehler oft unerkannt bleiben und eine nachträgliche Korrektur oft nicht möglich ist.\nDie einfachste Form der manuellen Datenerfassung sind Notizen. Notizen sind persönliche Aufzeichnungen über die eigene Arbeit bzw. über Beobachtungen bei der Arbeit. Diese Daten sind entweder unstrukturiert oder semi-strukturiert. Sie erlauben eine grosse Flexibilität falls die Daten nicht vorstrukturiert werden können oder die Struktur weitgehend unbekannt ist. Notizen lassen sich schwer objektivisieren, weil sie immer einen subjektiven Anteil der Person haben, welche die Notiz verfasst hat.\n\n\n\n\n\n\nPraxis\n\n\n\nEs ist eine gute Idee, Messwerte in Tabellen zu erfassen und zusätzliche Notizen zu machen. Aus beiden ergeben sich Laborberichte, die wiederum zu Labortagebüchern wachsen. In der wissenschaftlichen Praxis sind die strukturierten Daten zwar das Hauptergebnis einer Untersuchung, aus den Notizen ergeben sich jedoch oft neue Einsichten, die sich nicht aus den strukturierten Daten herauslesen lassen.\n\n\nNeben Notizen sind Transskripte ein wichtiges Werkzeug der manuellen Datenerfassung. Transskripte sind eine Verschriftlichung einer anderen Aufzeichnung. Oft sind das Tonaufzeichnungen von Gesprächen oder Videoaufzeichnugen eines Experiments. Diese Aufzeichnungen liefern immer unstrukturierte Daten. Die ursprüngliche Aufzeichnung ist dabei meistens eine Primärquelle für die Daten. Das Transskript ist eine abgeleitete Sekundärquelle der Primärquelle. Weil beim Transskribieren die Primärquelle neu kodiert wird, muss beim Transskribieren besonders sorgfältig gearbeitet werden, um die usprünglichen Daten nicht zu sehr zu verfälschen.\nInzwischen gibt es brauchbare Werkzeuge zur Transskription von Mediendateien. Diese automatisch erstellten Transkripte müssen aber immer nachkontrolliert werden. Nur so wird das Risiko reduziert, dass sich die Bedeutung der Daten durch Transskriptionsfehler ändert.\n\n\n5.3.2 Technisch-unterstützte Datenerhebung\nBei der technisch-unterstützten Datenerhebung soll das manuelle Datensammeln durch technische Werkzeuge vereinfacht werden, indem bestimmte Daten automatisch erfasst werden. Ein wichtiges Instrument für die technisch-unterstützte Datenerhebung sind Formulare. Formulare sind strukturierte Dokumente zur systematischen und wiederholten manuellen Eingabe von Daten durch Menschen.\nIm Gegensatz zu Papierfromularen können digitale Formulare die Eingaben überprüfen und bieten unterschiedliche Eingabeformate. Digitale Formulare können auch automatisch Daten erfassen, die nicht direkt eingegeben werden, wie beispielsweise den Zeitpunkt der Eingabe. Die populärste Art der digitalen Formulare sind inzwischen online Formulare, weil sie die grösste Flexibilität bei einer vergleichsweise niedrigen Nutzungsschwelle bieten.\nEs lassen sich zwei Arten von Diensten für online Formulare unterschieden:\n\nFormular-Dienste, wie z.B. MS-Forms oder Google Forms. REFERENCE\nUmfrage- bzw. Survey-Dienste, wie z.B. Survey Monkey oder Lime Survey.\n\nDer wesentliche Unterschied zwischen diesen Diensten sind zusätzliche Funktionen zur Datenerhebung. Survey-Dienste bieten zusätzliche Funktionen, wie die Anonymisierung der Daten, zusätzliche Daten über die Ausführung, Fragebogendokumentation oder die Unterstützung von wiederholten Befragungen.\nAlle Formulare erlauben die Eingabe von Daten mit offenen und geschlossenen Wertebereich sowie das Auslesen der Daten in tabellarischer Form. Für jedes ausgefüllte Formular wird dazu eine Zeile erstellt, wobei die Eingabefelder jeweils als eine Spalte abgebildet werden.\n\nDefinition 5.5 Eine Eingabemöglichkeit eines Formulars wird als Fragebogen-Item oder schlicht als Item bezeichnet.\n\nItems mit offenen Wertebereich sind Langantworten und Dateien. Alle anderen Eingaben haben einen geschlossenen Wertebereich. Die sog. Kurzantworten erscheinen als offene Eingabefelder. Ihr Wertebereich kann aber durch Validierungsregeln eingeschränkt werden.\nBei den Items mit geschlossenen Wertebereich kann zwischen einfachen und mehrfachen Eingaben unterschieden werden. Bei einfachen Eingaben kann nur eine Antwortmöglichkeit ausgewählt werden (sog. Single-Choice). Der Wertebereich dieser Items wird über die Antwortmöglichkeiten festgelegt.\nSkalen sind Single-Choice-Items für einen ordinalen Wertebereich. Oft werden die Antwortmöglichkeiten mit einem Rang versehen.\nEin Spezialfall der Skalen ist die Likert-Skala, bei der eine lineare Skala mit einer Bewertung zwischen zwei Extremwerten versehen wird. Die Extrem-Pole sollten möglichst weit auseinander gewählt werden. Z.B. “trifft absolut nicht zu” und “trifft voll und ganz zu” und nicht “trifft nicht zu” und “trifft zu”. Obwohl Likert-Skalen subjketive Ansichten messen, wird der Wertebereich meist als intervallskalierter Wertebereich behandlet.\nBei mehrfachen Eingaben können mehrere Antwortmöglichkeiten ausgewählt werden. Mehrfache Eingaben werden auch als Multiple-Choice-Items bezeichnet. Im Gegensatz zu Single-Choice-Items haben Multiple-Choice-Items immer einen binären Wertebereich. Das bedeutet, dass jede Antwortmöglichkeit nur zwei Werte annehmen kann: ausgewählt oder nicht ausgewählt. Intern werden Multiple-Choice-Items als separate Items gespeichert und auch so tabellarisch dargestellt. Ein Multiple-Choice-Item hat deshalb immer eine Ja/Nein-Frage als Grundlage, wobei die fehlende Auswahl durch einen nicht vorhandenen Eintrag repräsentiert wird.\nDie sog. Grid-Items oder Fragebatterien sind Items, bei denen mehrere Fragen mit der gleichen Antwortmöglichkeiten gestellt werden. Entsprechend haben diese Items den gleichen Wertebereich. Zu den Grid-Items sind oft als Skalen oder als Multiple-Choice-Items organisiert. Diese Items werden oft als Matrix dargestellt, wobei die Fragen als Zeilen und die Antwortmöglichkeiten als Spalten dargestellt werden. Intern werden die einzelnen Fragen von Grid-Items als separate Items gespeichert und werden auch tabellarisch so abgebildet. Dabei gelten die gleichen Regeln wie bei einfachen Single-Choice- und Multiple-Choice-Items.\nEine Fragebatterie aus Likert-Skalen wird Semantisches Differential genannt. Oft handelt es sich bei den Items um Aussagen, die über die gleiche Skala bewertet werden.\nEin besonderes Grid-Item ist das Ranking oder Sortieren. Bei dieser Art von Items werden mehrere Antwortmöglichkeiten in eine Reihenfolge gebracht. Die Antwortmöglichkeiten werden als eigene Items gespeichert, wobei der Wertebereich für jede Antwortmöglichkeit durch die möglichen Ränge festgelegt ist. Diese Items haben einen ordialen Wertebereich.\nEine Variante des Sortieren sind Zuordnungs-Items. Bei diesen Items muss jedem Wert aus einer Liste von Werten jeweils ein Wert aus einer zweiten Liste zugeordnet werden. Die Werte aus der ersten Liste werden als Items gespeichert und die Werte aus der zweiten Liste legen den Wertebereich der Items. Diese Items haben einen nominalen Wertebereich.\nGelegentlich werden Fotos oder Bilder angeboten und die Teilnehmenden werden gebeten, Bereiche auf diesen Bildern auszuwählen. Dabei handelt es sich um eine Variante eines Multiple-Choice-Grids, bei dem die Antwortmöglichkeiten als Bilder dargestellt werden.\nDurch die Wahl der Fragetypen und dem Festlegen der Wertebereiche von Formular-Items werden wird die Information kodiert.\n\n\n5.3.3 Automatische Datenerhebung\nBei der automatischen Datenerhebung werden Daten automatisch erfasst und gespeichert.\nBei der automatischen Datenerhebung werden grundsätzlich drei Kategorien unterschieden:\n\nSnapshots erfassen eine Momentaufnahme eines Systems. Bei Snapshots handelt es sich immer um komplexe strukturierte Daten. Ein Snapshot kann beispielsweise ein Foto, ein MRI-Scan oder eine Gen-Sequenz sein. Ein Snapshot liefert einen Datensatz, der in der Regel sehr viele Werte umfassst. Snapshots werden oft von speziellen Geräten erfasst und gespeichert.\nMetriken geben Auskunft über Zustände zu einem bestimmten Zeitpunkt. Oft werden Metriken in regelmässigen Abständen erfasst. Bei Metriken handelt es sich immer um einfache strukturierte Daten. Eine Metrik kann beispielsweise die Anzahl der Besucher einer Webseite zu einem bestimmten Zeitpunkt oder die Temperatur in einem Raum sein. Eine Metrik hat üblicherweise drei Eigenschaften:\n\nName\nWert\nZeitpunkt\n\nLogs geben Auskunft über Ereignisse in einem System. Ein Log-Eintrag wird erfasst, wenn ein Ereignis eintritt. Logs sind meist strukturierte oder semi-strukturierte Daten. Ein Log-Eintrag kann beispielsweise die Anmeldung eines Benutzers an einem System oder das Öffnen einer Webseite sein. Ein Log-Eintrag ist oft über zwei Hauptmerkmale definiert:\n\nZeitpunkt\nEreignismeldung\n\nLog-Einträge werden oft chronologisch in der Reihenfolge der Ereignisse gespeichert.\n\nNur weil Sensoren und andere datengenerierende Instrumente verwendet werden, findet eine automatische Datenerhebung unter Umständen nicht statt. Ein entsprechendes Instrument muss die Funktion bereitstellen, um Metriken und/oder Logs zu generieren und bereitzustellen.\nBei der automatischen Datenerhebung für Metriken und Logs werden meistens mehrere Systeme gemeinsam eingesetzt. Ein System erfasst die Daten und ein anderes System speichert die Daten in einer Datenbank. Die Daten werden in der Regel in einem Datenstrom bzw. Zeitreihe erfasst und gespeichert.\n\n\n\n\nZHAW. (2023). ZHAW Meldung vom 24.8.2023. https://twitter.com/ZHAW/status/1694731482051309775"
  },
  {
    "objectID": "kapitel/03-daten-organisieren/kapitel.html#daten-strukturieren",
    "href": "kapitel/03-daten-organisieren/kapitel.html#daten-strukturieren",
    "title": "6  Daten organisieren",
    "section": "6.1 Daten strukturieren",
    "text": "6.1 Daten strukturieren\nIm Kapitel 5 wurde die Bedeutung des Datenschemas für das Sammeln von Daten behandelt. Ein Schema gibt vor, welche Werte einen Datensatz bilden. Dieser Abschnitt konzentriert sich auf die Umsetzung des Datenschemas.\n\n6.1.1 Daten als Tabellen\nDaten werden oft als Tabellen präsentiert. Tabellen sind eine einfache und intuitive Form der Datenorganisation. Vorläufig lassen sich Tabellen wie in Definition 6.1 definieren. Diese Definition wird in Kapitel 8.3 erweitert, um verschiedene Datenstrukturen zu unterscheiden.\n\nDefinition 6.1 Tabellen formen eine Datenstruktur, die Zeilen und Spalten hat und in der alle Zeilen die gleiche Breite und alle Spalten die gleiche Länge haben.\n\nTabellen organisieren Daten in Zeilen und Spalten, wobei jede Zeile und jede Spalte eine Überschrift haben kann.\n\nDefinition 6.2 Die Überschriften einer Tabelle werden als Namen, bzw. Spaltennamen und Zeilennamen bezeichnet.\n\nEine bestimmte Spalte in einer bestimmten Zeile heisst Tabellenzelle oder schlicht Zelle. Eine Zelle enthält genau einen Wert.\nDefinition 6.1 legt fest, dass eine Tabelle keine Zellen haben kann, die sich über mehrere Zeilen oder Spalten erstrecken. Viele Publikationen zeigen jedoch Datenstrukturen mit solchen Zellen. Solche Datenstrukturen sind keine Tabellen im Sinne von Definition 6.1.\n\nDefinition 6.3 Eine tabellenartige Struktur mit Tabellenzellen, die sich über mehr als eine Zeile oder eine Spalte erstrecken heisst tabellarische Darstellung.\n\nTabellarische Darstellungen dienen der Präsentation von Daten und Ergebnissen. Sie sind nicht für die Datenorganisation geeignet.\n\n\n\n\n\n\nTipp\n\n\n\nIn Berichten und Publikationen wird nicht zwischen Tabellen und tabellarischen Darstellungen unterschieden. Beide Strukturen werden unter Tabellen zusammengefasst. Beide Strukturen einheitlich als Tabelle beschriftet und nummeriert.\nDiese Vereinfachung ist nur für die Präsentation von Daten erlaubt.\n\n\n\n\n6.1.2 Begriffe\nTabellen dienen zur systematischen Erfassung von Daten. Meist repräsentieren Tabellen Messungen, die später ausgewertet und analysiert werden sollen. Die Datenorganisation in Tabellen strukturiert Daten entlang zwei Dimensionen. Für die Datenerfassung werden die Daten in Zeilen und Spalten organisiert, wobei die Spalten meistens als Merkmale und die Zeilen als Messereignisse bezeichnet werden. Gemeinsam bilden die Merkmale und Messereignisse eine Stichprobe (engl. sample).\n\nDefinition 6.4 Ein Merkmal ist eine Eigenschaft, die in einer Messung durch einen Messwert erfasst wird. In der Statistik werden Merkmale in der Statistik als Variablen bezeichnet.\n\nEin Merkmal ist immer als Vektor organisiert. Alle Werte eines Merkmals haben also den gleichen Datentyp und den gleichen Wertebereich.\n\nDefinition 6.5 Ein Messereignis fasst ein oder mehrere gemeinsam gemessenen Merkmale zusammen. Ein Messereignis wird auch als Datensatz bezeichnet. Bei der Datenvisualisierung werden Messereignisse als Datenpunkte bezeichnet.\n\nEin Datensatz ist immer eine Liste von Werten, deren Datentypen und Wertebereichen voneinander verschieden sein können.\n\n\n\n\n\n\nHinweis\n\n\n\nDer Begriff Datensatz wird im Deutschen mehrdeutig verwendet. Es ist nicht immer klar, ob ein Datensatz ein Zeile in einer Tabelle oder eine ganze Tabelle bezeichnet. Im Englishen wird der Begriff Datensatz entweder mit data record (etwa Dateneintrag) für eine Zeile in einer Tabelle benutzt. Die Begriffe data set (Datenmenge) oder data frame (Datenraster) bezeichnen eine ganze Tabelle.\n\n\nDie Merkmale beschreiben gemeinsam ein Messereignis. Weil es sich bei den Merkmalen eines Messereignisses um zusammengehörende Werte handelt, wird auch der Begriff Entität (gegebene Einheit; eindeutig identifizierbare, zusammenhängende Größe) verwendet.\nMessungen bilden einen Ausschnitt einer Grundgesamtheit ab. Eine Grundgesamtheit umfasst alle prinziell messbaren Entitäten. Eine Stichprobe ist eine Teilmenge der Grundgesamtheit, die nur die tatsächlich gemessenen Entitäten enthält.\n\nDefinition 6.6 Alle prinzipiell messbaren Entitäten bilden eine Grundgesamtheit.\n\n\nDefinition 6.7 Eine Stichprobe ist die Gesamtheit der gemessenen Entitäten ab.\n\nDie Statistik befasst sich mit den Methoden, um von Stichproben auf die ursprüngliche Grundgesamtheit zu schliessen. Aus Sicht der Datenwissenschaft und Datenverarbeitung ist die Grundgesamtheit unerheblich, weil die nicht gemessenen Entitäten nicht in den Daten nicht abgebildet sind und deshalb unbekannt bleiben müssen!\n\n\n6.1.3 Daten normalisieren\nEin Datensatz kann Werte aus einer oder mehreren Messungen beinhalten. Wenn mehrere unabhängige Messungen in einem Datensatz zusammengefasst werden, dann beschreiben die entsprechenden Vektoren die gleichen Merkmale aus unterschiedliche Messereignissen.\n\nDefinition 6.8 Unabhängige Messungen sind Messungen für die gleichen Merkmale zu unterschiedlichen Zeitpunkten.\n\nEine Stichprobe mit unabhängigen Messungen für die gleiche Entität ist nicht normalisiert.\nAbbildung 6.1 zeigt einen Ausschnitt einer Stichprobe mit Werten aus mehreren unabhängigen Messungen bzw. Messereignissen. Jeder Vektor in dieser Stichprobe entspricht dabei unabhängigen Messungen.\n\n\n\nAbbildung 6.1: Beispiel einer Stichprobe mit mehreren Messereignissen pro Datensatz\n\n\nEin Messereignis bezeichnet das gleichzeitige Erheben zusammengehörender Daten. Wenn beispielsweise das gleiche Objekt zu unterschiedlichen Zeitpunkten gemessen wird, dann liegen unabhängige Messereignisse vor.\nWenn Daten in einer Tabelle jeweils ein Messereignis repräsentieren, dann liegen sie in Normalform vor. In der Normalform ist die Tabelle gleichbedeutend mit der zugehörigen Stichprobe. Jede Zeile ist der Datensatz einer beobachteten Entität. Die Spalten repräsentieren die Messungen.\n\n\n\n\n\n\nHinweis\n\n\n\nBeachten Sie, dass unabhängige Messereignisse nicht mit unabhängigen Variablen in der Statistik verwechselt werden darf.\n\n\n\nDefinition 6.9 Die Normalform einer Stichprobe ist eine Tabelle, in der jedes Merkmal genau einmal vorkommt und alle Werte in einem Datensatz zum gleichen Messereignis gehören.\n\nAbbildung 6.2 zeigt einen Ausschnitt der Normalform der Stichprobe aus Abbildung 6.1. Die Normalform einer Stichprobe erscheint auf dem ersten Blick unübersichtlicher als Varianten mit mehreren Messereignissen pro Datensatz. Die Normalform hat jedoch den Vorteil, dass die Stichprobe einfacher verarbeitet werden kann.\n\n\n\nAbbildung 6.2: Beispiel einer Stichprobe in der Normalform\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nWeil die Normalform oft schwer lesbar ist, werden Daten für die Präsentation in nicht-normalisierter Form bereitgestellt. Die Grundlage für diese Darstellung der Daten sollte möglichst die Normalform sein.\nBeim Datensammeln sollte möglichst die Normalform eingehalten werden.\n\n\n\nBeispiel 6.1 (Raumtemperatur und Helligkeit) Die am Montag um 13 Uhr gemessene Temperatur und Helligkeit gehören zum gleichen Messereignis. Wird die Messung am Dienstag um 8 Uhr wiederholt, dann gehört die Temperatur und Helligkeit ebenfalls zum gleichen Messereignis.\nDie Normalform dieser Daten wäre entsprechend:\n\n\n\nTag\nUhrzeit\nTemperatur\nHelligkeit\n\n\n\n\nMontag\n13\n21.5\n0.9\n\n\nDienstag\n8\n22.1\n0.5\n\n\n\nDie Temperatur am Montag und 13 Uhr und am Dienstag um 8 Uhr sind unabhängige Messereignisse für die Temperatur. Werden die Werte nicht-normalisiert gegenübergestellt, können Menschen die Werte oft leichter vergleichen. Eine solche Tabelle sähe dann wie folgt aus:\n\n\n\n\n\n\n\n\n\nTemperatur Montag, 13h\nTemperatur Dienstag, 8h\nHelligkeit Montag, 13h\nHelligkeit Dienstag, 8h\n\n\n\n\n21.5\n22.1\n0.9\n0.5\n\n\n\nDiese zweite Tabelle macht deutlich, dass viele nicht normalisierte Tabellen einen Teil der Daten in Vektornamen kodieren. Diese Daten sind für die Datenverarbeitung nur indirekt zugänglich. Deshalb sollten Daten möglichst in der Normalform vorliegen."
  },
  {
    "objectID": "kapitel/03-daten-organisieren/kapitel.html#daten-ablegen",
    "href": "kapitel/03-daten-organisieren/kapitel.html#daten-ablegen",
    "title": "6  Daten organisieren",
    "section": "6.2 Daten ablegen",
    "text": "6.2 Daten ablegen\n\n6.2.1 Dateien und Verzeichnisse\nDatendateien sollten möglichst isoliert und vor versehentlichen überschreiben geschützt werden.\nDaten werden am Besten immer in eigenen Dateien abgelegt. Diese Dateien enthalten nur Werte und keine Umformungen oder Berechnungen. Wenn ein Projekt mehrere Datenerhebungen umfasst, dann sollten die Daten für jede Erhebung in einer eigenen Datei abgelegt werden. Hierzu sollte eine eindeutige Bezeichnung verwendet werden, die auf die Erhebung hinweist. Ein geeignetes Format für Dateinamen ist ein Datum-Kennungs-Format, die die Erhebung eindeutig identifiziert. Dabei wird das Datum in der Form YYYY-MM-DD angegeben, gefolgt von einer kurzen Bezeichnung der Erhebung.\n\nBeispiel 6.2 (Dateiname im Datum-Kennungsformat)  \n2020-10-01-erhebung-1.csv\n\nDurch die inverse Datumsschreibweise dieses Formats lassen sich die Dateien leicht nach Datum sortieren und schneller wiederfinden.\nDamit die Daten von anderen Teilen eines Projekts getrennt werden können, sollten die Daten in einem eigenen Verzeichnis abgelegt werden. Dabei sollte das Verzeichnis einen Namen haben, der anzeigt, dass nur Datendateien in diesem Verzeichnis abgelegt werden. Eine solche Bezeichnung könnte beispielsweise data oder daten sein.\n\n\n6.2.2 Daten-Repositories\nEine deutlichere Trennung der Daten von den Ergebnissen ist mit Hilfe von eigenen Daten-Repositories möglich. Dabei werden die Daten separat von den Ergebnissen gespeichert, versioniert und synchronisiert.\nEin Daten-Repository sollte immer nur die Daten eines Projekts enthalten. Das Repository sollte einen Namen haben, der anzeigt, dass es sich um ein Daten-Repository handelt.\nBei der Verwendung eines getrennten Daten-Repositories entfällt die Notwendigkeit, die Daten in einem eigenen Verzeichnis abzulegen. Diese Funktion übernimmt das Repository.\n\n\n6.2.3 Datenbanken\nDatenbanken sind eine weitere Möglichkeit, Daten zu abzulegen. Datenbanken werden über spezielle Software verwaltet. Sie eigenen sich besonders für die Verwaltung von grossen und kontinuierlich wachsenden Datenmengen, die von mehreren Personen bearbeitet werden und die über eine längere Zeit verfügbar sein müssen.\nDatenbanken haben den Vorteil, dass gezielt Teile der Daten für spezielle Analysen geladen werden können. Dadurch können auch sehr grosse Datenmengen effizient verarbeitet werden.\n\n\n6.2.4 Datenverlust vermeiden\nAllein die Organisation von Daten in Tabellen, die in den richtigen Dateien in einem eigenen Verzeichnis abgelegt sind, ist keine Garantie, dass die Daten sicher sind. Daten können durch versehentliches Überschreiben oder Löschen verloren gehen.\nDaten können beispielsweise durch Hardware-Fehler oder einen anderen Verlust der Hardware verloren gehen. Deshalb sollten Daten gesichert werden.\nDie einfachste Form der Sicherung sind getrennte Speicherorte. Dazu werden die Daten an mindestens zwei Orten gespeichert. Diese Art der Sicherung heisst Datenreplikation. Wenn die Daten an einem Ort verloren gehen, können sie über den anderen Ort wiederhergestellt werden. Dazu müssen zwei Bedingungen erfüllt sein:\n\nDie Daten müssen in beiden Daten vollständig vorhanden sein.\nDie Speicherorte müssen unabhängig voneinander sein.\n\nZum Beispiel ist eine externe Festplatte für Sicherungen eines Laptops kein geeigneter Speicherort, wenn beide Geräte im gleichen Rucksack transportiert werden. Wenn der Rucksack verloren geht oder gestohlen wird, wären die Daten auf der externen Festplatte ebenfalls verloren.\nDie Versionierung der Daten ein wichtiges Instrument zur Vermeidung von Datenverlusten. Moderne Versionierungssysteme arbeiten dabei zweistufig (s. Kapitel 7):\n\nDie Daten werden lokal versioniert, so dass die Daten aus den Versionierungspunkten wiederhergestellt werden können.\nDie Versionen werden in der verteilten Versionsverwaltung synchronisiert. Dadurch werden die Daten automatisch repliziert.\n\nDurch diese Vorgehensweise sind die Daten an mindestens zwei Orten gespeichert. Wenn die Daten an einem Ort verloren gehen, können sie über den anderen Ort wiederhergestellt werden.\nDie dritte Technik zur Vermeidung von Datenverlusten ist die Archivierung. Für die Datenarchivierung werden die Daten gebündelt und in einem Archiv abgelegt. Die Archivierung erfolgt meist nach Abschluss eines Projekts oder einer Studie. Alternativ sollten Daten bereits archiviert werden, sobald die Datenerhebung abgeschlossen wurde.\n\n\n\n\n\n\nPraxis\n\n\n\nVersionierungssysteme wie git können aus Versionen von Daten automatisch Archivdateien erzeugen. git Hosting-Plattformen bieten hierfür eigene Ablagen. Die Archivdateien können anschliessend an einem sicheren Ort abgelegt werden.\n\n\n\n\n\n\n\n\nDatenbanken sind kein Ersatz für Sicherungen\n\n\n\nObwohl Datenbanken eine sehr gute Möglichkeit sind, Daten zu verwalten, sind sie kein Ersatz für Sicherungen. Datenbanken können zwar Daten speichern, aber sie können keine Daten sichern.\nEine Datenbank kann erst dann einen Datenverlust vorbeugen, wenn die Datenbank selbst gesichert wird. Das bedeutet, dass die Datenbank zumindest repliziert werden muss."
  },
  {
    "objectID": "kapitel/03-daten-organisieren/kapitel.html#datenmanipulation",
    "href": "kapitel/03-daten-organisieren/kapitel.html#datenmanipulation",
    "title": "6  Daten organisieren",
    "section": "6.3 Datenmanipulation",
    "text": "6.3 Datenmanipulation\nNach dem Importieren und vor dem Exportieren muss die Datenintegrität sichergestellt werden. Das bedeutet, dass zwischen allen Werten und Ergebnissen eine systematische Verbindung besteht. Werte dürfen deshalb nicht willkürlich verändert, gelöscht oder hinzugefügt werden.\nEin grosses Problem bei der Arbeit mit Daten ist die nachträgliche Datenmanipulation. Dabei werden die erhobenen Daten verändert, wobei sich die Veränderung nicht einwandfrei reproduzieren lässt.\n\nDefinition 6.10 Eine Datenmanipulation heisst jede Veränderung von Daten bei denen Werte unsystematisch hinzugefügt, beliebige Werte verändert oder gelöscht werden.\n\nWeil nach einer Datenmanipulation die ursprünglichen Daten nicht mehr eindeutig reproduziert werden können, lassen sich die Ergebnisse nicht mehr bestätigen oder wiederlegen. Das kommt einem vollständigen Datenverlust gleich, denn alle vorliegenden Daten können manipuliert worden sein.\n\n\n\n\n\n\nKeine Datenreproduktion möglich\n\n\n\nWird eine Datenmanipulation entdeckt oder ist eine Manipulation sehr wahrscheinlich, dann ist es nicht mehr möglich, die ursprünglichen Daten zu reproduzieren. In diesem Fall gelten alle Daten eines Datensatzes als komprimitiert. Solche Daten dürfen auf keinen Fall für Analysen weiterverwendet werden.\n\n\nEine Datenmanipulation muss von der systematischen Datenverarbeitung abgegrenzt werden. Bei der systematischen Datenverarbeitung werden Daten mit Hilfe von Werkzeugen und definierten Methoden verarbeitet. Dabei gehen keine Daten verloren, werden neue Werte erzeugt oder bestehende Werte verändert. Bei der systematischen Datenverarbeitung lassen sich alle Ergebnisse aus den ursprünglichen Daten herleiten.\nFalls Werte erzeugt werden, dürfen diese nicht willkürlich mit den ursprünglichen Daten vermischt werden. Stattdessen sind solche neuen Werte von den Daten zu trennen.\n\n\n\n\n\n\nPraxis\n\n\n\nGenerierte Werte dürfen nur über eine Kodierung (Kapitel 15) mit den ursprünglichen Daten verknüpft werden. Die Kodierung muss so gestaltet sein, dass die ursprünglichen Daten jederzeit reproduziert werden können.\n\n\n\n\n\n\n\n\nMerke\n\n\n\nUm eine systematische Datenverarbeitung belegen zu können, müssen Daten, Ergebnisse und alle Operationen, die von den Daten zu den Ergebnissen, vorgehalten werden.\n\n\n\n\n\n\n\n\nKeine Datenmanipulation\n\n\n\nSolange alle Werte im Rahmen des Schemas erhalten bleiben, liegt keine Datenmanipulation vor. Dazu gehören insbesondere:\n\nNachvollziehbare logische, methodische und systematische Fehler.\nKorrektur von Vektornamen/Variablen und deren Übersetzung in eine andere Sprache.\nBegründetes Runden, wenn dadurch keine Datenverzerrung entsteht. Als Richtlinie gilt die Messgenauigkeit der verwendeten Instrumente.\nUmbenennen von Dateien und Verzeichnissen.\nUmwandlung von Masseinheiten, z.B. Konvertierung von Grad Fahrenheit in Grad Celsius.\nAnonymisierung von Datensätzen.\n\n\n\nEs gibt zwei Arten der Datenmanipulation.\nDie absichtliche Manipulation von Daten erfordert aktives Eingreifen einer Person mit Zugang zu den Daten. ist ein schweres professionelles Delikt. Diese Art von Manipulation kann das Löschen von unpassenden Daten sein, das Verändern von Werten betreffen bzw. Werte für die Studienergebnisse passend machen oder auch neue Daten erfinden. Solche Datenmanipulationen wiegen wissenschaftlich oft schwerer als Plagiarismus und können bei professionellen Analysen als Urkundenfälschung gewertet werden.\nDie versehentliche Datenmanipulation kommt sehr viel häufiger vor als eine absichtliche Datenmanipulation. Die versehentliche Datenmanipulation kann viele Ursachen haben und reicht von der fehlerhaften Bedienung von Tools und Werkzeugen über Software-Fehler bis zum Überschreiben von Daten mit Ergebnissen.\nEine sehr häufig vorkommende Form der versehentlichen Datenmanipulation ist die automatische Datentyperkennung von Excel. Dabei werden Daten beim Import oder bei der Eingabe in einer Excel-Arbeitsmappe in einen unerwünschten Datentyp geändert, wobei sich auch der Wert der Daten ändert. Wenn durchgehend mit Excel gearbeitet wird, müssen diese Fehler vorgebeugt werden. Diese Praktiken erfordern von allen Beteiligten eine grosse Arbeitsdisziplin, was sich im Alltag nicht immer fordern lässt. Deshalb ist es oft einfacher, die Daten in einem einfacheren Dateiformat (z.B. CSV oder JSON) zu erfassen und anschliessend diese Daten in Excel als externe Daten zu importieren.\n\n\n\n\n\n\nPraxis\n\n\n\nUm versehentliche Datenmanipulation zu vermeiden, sollte ausser bei Messungen nie direkt mit den Daten gearbeitet werden. Stattdessen sollten die Daten immer in einer separaten Datei gespeichert und versioniert werden. Aus dieser Datei werden die Daten anschliessend importiert und bearbeitet. Die Ergebnisse können in andere Dateien exportiert werden.\nDurch die Versionierung kann jederzeit auf die ursprünglichen Daten zurückgegriffen und wiederhergestellt werden, selbst wenn sie versehentlich oder absichtlich überschrieben oder gelöscht wurden."
  },
  {
    "objectID": "kapitel/01-tool-chain/git_github.html#git-installieren",
    "href": "kapitel/01-tool-chain/git_github.html#git-installieren",
    "title": "7  Versionierung mit Git und GitHub",
    "section": "7.1 git installieren",
    "text": "7.1 git installieren\ngit besteht im wesentlichen aus einem Kommandozeilen-Werkzeug, das alle Funktionen von git bereitstellt. Dieses Werkzeug wird oft auch als CLI-Tool bezeichnet. Es für die meisten GUI-Apps die Voraussetzung für die Arbeit. Ausserdem stellen nicht alle GUI-Apps alle git-Funktionen bereit und gelegentlich kann es in Spezialfällen notwendig sein, git direkt zu verwenden. Deshalb sollte git immer auf einem Computer installiert sein.\n\n7.1.1 git unter MacOS installieren\nEs wird dringend empfohlen die offiziell von Apple vertriebene Version von git zu verwenden.\nUnter MacOS ist git Teil der internen Entwicklungsumgebung. Dazu sollte XCode installiert sein. XCode muss mindestens einmal gestartet worden sein, damit die Lizenzbedingungen erstmalig akzeptiert werden. Anschliessend müssen die XCode Command Line Tools dem System hinzugefügt werden. Wählen Sie die Version dieser Tools immer so aus, dass sie zu der von Ihnen installierten Version von XCode passt. Für diesen Download benötigen Sie einen Entwicker-Account auf Apple’s Entwicklerplattform. Dieser Account ist kostenlos. Nach der Installation der XCode Command Line Tools ist auch git auf Ihrem Rechner installiert.\n\n\n7.1.2 git unter Windows installieren\nUnter Windows stellt das Projekt git for Windows eine für Windows Systeme angepasste Version von git bereit. Diese Version bietet neben git zusätzliche Werkzeuge, mit denen sich Anleitungen leichter nachvollziehen lassen.\n\n\n7.1.3 Grafische Oberflächen für git\nGUI-Apps die Arbeit mit git. Für die Arbeit mit diesem Buch werden die folgenden Werkzeuge empfohlen.\n\nVisual Studio Code unterstützt git in der Basisinstallation.\nGitLens ist eine Erweiterung für Visual Studio Code und bindet zusätzliche Funktionen für das Versionsmangement direkt in die IDE ein.\nGitHub Desktop stellt eine einfache Benutzeroberfläche für die Basisaufgaben mit GitHub am Computer Desktop bereit.\nGitKraken bietet unfangreiche Funktionen zum Versionsmanagement mit git. Mit GitKraken lassen sich fast alle git-Aufgaben über die GUI lösen. Ausserdem ist GitKraken nicht auf GitHub als Hosting-Plattform beschränkt.\n\n\n\n7.1.4 git-Hosting-Plattformen\ngit ist zuerst auf den eigenen Computer beschränkt. Für das Zusammenarbeiten mit anderen und die Sicherung der eigenen Versionierung empfielt sich die Verwendung einer sog. git-Hosting-Plattform. Eine git-Hosting-Plattform erlaubt es die Versionierung eines Projekts online zu sichern und mit anderen zu teilen, die bietet Projektmanagementfunktionen sowie Automatisierungsmöglichkeiten, die über die Kernfunktionen von git hinausgehen.\nDie wichtigsten git-Hosting-Plattformen mit gleichwertigem Funktionsumfang sind:\n\nGitHub\nGitLab\nGitea\n\nJede dieser Plattformen benötigt ein eigenes Benutzerkonto.\n\n\n\n\n\n\nHinweis\n\n\n\nDieses Buch verwendet GitHub für Code-Beispiele, Diskussionen und andere Funktionen. GitLab und Gittea sind Alternativen zu GitHub mit gleichwertigen Funktionsumfang und ähneln sich bei der Bedienung und im Funktionsumfang stark. Aus Sicht der Projektorganisation sind die Plattformen fast identisch. Es gibt vor Allem emotionale und wirtschaftliche Gründe, sich für die eine oder die andere Plattform zu entscheiden."
  },
  {
    "objectID": "kapitel/01-tool-chain/git_github.html#git-konzepte",
    "href": "kapitel/01-tool-chain/git_github.html#git-konzepte",
    "title": "7  Versionierung mit Git und GitHub",
    "section": "7.2 git-Konzepte",
    "text": "7.2 git-Konzepte\n\n7.2.1 Repositories, Clones und Forks\nDie Grundlage der Versionierung mit git ist das Repository. Ein Repository enthält die Dateiversionen eines Projekts. Aus den Versionen kann das Projekt auf den Zustand zu jedem Versionierungszeitpunkt wiederhergestellt werden.\nEin Repository enthält alle versionierten Dateien und deren Versionen. Auf dem eigenen Computer sieht ein git-Repository ersteinmal wie ein normales Verzeichnis aus. Die Versionen sind in einer versteckten Versionsdatenbank gespeichert, über die mit dem git-Kommando oder einem entsprechenden GUI-Tool interagiert wird.\nUm aus einem normalen Verzeichnis ein git-Repository zu erstellen, muss das Verzeichnis für git initianlisiert werden. Im Terminal kann ein beliebiges Verzeichnis zu einem Repository initialisiert werden.\ngit init\ngit-Repositories können aus zwei Arten synchronisiert werden: Durch Clone und durch Forks. Jedes Kopie eines git-Repositories enthält immer alle Versionen des Projekts. Wird ein Repository auf einen anderen Computer synchronisiert, dann wird das entfernte Repository als Remote bezeichnet. Handelt es sich bei diesem Repository um ein Quell-Repository, dann wird dieses auch als Upstream-Repository bezeichnet. Die lokale Variante des Repositories wird auch als Downstream-Repository bezeichnet.\nZwei gleichwertige Kopien eines Repositories werden als Clone bezeichnet. Gleichwertig bedeutet, dass die Versionen zwischen diesen Repositories direkt synchronisierbar sind.\nNeben gleichwertigen Repositories gibt es noch hierarchische Beziehungen zwischen Repositories. Dabei kann nur vom Upstream Remote direkt in die lokale Kopie sysnchronisiert werden. Änderungen im Downstream-Repository können nicht direkt in das Upstream Remote synchronisiert werden. Das Downstream Repository wird als Fork bezeichnet. Änderungen eines Forks können über sog. Pull-Requests an das Upstream-Repository gesendet werden.\n\n\n7.2.2 Versionierungsstatus feststellen\nMit dem Kommando git status kann der aktuelle Änderungsstatus eines Repositories gestgestellt werden. In einem frisch initialisierten Repository liefert dieses Kommando die folgende Meldung.\nOn branch main\n\nNo commits yet\n\nnothing to commit (create/copy files and use \"git add\" to track)\nWird einem leeren Repository eine neue Datei hinzugefügt, zeigt git status an, dass die neue Datei noch nicht versioniert wird. Als Beispiel wird die Datei README.md mit dem folgenden Inhalt erstellt.\n# Mein erstes Projekt\nNach dem diese Datei gespeichert wurde, liefert git status die folgende Meldung.\nOn branch main\n\nNo commits yet\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n    README.md\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\n\n7.2.3 Versionierung durch Commits\ngit muss mitgeteilt werden, dass eine neue, noch nicht verfolgte Datei in die Versionierung aufgenommen wird. Die Meldung von git status gibt den Hinweis, dass das Kommando dazu verwendet werden muss.\nIm obigen Beispiel kann die neue mit git add README.md in die Versionierung aufgenommen werden.\nIm Gegensatz zu Cloud-Speichern führt git keine automatische Synchronisation bei Änderungen einer Datei durch. Stattdessen müssen zu versionierende Dateien und Änderungen ihnen explizit versioniert werden. Auf den ersten Blick sieht das kompliziert aus, bietet im Entwicklungsprozess mehr Flexibilität und Kontrolle.\nDie Versionierung erfolgt immer in zwei Schritten:\n\nAuswahl der zuversionierenden Dateien mit git add.\nErstellen einer neuen Verion mit den Änderungen in den ausgewählten Dateien mit git commit.\n\nAuf der Kommandozeile werden die beiden Schritte durch zwei Aufrufe von git:\n# Alle geänderten und neuen Dateien für die Versionierung auswählen\ngit add . \n# Eine neune Version für die ausgewählten Dateien erzeugen.\ngit commit\nFalls nur verfolgte Dateien in einer Version aufgenommen werden sollen, dann können die beiden Schritte mit dem folgenden Kommando zusammengefasst werden.\ngit commit -a\nSollen neue, noch nicht versionierte Dateien in die Versionierung aufgenommen werden, dann müssen diese Dateien zwingend mit git add ausgewählt werden.\n\nGUI-Apps fassen die beiden Schritte automatisch zusammen.\n\nIm obigen Beispiel wurde die Datei README.md bereits zur Versionierung markiert. Diese Datei soll nun versioniert werden. Das wird mit git commit erreicht. Wird git commit direkt aufgerufen, startet git den sog. Message-Editor, um die Meldung für diese Version einzugeben. git versucht einen Vorschlag für die Meldung vorzuschlagen. Diese Meldung kann übernommen werden, indem die Rautesymbole am Zeilenanfang gelöscht werden. Abschliessend muss die Meldung gespeichert und geschlossen werden, damit git die Meldung übernimmt.\ngit erfordert, dass alle Versionen eine Meldung haben, die kurz die vorgenommenen Änderungen beschreibt. Diese Versionsmeldung erlaubt es, die Entwicklung eines Projekts schrittweise nachzuvollziehen.\n\nHinweis: Es ist zwar prinzipiell möglich auch leere Versionsmeldungen zu speichern, dadurch lässt sich die Versionsgeschichte nur schwer reproduzieren. Ausserdem wird die Auswahl einer bestimmten Version erschwert, weil aus der Versionsnummer nicht direkt hervorgeht, welche Änderungen vorgenommen wurden.\n\nDas Kommando git status zeigt nun an, dass keine Änderungen gefunden wurden.\nNachdem eine Version erstellt wurde, kann die Versionsgeschichte mit git log angezeigt werden. Das Ergebnis sieht nach dem initialen Commit des obigen Beispiels sieht etwas folgendermassen aus:\ncommit b281e4a03a4e71bcc41fa2f68e822b98c1555e1d (HEAD -&gt; main)\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 14:37:49 2023 +0200\n\n    Initial commit\n        new file:   README.md\nDie kryptische Symbolfolge in der ersten Zeile hinter dem Wort commit ist die Versionsnummer. Die Versionsnummer ist eindeutig im Projekt und über die meisten Projekte hinweg. In Klammern stehen die beiden Worte HEAD und main. HEAD zeigt die Markierung der aktuellen Version. main zeigt das Ende des aktuellen Versionszweig mit dem Namen main an. Dieser Information folgt der Name der Person, welche die Version erzeugt hat und dem Datum und der Uhrzeit, was den Versionszeitpunkt markiert. Abschliessend folgt die Versionsmeldung.\nDieser Schritt kann nun mit einer Änderung an der Datei README.md wiederholt werden. Hierzu wird zusätzlicher Text \"Eine Übung zur Git Versionierung\" ans Ende der Datei hizugefügt. Der Inhalt der Datei sollte nun wie folgt aussehen:\n# Mein erstes Projekt\n\nEine Übung zur Versionierung mit git.\nDiese Änderungen werden nun mit git commit -a versioniert.\ngit log zeigt nun die folgende Information.\ncommit 1504d416bb1ef926fde4d5e949f3ed330d97b065 (HEAD -&gt; main)\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 15:27:19 2023 +0200\n\n    Zusatzinformation zum Projekt\n      modified:   README.md\n\ncommit b281e4a03a4e71bcc41fa2f68e822b98c1555e1d\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 15:26:36 2023 +0200\n\n    Initial commit\n        new file:   README.md\nDie beiden Markierungen HEAD und main wurden zur aktuellen Version verschoben.\n\n\n7.2.4 Checkout\nEine Versionierung macht nur dann Sinn, wenn auf eine ältere Version zugegriffen werden kann. Das erlaubt das Kommando git checkout. Dieses Kommando benötigt eine Versionsnummer oder eine Markierung, um die entsprechede Version zuzugreifen.\nSo kann auf die erste Version im Projekt zugegriffen werden:\ngit checkout b281e4a03a4e71bcc41fa2f68e822b98c1555e1d\nDieses Kommando ersetzt alle Dateien im Arbeitsverzeichnis in den Zustand der angegebenen Version.\nDer Inhalt der Datei README.md ist nun wieder wie folgt.\n# Mein erstes Projekt\nDer Befehlt git log zeigt nun die Versionsgeschichte bis zum aktuell vorliegenden Inhalt.\ncommit b281e4a03a4e71bcc41fa2f68e822b98c1555e1d (HEAD)\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 15:26:36 2023 +0200\n\n    Initial commit\n        new file:   README.md\nHier gilt es zu beachten, dass die Markiergung main nicht mehr angezeigt wird. Diese Markierung ist nicht verloren, liegt aber aus Sicht der aktuellen Version in der Zukunft und wird deshalb nicht dargestellt. Wenn diese Versionsnummer nicht notiert wurde, kann auf die “zukunftigen” Versionen nicht leicht zugegriffen werden. Damit wieder auf die letzte Version zugegriffen werden kann, kann die Markierung main verwendet werden.\ngit checkout main\nMit diesem Kommando werden alle Dateien auf den neusten Stand gebracht. git log zeigt nun wieder die vollständige Versionsgeschichte.\n\n\n7.2.5 Tags\nDie Navigation über die Versionsnummern ist wegen der kryptischen Versionsnummern nicht ganz einfach. Ausserdem haben nicht alle Versionen in einem git-Repository die gleiche Bedeutung für die Nutzenden. Um zwischen wichtigen Versionen leichter navigieren zu können dienen Tags.\nTags sind spezielle Markierungen von Versionen in einem git-Repository. Das besondere Tag HEAD markiert immer die aktuell vorliegende Version. Mit dem Kommando git tag können neue Markierungen angelegt werden, um die Navigation zwischen Versionen zu erleichtern oder wichtige Zeitpunkte zu markieren.\nEin Tag darf keine Leerzeichen enthalten und sollte kompakt sein. Das folgende Beispiel markiert die erste Version im Repository.\ngit tag erste_version b281e4a03a4e71bcc41fa2f68e822b98c1555e1d\nTags werden in der Versionsgeschichte angezeit. git log zeigt dann das folgende Ergebnis.\ncommit 1504d416bb1ef926fde4d5e949f3ed330d97b065 (HEAD -&gt; main)\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 15:27:19 2023 +0200\n\n    Zusatzinformation zum Projekt\n      modified:   README.md\n\ncommit b281e4a03a4e71bcc41fa2f68e822b98c1555e1d (tag: erste_version)\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 15:26:36 2023 +0200\n\n    Initial commit\n        new file:   README.md\nNun kann auf die erste Version direkt zugegriffen werden, ohne die kryptische Versionsnummer kennen zu müssen.\ngit checkout erste_version\nDieses Kommando springt nun auf die erste Version in diesem Repository. Das kann mit git log überprüft werden.\nDas Kommando git tag -l listet alle verfügbaren Tags eines Repositories.\n\n\n7.2.6 Branching und Merging\nDie Markierung main ist kein Tag, sondern markiert einen Versionszweig. Diese Markierung wandert mit jedem Commit immer zur neusten Version. Es ist möglich mehrere Versionszweige im gleichen Repository zu führen. Ein Versionszweig wird als Branch bezeichnet.\nDie Versionszweige eines Repositories lassen sich mit dem Kommando git branch anzeigen. Im Beispiel-Repository liefert dieses Kommando das folgende Ergebnis.\n* main\nJedes git-Repository hat mindestens einen Versionszweig. Neuere Versionen von git verwenden main als Namen für diesen Haupt-Branch.\nVersionszweige werden in der Praxis dafür verwendet, um komplexe Änderungen im Projekt vorzunehmen oder um zusammenzuarbeiten.\nUm einen neuen Branch zu erstellen wird das Kommando git branch -c verwendet. Es fügt an der aktuell aktiven Version einen neuen Branch ein.\ngit checkout erste_version\ngit branch -c extras\nDieses Kommando erstellt am Tag erste_version einen neuen Branch mit dem Namen extras. git branch zeigt nun das folgende Ergebnis.\n* (HEAD detached at erste_version)\n  main\n  extras\nUm den extras-Branch zu aktivieren, muss dieser nur git checkout extras aufgerufen werden.\ngit log zeigt nun als Versionsgeschichte.\ncommit b281e4a03a4e71bcc41fa2f68e822b98c1555e1d (HEAD -&gt; extras, tag: erste_version)\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 15:26:36 2023 +0200\n\n    Initial commit\n        new file:   README.md\nDer Pfeil von HEAD nach extras zeigt an, dass neue Versionen zum extras-Branch und nicht mehr zum main-Branch hinzugefügt werden. So lassen sich Verzweigungen umsetzen. Das veranschaulicht das folgende Beispiel: Es wird eine neue Datei mit dem Namen AUTHORS.md und dem folgenden Inhalt.\nChristian Glahn (ZHAW)\nerstellt. Es handelt sich um eine neue Datei und deshalb muss sie mit git add zum Repository hinzugefügt und eine Version mit git commit erstellt werden.\ngit add AUTHORS.md\ngit commit -m \"Autorenliste\"\ngit log zeigt nun als Versionsgeschichte:\ncommit 5d10e17be5a2fc0d987db10644b35c73224f51f2 (HEAD -&gt; extras)\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 16:58:01 2023 +0200\n\n    Autorenliste\n\ncommit b281e4a03a4e71bcc41fa2f68e822b98c1555e1d (tag: erste_version)\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 15:26:36 2023 +0200\n\n    Initial commit\n        new file:   README.md\nDiese neue Datei existiert vorerst nur im extras-Branch. Diesem Branch können nun weitere Änderungen hinzugefügt werden.\nSind die Änderungen abgeschlossen, dann können diese Änderungen in den Hauptzweig übernommen werden. Dieses Zusammenführen von zwei Branches wird als Merge bezeichnet. Die folgenden Kommandos führen den Merge der Änderungen von extras in den main-Branch aus.\ngit checkout main\ngit merge -m \"Extras übernehmen\" extras\nDieses Zusammenführen bindet die Versionen aus dem extras-Branch in den main-Branch ein. Es gehen also keine Versionen verloren. git log zeigt das.\ncommit 4f33342df57ec5f60b2ec1daeb581b49836f05bf (HEAD -&gt; main)\nMerge: 1504d41 5d10e17\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 17:01:27 2023 +0200\n\n    Extras übernehmen\n\ncommit 5d10e17be5a2fc0d987db10644b35c73224f51f2 (extras)\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 16:58:01 2023 +0200\n\n    Autorenliste\n\ncommit 1504d416bb1ef926fde4d5e949f3ed330d97b065\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 15:27:19 2023 +0200\n\n    Zusatzinformation zum Projekt\n      modified:   README.md\n\ncommit b281e4a03a4e71bcc41fa2f68e822b98c1555e1d (tag: erste_version)\nAuthor: Christian Glahn &lt;christian.glahn@zhaw.ch&gt;\nDate:   Fri Aug 18 15:26:36 2023 +0200\n\n    Initial commit\n        new file:   README.md\nNun existiert die Datei AUTHORS.md auch im main-Branch.\n\n7.2.6.1 Merge-Konflikte lösen\nGelegentlich entstehen beim Mergen Konflikte. Ein Merge-Konflikt sind widersprüchliche Inhalte an der gleichen Code-Position. Solche Konflikte können auch entstehen, wenn mehrere Personen gleichgzeitig auf dem gleichen Branch arbeiten.\ngit löst solche Widersprüche nicht selbst, sondern erfordert ein aktives Eingreifen der Entwickler:innen. Um diesen Schritt zu erleichtern, fügt git Markierungen für die Konflikte ein. Diese Markierungen sind in den aktiven Daten zu finden, aber sind keine eigenständigen Versionen im Repository.\nEin solcher Konflikt kann dadurch provoziert werden, indem im extras-Branch der Datei README.md am Ende zusätzlicher Text hinzugefügt wird, so dass die Datei den folgenden Inhalt hat.\n# Mein erstes Projekt\n\nAlle Informationen zu den Autoren finden sich in der Datei [AUTHORS.md]\nWird nun versucht den extras und den main-Branch zusammenzuführen, meldet git merge den folgenden Konflikt:\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nAutomatic merge failed; fix conflicts and then commit the result.\nDer Inhalt der Datei README.md zeigt nun den Merge-Konflikt.\n# Mein erstes Projekt\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nEine Übung zur Versionierung mit git.\n=======\nAlle Informationen zu den Autoren finden sich in der Datei [AUTHORS.md].\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; extras\nDurch die Gleichheitszeichen sind der aktuelle Branch (oben) und der einzubindende Branch (unten) getrennt. Jeweils am Anfang und Ende des Konfliktbereichs stehen die Namen des betreffenden Branches.\nEs bleibt den Entwickler:innen überlassen, sich für eine, beide oder keine der Änderungen zu entscheiden. In diesem Beispiel sollen beide Inhalte erhalten bleiben. Dazu werden die git-Markierungen aus der Datei entfernt und durch Zeilenumbrüche ersetzt. Der Dateiinhalt ist nun:\n# Mein erstes Projekt\n\nEine Übung zur Versionierung mit git.\n\nAlle Informationen zu den Autoren finden sich in der Datei [AUTHORS.md].\nDie Datei ist nun konfliktfrei und kann in die Versionierung aufgenommen werden.\n\n\n7.2.6.2 Rebase\nNormalerweise erfolgt das Auflösen von Merge-Konflikten durch die Verantwortlichen des Hauptzweigs. Das ist aus Sicht des Projektmanagements ungünstig. Besser wäre es, wenn nur konfliktfreie Änderungen übernommen werden müssten. git bietet hierzu das Kommando git rebase an. Das Kommando zieht alle Änderungen des Zielzweigs in den aktuellen Arbeitszweig.\ngit checkout extras\ngit rebase main\nDadurch wird der gleiche Merge-Konflikt wie beim regulären Merge ausgelöst. Dieser Konflikt kann nun durch die Person gelöst werden, die für den Arbeits-Branch verantwortlich ist.\nAnschliessend können beide Branches konfliktfrei zusammengeführt werden.\n\n\n\n\n\n\nPraxis\n\n\n\nEs hat sich als gute Praxis etabliert, Merge-Konflikte immer mit git rebase und nicht mit git merge zu lösen.\n\n\n\n\n\n7.2.7 Fetch, Pull und Push\ngit synchronisiert Repositories nicht automatisch. Damit Änderungen in einem Clone oder Fork im eigenen Repository übernommen werden, müssen die Repositories synchronisiert werden.\nDas Kommando git fetch synchronisiert die Versionen der Remotes mit dem lokalem Repository. Falls ein Repository mehrere Remotes registriert hat, können alle Änderungen in allen Remotes mit git fetch --all auf einmal abgeglichen werden.\nNach git fetch enthält das lokale Repository alle Versionen der Remotes. Diese Versionen werden allerdings nicht automatich in die lokalen Versionszweige übernommen. Die so synchornisierten Änderungen existieren als eigene Branches im Repository. Im Gegensatz zum regulären Merge, werden diese “Remote-Branches” mit dem Kommando git pull in die lokalen Versionen übernommen. git pull löst alle Unterschiede für den aktuellen Branch im lokalen und remote Repository auf.\nWeil intern ein Merge durchgeführt wird, kann auch git pull zu Merge-Konflikten führen. Diese Konflikte müssen gelöst werden, bevor weitergearbeitet werden kann.\n\n\n\n\n\n\nHinweis\n\n\n\ngit pull führt automatisch ein git fetch aus, falls keine Änderungen für ein Remote-Repository lokal gefunden wurden.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nSind für ein Repository mehrere Remotes konfiguriert, dann sollten die einzelnen Remotes einzeln synchronisiert werden.\n\n\nDas Kommando git push wird zum Synchronisieren des lokalen Repositories mit den Remotes genutzt. Beim git push wird im Remote ein Merge durchgeführt. Führt dieser zu Konflikten, meldet git push einen Fehler, jedoch keinen Merge-Konflikt. Bei Fehlern von git push muss zuerst git fetch und anschliessend ein git rebase ausgeführt werden und eventuelle Merge-Konflikte lokal gelöst werden.\ngit push kann nur für Clones verwendet werden. Forks können normalerweise nicht direkt in das Upstream-Remote synchronisieren. Sollen Änderungen für ein Upstream Repository vorgeschlagen werden, dann muss ein sogenannter Pull-Request ausgelöst werden. In diesem Fall werden die Änderungen durch ein git pull im Upstream-Repository übernommen."
  },
  {
    "objectID": "kapitel/01-tool-chain/git_github.html#git-projektmanagement",
    "href": "kapitel/01-tool-chain/git_github.html#git-projektmanagement",
    "title": "7  Versionierung mit Git und GitHub",
    "section": "7.3 git-Projektmanagement",
    "text": "7.3 git-Projektmanagement\nDie im folgenden beschrieben Funktionen sind kein Teil von git, sondern finden sich als Erweiterungen in git-Hosting-Plattformen. Diese Funktionen wurden für den Einstieg in die Verwendung von git-Hosting-Plattformen ausgewählt und zeigen nur einen Bruchteil der Managementfunktionen moderner git-Hosting-Plattformen.\n\n7.3.1 Issues\ngit-Hosting-Plattformen führen neben dem eigentlichen Repository eine Liste mit Issues. Issues bezeichnen traditionell ein Problem, Fragestellung oder Angelegenheit im oder mit dem Projekt. Das können z.B. noch nicht realisierte Projektziele, fehlende Dokumentation oder auch Sicherheitsproblemen durch Programmierfehler sein. Damit Issues nicht verloren und vergessen werden, sollten sie dokumentiert werden. Dazu dient der Issues-Bereich in git-Hosting-Plattformen.\nDie Issues eines Projekts sind nummeriert, so dass über diese Nummer auf das jeweilige Issue referenziert werden kann. Ein Issue besteht immer aus einem Titel, welcher die notwendige Änderung kurz beschreibt. Zusätzlich verfügen Issues über eine Beschreibung, in der detailliert beschrieben werden kann, was das Problem ist und welche Anforderungen erfüllt sein müssen, damit ein Issue erfüllt ist.\nDie Issues von git-Hosting-Plattformen haben zwei Zustände: Offen (engl. open) und geschlossen (engl. closed). Offene Issues sind noch nicht bearbeitet. Geschlossene Issues sind bearbeitet und erledigt. Issues können deshalb als To-Do-Liste für ein Projekt verwendet werden: Jedes Issue lässt sich mit Änderungen im Repository verbinden. Weil jede Änderung mit einer Version gleichzusetzen ist, kann ein Issue geschlossen werden, wenn im Repository ein Commit existiert, das die notwendige Änderung enthält.\n\ngit-Hosting-Plattformen unterstützen sog. Action-Keywords in Commit-Meldungen. Wird ein solches Keyword zusammen mit der Issue-Nummer verwendet, dann schliesst die Hosting-Plattform das genannte Issue automatisch. Gleichzeitig wird dokumentiert, mit welchem Commit das Issue geschlossen wurde.\n\nDie Möglichkeit ein Issue zu kommentieren ist weitere sehr praktische Funktion. So können Notizen, Gedanken und Recherchen einem Issue zugeordnet werden. Diese Dokumentation wird automatisch mit einem Datum und dem Account-Namen versehen, so dass sich die Arbeit an einem Issue leicht reproduzieren lässt. Der Vorteil dieser Funktion ist, dass so Konzepte und Ideen einem Issue zugeordnet werden können, selbst wenn sich diese nicht im eigentlichen Repository wiederfinden. So kann die Entscheidungsfindung in einem Projekt nachvollziehbar dokumentiert werden.\n\n\n7.3.2 Pull-Requests\nWenn Code in zwei Code-Zweigen zusammengeführt werden soll, werden sog. Pull-Requests bzw. Merge-Requests erstellt. Ein Pull-Request ist eine Anfrage zum Zusammenführen eines Branches oder eines Forks mit einem anderen Branch.\n\n\n\n\n\n\nHinweis\n\n\n\nUrsprünglich wurden Pull-Requests in Form von E-Mails an die Projektkoordination geschickt und enthieleten einen Verweis auf den einzubindenen Fork. In git-Hosting-Plattformen sind Pull-Requests spezielle Issues, die einen Branch oder einen Fork mit dem Repository verknüpfen.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nSobald ein Commit in einem Branch vorliegt, kann ein Pull-Request erstellt werden. Es ist eine gute Vorgehensweise, möglichst früh einen Pull-Request zu öffnen.\n\n\nWie Issues können Pull-Requests kommentiert werden, so dass notwendige Anpassungen angeregt werden können. Es kann auch die Qualität der Versionen in einem Branch überprüft werden. Entspricht ein Pull-Request nicht den Qualitätsanforderungen eines Projekts, können vor einem Merge die notwendigen Änderungen vorgenommen werden. Alle git-Hosting-Plattformen bieten die Möglichkeit für jeden Pull-Request Projektstandards automatisch zu überprüfen und verhindern das Zusammenführen bei Problemen.\nPull-Requests habe wie Issues den Zustand offen und geschlossen. Sobald ein Merge mit dem Ziel-Branch erfolgt durchfegührt wurde, schliesst die git-Hosting-Plattform den Pull-Request automatisch. Pull-Requests können auch Issues zugeordent werden, so dass ein oder mehrere zugeordnete Issues automatisch geschlossen werden, sobald ein Pull-Request gemerged wurde."
  },
  {
    "objectID": "kapitel/01-tool-chain/git_github.html#anwendungen-und-praxistipps",
    "href": "kapitel/01-tool-chain/git_github.html#anwendungen-und-praxistipps",
    "title": "7  Versionierung mit Git und GitHub",
    "section": "7.4 Anwendungen und Praxistipps",
    "text": "7.4 Anwendungen und Praxistipps\n\n7.4.1 GitHub-Flow\nEs hat sich bewährt, jede Aktvität am Repository in einem eigenen Branch durchzuführen. Dabei wird jeder Branch immer mit einem Issue verknüpft. Ist die Arbeit abgeschlossen, dann wird ein Pull-request zur Qualitätskontrolle erstellt. Sind die Änderungen in Ordnung, dann kann dieser Pull-Request mit einem Merge abgeschlossen werden. Der main-Branch enthält bei dieser Vorgehensweise immer eine korrekte und funktionierende Version des Projekts. Diese Vorgehensweise wird als GitHub-Flow (GitHub Inc., o. J.) bezeichnet.\nAbbildung 7.1 zeigt ein einfaches Beispiel für den Ablauf des GitHub-Flows.\n\n\n\n\n\n%%{init: {'theme': 'base' } }%%\ngitGraph\n   commit id: \"1\"\n   commit id: \"2\"\n   branch issue_1\n   checkout issue_1\n   commit id: \"3\" tag: \"Pull-Request\"\n   checkout issue_1\n   commit  id: \"4\"\n   checkout main\n   merge issue_1\n   branch issue_2\n   commit id: \"5\"\n\n\nAbbildung 7.1: Vereinfachter GitHub-Flow\n\n\n\n\nDer GitHub-Flow arbeitet immer nach dem gleichem Grundschema:\n\nEs wird ein Issue mit den Anforderungen für die Aufgabe erstellt.\nEs wird ein Issue-Branch erstellt.\nEs werden die Änderungen im Issue-Branch festgehalten.\nEs wird ein Pull-Request für den Issue-Branch erstellt.\nSind alle Anforderungen erfüllt und existieren keine Merge-Konflikte, wird ein Merge des Issue-Branch mit dem main-Branch durchgeführt.\nDer Issue-Branch wird aus dem Repository gelöscht.\n\nIm GitHub-Flow gelten die folgenden Regeln für die Projektarbeit:\n\nBranches werden ausschliesslich über Pull-Requests mit dem main-Branch zusammengeführt.\nAlle Pull-Requests beziehen sich auf mindestens ein Issue.\nEs erfolgen keine Commits in den main-Branch.\nEs werden ausschliesslich konfliktfreie Merges durchgeführt. Alle Merge-Konflikte müssen im zugehörigen Issue-Branch gelöst werden.\n\nEin Issue-Branch ist ein normaler git-Branch mit dem Namen oder der Nummer des Issues. Am einfachsten sind Branchnamen die mit issue_ beginnen und mit der jeweiligen Issue-Nummer enden. Z.B. für das erste Issue eines Projekts würde der zugehörige Issue-Branch issue_1 heissen. Der Vorteil dieser Benennung ist, dass ein Branch einem Issue zugeordnet werden kann, selbst wenn noch kein Pull-Request erstellt wurde.\nEs wird empfohlen, einen Pull-Request zu öffnen, sobald eine Version in den Branch committed wurde. Dadurch können automatische Qualitätssicherungsschritte die Arbeit unterstützen. Ein Pull-Request muss spätestens nach vollendeter Arbeit an einem Issue erstellt werden.\nPull-Requests sollten mit Action-Keywords konfiguriert werden, so dass mit dem schliessen des Pull-Requests durch einen Merge das zugehörige Issue automatisch geschlossen wird.\nAbschliessend wird der Issue-Branch gelöscht. Technisch wird nur die Verzweigung aus dem Repository entfernt, weil die Versionierung beim Merge erhalten bleibt. Dadurch wird sichergestellt, dass an dieser Aufgabe nicht versehentlich weiter gearbeitet wird.\n\n\n7.4.2 Dateien und Verzeichnisse von der Versionierung ausschliessen\ngit meldet “nicht verfolgte”-Dateien, um Datenverlusten vorzubeugen. Nicht alle Dateien in einem Projekt müssen oder sollten versioniert werden. Das gilt meist für die folgenden Kategorien.\n\nDateien des Betriebssystems\nKonfigurationsdateien\nHilfsmodule und Komponenten von Dritten\nTemporäre Dateien und Zwischenergebnisse\n\nDamit diese Dateien nicht versehentlich in der Versionierung erfasst werden, sollten sie aus dem Prozess ausgenommen werden. Dateien und Verzeichnisse können von der Versionierung ausgenommen werden, indem sie in der Datei .gitignore erwähnt werden. .gitignore kann gezielt einzelne Namen oder Namesmuster ausklammern. .gitignore ist Teil der versionierten Daten, so dass sauber nachvollziehbar ist, welche Dateien aus der Versionierung ausgenommenen werden sollten.\nEine Datei wird nur ignoriert, wenn sich noch nicht in der Versionierung erfasst wurde.\n\n\n\n\n\n\nAchtung\n\n\n\nEine Datei wird von der Versionierung ausgeschlossen, wenn eine der folgenden Regeln zutrifft.\n\n\n\nDer Datei- oder Verzeichnisname ist explizit in .gitignore gelistet. Für Namen in Unterverzeichnissen muss dazu der Gesamtepfad angegeben sein.\nEine Datei oder ein Verzeichnis liegt in einem Verzeichnis, dass ignoriert wird.\nDer Datei- oder Verzeichnisname wird durch ein Namesmuster erfasst.\n\nDie folgenden Namesmuster sind gebräuchlich:\n\n*/dateiname - eine Datei oder ein Verzeichnis mit einem bestimmten Namen liegt in einem Verzeichnis im Projektverzeichnis.\n**/dateiname - eine Datei oder ein Verzeichnis liegt an beliebiger Stelle im Projekt\n*.tmp - alle Dateien oder Verzeichnisse im Projektverzeichnis, die auf .tmp enden.\nbild* - alle Dateien oder Verzeichnisse im Projektverzeichnis, die mit bild beginnen.\n\n\nGelegentlich kommt es vor, dass festgestellt wird, dass eine oder mehrere Dateien ignoriert werden soll, obwohl sie bereits in die Versionierung aufgenommen wurde. In diesem Fall erscheit es, als ob .gitignore nicht funktioniert. Das liegt daran, dass git eine Datei nur ignoriert, wenn diese nicht in der Versionierung erfasst wurde. Um eine bereits erfasste Datei zu irgnorieren, muss diese Datei aus dem Versionsdatenbank mit git rm entfernt werden.\n\nBeispiel\nDas folgende Beispiel zeigt typische .gitignore-Datei für ein R-Projekt.\n# Ignore MacOS Filesystem Metadata\n**/.DS_Store\n\n# R-specific Files\n.Rhistory\n.Rapp.history\n.RData\n.RDataTmp\n.Ruserdata\n.Renviron\n\n*-Ex.R\n\n/*.tar.gz\n/*.Rcheck/\n.Rproj.user/\n\nvignettes/*.html\nvignettes/*.pdf\n\nrsconnect/\n.httr-oauth\n\n*_cache/\n/cache/\n*.utf8.md\n*.knit.md\npo/*~\n_bookdown_files/\n_book\n.quarto/\n/.quarto/\n\n\n7.4.3 Repository-Organisation\nDie Arbeit mit Git und den anderen Hosting-Plattformen erscheint oft mühsam und aufwändig. Das gilt speziell für grösseres Umorganisieren eines Repositories. Gerade bei komplexen Projekten sollte deshalb möglichst früh die Organisation des Versionsmanagements festgelegt werden.\nIn der Praxis finden sich drei Organisationsstrategien.\n\nMonorepo\nProjektrepo\nMicrorepo\n\nDie Wahl der Repository-Organisation hängt stark von den Projektanforderungen ab.\n\n7.4.3.1 Monorepo\nBei der Monorepo-Strategie werden alle Dateien in einem einzigen Repository organisiert. Diese Strategie ist besonders bei Projektbeginn oder bei einfachen Projekten mit geringer funktionaler Trennung geeignet. Der Vorteil dieser Strategie ist, dass alle Daten in einem Repository zusammengefasst vorliegen und als Ganzes verwaltet werden können.\nFür komplexe Projekte wird diese Organisationsstrategie normalerweise mit dem Git-Flow als Branching-Strategie kombiniert. Dabei müssen alle Projektteile aufeinander abgestimmt werden und benötigen eine konsitente Qualitätskontrolle, weil alle Änderungen voneinander abhängig sind. Komplexe Änderungen beeinflussen wegen der linearen Abhängigkeit der Versionen deshalb alle anderen Bereich und sind deshalb wesentlich schwerer zu korrigieren.\n\n\n7.4.3.2 Projektrepo\nDie Projektrepo-Strategie ist eine Variante der Monorepo-Strategie für komplexe Projekte, mit klar getrennten aber voneinander abhängigen Projektteilen. Dazu werden einzelene Projektteile in eigene Repositories ausgegliedert und als git-Submodule in das Haupt-Repository eingebunden. Solche Submodule können unabhängig vom Haupt-Projekt entwickelt werden und auch in anderen Projekten wiederverwendet werden. Die Integration eines Submoduls erfolgt für einen bestimmten Commit oder ein bestimmtes Tag. Dadurch wird eine differenziertere Qualitätskontrolle möglich.\n\n\n7.4.3.3 Microrepo\nBei der Microrepo-Strategie werden alle Projektteile in eigenen Repositories unabhängig voneinander geführt, so dass nur der jeweilige Projektteil und die zugehörige Konfiguration in einem Repository vorliegen.\nBei der Microrepo-Strategie werden Daten, Code und Konfiguration grundsätzlich immer voneinander getrennt und werden in eigenen Repositories verwaltet. Damit ist diese Strategie die Antithese zum Monorepo. Die Integration der Komponenten erfolgt über das lokale Dateisystem oder über Packetmanager und git-Tags.\nDiese Strategie eignet sich für Datenprojekte, Projekte mit wenigen direkten Abhähngigkeiten oder Projekte mit verschiedenen Anwendungsgebieten (engl. Deployments). Durch klar getrennte Repositories lassen sich die einzelnen Komponenten in unterschiedlichen Kontexten problemlos unabhängig voneinander publizieren und anpassen. Deshalb ist diese Strategie besonders für Projekte mit sensitiven Daten, wie z.B. Patientendaten, oder Konfigurationen, wie beispielsweise Passwörtern, geeignet, bei denen die Datenverarbeitung keine sensitiven Teile hat.\n\n\n\n\nGitHub Inc. (o. J.). GitHub flow. https://docs.github.com/en/get-started/quickstart/github-flow"
  },
  {
    "objectID": "kapitel/05-datentypen/kapitel.html#fundamentale-datentypen",
    "href": "kapitel/05-datentypen/kapitel.html#fundamentale-datentypen",
    "title": "8  Datentypen",
    "section": "8.1 Fundamentale Datentypen",
    "text": "8.1 Fundamentale Datentypen\nDatentypen helfen uns Werte zu organisieren. Wir haben bereits drei wichtige Datentypen kennengelernt. Damit kennen wir bereits den Grossteil der wichtigsten Datentypen für einzelne Werte. Die vollständige Auflistung besteht aus fünf Datentypen:\n\nZahlen (engl. numerics)\nWahrheitswerte (engl. booleans)\nZeichenketten (engl. strings)\nFehlerwerte (engl. error values)\nUndefinierte Werte (engl. undefined values).\n\nDiese Datentypen beschreiben jeweils einzelne Werte.\n\nDefinition 8.1 Fundamentale Datentypen heissen Datentypen, die Eigenschaften für einzelne Werte festlegen.\n\n\nDefinition 8.2 Ein Wert von einem fundamentalen Datentyp heisst Skalar.\n\nDie fundamentalen Datentypen legen die allgemeinen Wertebereiche fest, auf welchen die speziellen Wertebereiche der Datenschemata aufbauen.\n\n8.1.1 Undefinierte Werte\nGelegentlich fehlen Werte in den Daten oder wurden bei der Datenverarbeitung (noch) nicht zugewiesen. In diesen Fällen werden die “fehlenden” Werte nicht ignoriert, sondern als undefinierte Werte festgehalten.\n\nDefinition 8.3 Als undefinierte Werte die keine Werte repräsentieren.\n\nIn den meisten Programmiersprachen kennen für undefinierte Werte eine konstanten Wert. Dieser Wert ist in der Regel vom beliebigen Datentyp.\n\n\n8.1.2 Zahlen\n\nDefinition 8.4 Als Zahlenwerte werden nummerische Werte bezeichnet.\n\nZahlenwerte können verschiedene Darstellungen haben, ohne dass sich der Wert der Zahl verändert (s. Kapitel 15).\nZahlenwerte können in zwei Klassen unterteilt werden:\n\nGanze Zahlen\nReelle Zahlen\n\nDaneben unterstützen die meisten Programmiersprachen für die Datenanalyse auch komplexe Zahlen. Diese werden jedoch selten direkt eingegeben, sondern sind in der Regel Teil von Berechnungen.\n\n\n\n\n\n\nWarnung\n\n\n\nEin Teil der reellen Zahlen sind die Gleitkommazahlen. Gleitkommazahlen arbeiten wie die wissenschaftliche Schreibweise von Zahlen (s. Abschnitt 3.4) mit einer Basis und einer Potenz, durch welche die Grössenordnung einer Zahl definiert ist.\nAlle reellen Zahlen werden in Computern grundsätzlich als Gleitkommazahlen abgebildet. Dadurch wird der mögliche Zahlenraum prinzipiell erweitert. Zahlen lassen sich so nicht mehr mit beliebiger Genauigkeit behandeln. Deshalb kann mit Gleitkommazahlen nicht immer exakt gerechnet werden. Das ist immer dann der Fall, wenn sehr kleine und sehr grosse Zahlen miteinander verrechnet werden. In solchen Fällen kann es zu unerwarteten Rundungsfehlern kommen.\nFalls sehr genaue Berechnungen notwendig sind, dann müssen spezielle Bibliotheken verwendet werden, die mit der entsprechenden Genauigkeit umgehen können.\n\n\n\n\n8.1.3 Wahrheitswerte\n\nDefinition 8.5 Als Wahrheitswerte werden die Werte Wahr (True) und Falsch (False) bezeichnet.\n\nWeil es nur zwei Wahrheitswerte gibt, werden sind Wahrheitswerte ein binärer Datentyp.\nIn den meisten Programmiersprachen lassen sich Zahlenwerte als Wahrheitswerte verwenden. Dabei wird die Zahl 0 als Falsch und alle anderen Zahlen als Wahr interpretiert.\nWahrheitswerte werden meistens zur Steuerung der Programmlogik verwendet (s. Kapitel 12).\n\n\n8.1.4 Zeichenketten\n\nDefinition 8.6 Als Zeichenketten werden Werte bezeichnet, die aus einer Zeichenfolge bestehen. Dazu gehören Buchstaben, Ziffern, sowie Leer-, Satz- und Sonderzeichen.\n\nZeichenketten setzen sich aus Symbolen zusammen, weshalb Zeichenketten eine Länge haben. Die Länge einer Zeichenkette entspricht der Anzahl ihrer Symbole. Entsprechend hat jedes Symbol eine eindeutige Position in der Zeichenkette.\nZeichenketten werden für alle Werte verwendet, die nicht als Zahlenwerte oder Wahrheitswerte dargestellt werden können. Gelegentlich müssen Zahlen als Zeichenketten dargestellt werden, um sie in einem bestimmten Format auszugeben oder für mathematische Operationen zu sperren.\nIn den meisen Programmiersprachen müssen Zeichenketten besonders markiert werden, damit sie von anderen Datentypen und Bezeichnern unterschieden werden können (s. Kapitel 10). Die Markierung erfolgt meistens durch Anführungszeichen.\n\n\n\n\n\n\nHinweis\n\n\n\nProgrammiersprachen wie bspw. C, C++, C# oder Java verwenden für Zeichenketten den fundamentalen Datentyp des Symbols (oder Character). In diesen Programmiersprachen werden Zeichenketten als Liste von Symbolen behandelt.\nDiese Unterscheidung ist für die Programmiersprachen der Datenwissenschaften nur insofern von Bedeutung, als dass eine Zeichenkette eine Länge hat und jedes Symbol in einer Zeichenkette über dessen Position abgefragt werden kann.\n\n\n\n\n8.1.5 Fehlerwerte\n\nDefinition 8.7 Als Fehlerwerte werden Werte bezeichnet, die Fehler repräsentieren.\n\nFehlerwerte unterscheiden sich von den anderen Datentypen. Mit ihnen eine Programmierumgebung oder eine Programmiersprache an, dass ein Fehler aufgetreten ist oder eine unzulässige Operation ausgeführt wurde. Für die meisten Programmiersprachen sind die möglichen Fehler von Operationen und Funktionen dokumentiert.\nFehlerwerte können nicht mit anderen Datentypen verknüpft werden. Wird ein Fehlerwert mit einem anderen Datentyp verknüpft, dann wird der Fehlerwert als Ergebnis zurückgegeben.\nFehlerwerte geben an, welche Art von Fehler aufgetreten ist. Dadurch können regelmässig auftretende Fehler automatisch behandelt werden. Hierzu stellen alle Programmiersprachen spezielle Funktionen zur Fehlerbehandlung bereit.\n\n\n\n\n\n\nPraxis\n\n\n\nEin besonderer Fehlerwert in der Datenanalyse ist der fehlende Wert. Er wird verwendet, wenn ein Wert nicht vorhanden ist oder nicht zugewiesen wurde. Dieser Wert ist notwendig, weil fehlende Werte (normalerweise) nicht durch den Wert 0 ersetzt werden dürfen. Er ist dem Datentyp undefinierter Wert vorzuziehen, weil dieser Fehlerwert einen fehlenden Wert explizit kennzeichnet und diesen Wert für normale Operationen sperrt, was bei undefinierten Werten nicht immer der Fall ist."
  },
  {
    "objectID": "kapitel/05-datentypen/kapitel.html#sec-skalenniveaus",
    "href": "kapitel/05-datentypen/kapitel.html#sec-skalenniveaus",
    "title": "8  Datentypen",
    "section": "8.2 Klassen von Datentypen",
    "text": "8.2 Klassen von Datentypen\nEs werden zwei Klassen von Datentypen unterschieden:\n\nDiskrete Daten\nKontinuierliche Daten\n\n\n\n\n\n\n\nHinweis\n\n\n\nIn der Statistik heissen die folgenden Wertebereichklassen Skalenniveaus.\n\n\n\n8.2.1 Diskrete Daten\n\nDefinition 8.8 Wenn ein Wertebereich nur eindeutige Werte enthält, dann heisst der Wertebereich diskret.\n\nGanze Zahlen, Wahrheitswerte, Zeichenketten und Fehlerwerte haben immer diskrete Wertebereiche. Undefinierte Werte umfassen nur einen einzigen Wert und können je nach Kontext diskret oder kontinuierlich sein.\nEs werden drei Arten von diskreten Daten unterschieden:\n\nNominale Daten\nOrdinale Daten\nIntervallskalierte Daten\n\nZusätzlich erfahren binäre Wertebereiche oft eine besondere Behandlung in der Literatur.\n\n8.2.1.1 Nominalskalierte Daten\n\nDefinition 8.9 Lassen sich alle Werte in einem Wertebereich eindeutig voneinander unterscheiden, dann liegt ein nominalskalierter Wertebereich vor.\n\nNominalskalierte Daten können nur durch Gleichheit oder Ungleichheit voneinander unterschieden werden. Nominalskalierte Daten können nur über Häufigkeiten zusammengefasst werden.\n\n\n8.2.1.2 Ordinalskalierte Daten\n\nDefinition 8.10 Lassen sich alle Werte eines nominalskalierten Wertebereichs in eine eindeutige Reihenfolge sortieren, dann liegt ein ordinalskalierter Wertebereich vor.\n\nOrdinale Daten sind eine Untermenge der nominalen Daten, bei der sich die Werte im Wertebereich sortieren lassen. Dadurch kann jedem Wert ein eindeutiger Rang zugewiesen werden. Der Rang markiert die Position eines Werts im sortierten Wertebereich.\n\n\n\n\n\n\nHinweis\n\n\n\nEine Reihenfolge bedeutet nicht, dass auch die Abstände zwischen allen Werten gleich sind.\n\n\n\n\n8.2.1.3 Binäre Daten\n\nDefinition 8.11 Hat ein Wertebereich genau zwei Werte, dann liegt ein binärer Wertebereich vor.\n\nBinäre Wertebereiche sind ein Sonderfall unter den diskreten Daten, denn sie können entweder nominal- oder ordinalskaliert sein.\nEin binärer Wertebereich ist ordinalskaliert, wenn die zulässigen Werte sortierbar sind. Ein häufiger Fall eines ordinalen binären Wertebereichs sind vorher-nachher-Markierungen.\n\n\n\n\n\n\nMerke\n\n\n\nAlle binären Daten können als Wahrheitswerte dargestellt werden.\n\n\nMehrere binäre Wertebereiche können durch die Verknüpfung von Zweier-Potenzen zu einem nominalskalierten Wertebereich zusammengefasst werden.\n\n\n8.2.1.4 Intervallskalierte Daten\n\nDefinition 8.12 Haben alle Werte in einem Wertebereich die gleichen Abstände, ist der Wertebereich intervallskaliert.\n\nIntervallskalierte Daten sind über die Differenz definiert: Werden zwei beliebige benachbarte Wertepaare ausgewählt, dann muss die Differenz zwischen Paaren, zwischen den beiden kleineren Werten und zwischen den beiden grösseren Werten jeweils zueinander gleich sein. Benachbarte Werte unterscheiden sich im Rang um 1.\n\n\nBeispiel 8.1 Aus dem ordinalskalierten Wertebereich der ganzen Zahlen \\mathbb{I} werden die Werte 1, 2, 5 und 6 gewählt. Die Wertepaare 1 und 2 sowie 5 und 6 sind benachbart.\nWenn der Wertebereich intervallskaliert ist, dann müssen beide Gleichungen in Formel 8.1 gelten.\n\n2 - 1 = 6 - 5 \\Leftrightarrow 1 = 1 \\\\ und \\\\\n6 - 2 = 5 - 1 \\Leftrightarrow 4 = 4\n\\tag{8.1}\nBeide Gleichungen müssen für alle Wertepaare im Wertebereich gültig sein, was bei den ganzen Zahlen der Fall ist. Deshalb ist \\mathbb{I} intervallskaliert.\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nDie Abstände zwischen den einzelnen Werten lassen sich nicht für alle ordinalen Wertebereiche feststellen. Solche Wertebereiche sind nie intervallskaliert.\n\n\n\n\n\n8.2.2 Kontinuierliche Daten\nLässt ein Wertebereich beliebige Abstufungen zwischen Werten zu, dann heisst dieser Wertebereich kontinuierlich.\n\nDefinition 8.13 Kontinuierliche Daten liegen vor, wenn alle Werte im Wertebereich sortierbar sind, die gleichen Abstände haben und die Verhältnisse von Werten ebenfalls im Wertebereich liegen.\n\n\n\n\n\n\n\nHinweis\n\n\n\nKontinierliche Daten werden auch als metrische Daten, varianzskalierte Daten oder kardinale Skalenniveaus bezeichnet.\n\n\nDefinition 8.13 verweist auf die Verhältnisse zwischen zwei Werten. Das Verhältnis ist das Gleiche wie ein Bruch bzw. die Division. Bei diskreten Daten können die Verhältnisse zwischen beliebigen Wertepaaren nicht so gebildet werden, dass auch alle Verhältnisse im gleichen diskreten Wertebereich liegen.\n\n\nBeispiel 8.2 Gegeben sind die Werte 1, 2, 3 und 4 aus dem intervallskalierten Wertebereich der ganzen Zahlen \\mathbb{I}.\nDie Verhältnisse zwischen diesen Werten sind \\frac{1}{2}, \\frac{1}{3}, \\frac{1}{4}, \\frac{2}{1}, \\frac{2}{3}, \\frac{2}{4}, \\frac{3}{1}, \\frac{3}{2}, \\frac{3}{4}, \\frac{4}{1}, \\frac{4}{2} und \\frac{4}{3}. Nur die Verhältnisse \\frac{2}{1}, \\frac{3}{1}, \\frac{4}{1} und \\frac{4}{2} sind wieder ganze Zahlen und würden zum Wertebereich gehören.\nWäre der Wertebereich mit \\mathbb{R} festgelegt worden, dann liegen alle Verhältnisse ebenfalls im Wertebereich von \\mathbb{R}. Daraus folgt, dass \\mathbb{R} ein kontinuierlicher Wertebereich ist.\n\n\nAlle kontinuierlichen Daten lassen sich auf reelle Zahlen abbilden.\n\n\n\n\n\n\nPraxis\n\n\n\nHäufig stellt sich bei der Analyse der Daten heraus, dass die Werte eines eigentlich kontinuierlichen Wertebereichs nur (wenige) diskrete Werte annehmen. In diesem Fall muss der Wertebereich als diskret behandelt werden."
  },
  {
    "objectID": "kapitel/05-datentypen/kapitel.html#sec-chapter-datenstrukturen",
    "href": "kapitel/05-datentypen/kapitel.html#sec-chapter-datenstrukturen",
    "title": "8  Datentypen",
    "section": "8.3 Datenstrukturen",
    "text": "8.3 Datenstrukturen\nAus fundamentalen Datentypen können komplexe Datentypen zusammengesetzt werden, um mehrere Werte zusammenzufassen. Komplexe Datentypen können ausserdem wiederum komplexe Datentypen enthalten. So lassen sich komplexe Strukturen bilden.\n\nDefinition 8.14 Eine Datenstruktur ist ein Datentyp, in dem mehrere Werte zusammengefasst werden können.\n\nWeil eine Datenstruktur ebenfalls ein Datentyp ist, lässt sie sich wie ein einzelner Wert behandeln. Dadurch haben Datenstrukturen eine Reihe von Vorteilen:\n\nDatenstrukturen können als Einheit behadelt werden.\nDatenstrukturen können verschachtelt werden, um noch komplexere Strukturen zu bilden.\nDatenstrukturen können als Sammlung von Einzelwerten betrachtet werden, welche getrennt verarbeitet werden können.\n\nDurch diese Eigentschaften sind Datenstrukturen besonders gut für die Datenorganisation geeignet.\n\n8.3.1 Eindimensionale Datenstrukturen\nDatenfelder (engl. arrays) sind eine besondere Datenstruktur. Datenfelder fassen Werte so zusammen, dass jeder Wert eine eindeutige Position hat. Die Position eines Wertes wird durch einen Index angegeben. Die Anzahl der Werte in einer Datenstruktur ist deren Länge. Die Länge und die Idizes einer Datenstruktur sind natürliche Zahlen.\nÜber die zusammengefassten Datentypen lassen sich zwei Arten von Datenfeldern unterscheiden.\n\nDefinition 8.15 Vektoren sind Datenfelder mit Werten vom gleichen Datentyp.\n\nWeil alle Werte in einem Vektor vom gleichen Datentyp sind, sind Vektoren homogene Datenstrukturen.\n\nDefinition 8.16 Listen sind Datenfelder mit Werten mit beliebigen Datentypen.\n\nWeil die Datentypen der Listenwerte nicht festgelegt sind, sind Listen heterogene Datenstrukturen.\n\n\n8.3.2 Mehrdimensionale Datentypen\nDie Logik der komplexen Datentypen erlaubt die Verknüpfung von Listen und Vektoren zu noch komplexeren Strukturen.\n\nDefinition 8.17 Eine geschachtelte Liste ist eine Liste, die aus beliebigen anderen Datenfeldern (d.h. Listen oder Vektoren) besteht, wobei die eingebetteten Datenfelder unterschiedliche Längen haben können.\n\nEin Spezialfall der geschachtelten Liste sind Listen, die Vektoren mit gleicher Länge schachteln. Diese Spezialfälle haben besondere Namen:\n\nDefinition 8.18 Eine Datenrahmen (engl. data frame) verknüpft mehrere gleichlange Vektoren mit unterschiedlichen Datentypen.\n\nEin Datenrahmen kann als eine Liste von Vektoren mit gleicher Länge verstanden werden. Diese Datenstruktur muss eine Liste sein, weil die einzelnen Vektoren unterschiedliche Datentypen haben können. Entsprechend gelten Datenrahmen ebenfalls als hetreogene Datenstrukturen.\nDie gleiche Logik lässt sich auch auf Vektoren anwenden. In diesem Fall ist der Spezialfall ein Vektor, der Vektoren gleicher Länge und des gleichen Datentyps schachtelt. Diese Datenstruktur hat ebenfalls einen eigenen Namen:\n\nDefinition 8.19 Eine Matrix verknüpft mehrere gleichlange Vektoren vom Datentyp Zahlen. Die Länge der Vektoren einer Matrix muss mindestens 1 sein.\n\nWeil alle Vektoren in einer Matrix vom gleichen Datentyp sind, sind Matrizen homogene Datenstrukturen.\nEine Matrix hat eine Höhe (oft als m Zeilen gekennzeichnet) und eine Breite (oft als n Spalten gekennzeichnet). Die Anzahl der Zeilen und Spalten müssen natürliche Zahlen sein. Daraus folgt, dass nur Matrizen existieren, für die m und n &gt; 0 gilt.\nEine Matrix mit m Zeilen und n Spalten wird als m \\times n-Matrix bezeichnet. Die Anzahl der Zeilen und Spalten einer Matrix sind ihre Dimensionen.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Dimensionen einer Matrix müssen beide &gt;0 sein, aber sie müssen genau nicht gleich sein. Weil m und n einer Matrix grösser als 0 sein müssen, folgt daraus: Vektoren sind spezielle Matrizen mit m-Zeilen und einer Spalte (n = 1).\n\n\n\nDefinition 8.20 Eine Matrix mit gleichvielen Spalten und Zeilen wird als quadratische Matrix bezeichnet.\n\nFür eine quadratische Matrix gilt immer m = n.\nDer Wert an einer Position in einer Matrix ist durch den Zeilen- und Spaltenindex eindeutig identifiziert.\n\n\\begin{bmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\\\n\\vdots & \\vdots  & \\ddots & \\vdots \\\\\\\na_{m1} & a_{m2} &  \\cdots &  a_{mn}  \n\\end{bmatrix}\n\nNeben der üblichen Schreibweise von Matrizen, können Matrizen auch als Vektoren dargestellt werden. Dabei handelt es sich um eine besondere Schreibweise der Matrix, die Vektorform einer Matrix genannt wird. Für jede Matrix gibt es immer zwei Vektorformen. Die eine Vektorform fügt die Werte einer Matrix spaltenweise aneinander, die andere Vektorform fügt die Werte zeilenweise aneinander.\nDie Vektorform einer Matrix kann nur gebildet werden, weil wegen Definition 8.19 die Datentypen aller Werte in einer Matrix gleich sind. Deshalb wird die Bedingung aus Definition 8.15 für die Vektorform einer Matrix erfüllt.\n\n\nBeispiel 8.3 Vektorformen einer Matrix\nFür die folgende Matrix A mit m = 3 Zeilen und n = 2 Spalten soll in ihre Vektorform überführt werden.\n\nA = \\begin{bmatrix}\n1 & 0 \\\\\\\n0 & 2 \\\\\\\n6 & 2  \\\\\\\n4 & 6  \\\\\\\n9 & 7\n\\end{bmatrix}\n\nFür alle Matrizen gibt es zwei Vektorformen.\nDie erste Vektorform A_{s} fügt die Werte spaltenweise aneinander.\n\nA_{s} = \\begin{bmatrix}\n1 \\\\\\\n0 \\\\\\\n6 \\\\\\\n4 \\\\\\\n9 \\\\\\\n0 \\\\\\\n2 \\\\\\\n2 \\\\\\\n6 \\\\\\\n7\n\\end{bmatrix}\n\nDie zweite Vektorform A_{z} fügt die Werte zeilenweise aneinander.\n\nA_{z} = \\begin{bmatrix}\n1 \\\\\\\n0 \\\\\\\n0 \\\\\\\n2 \\\\\\\n6 \\\\\\\n2 \\\\\\\n4 \\\\\\\n6 \\\\\\\n9 \\\\\\\n7\n\\end{bmatrix}"
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#dateien-verwenden",
    "href": "kapitel/04-dateiformate/kapitel.html#dateien-verwenden",
    "title": "9  Dateiformate",
    "section": "9.1 Dateien verwenden",
    "text": "9.1 Dateien verwenden\n\n9.1.1 Importieren\n\nDefinition 9.3 Das Lesen eines Datenstroms in eine Datenstruktur wird Importieren genannt.\n\nDas Importieren von Daten folgt immer in mehreren Schritten:\n\nLesen eines Datenstroms.\nZuordnung der Werte zu den richtigen Datentypen.\nAuswahl der zu verarbeitenden Daten.\n\n\n9.1.1.1 Daten einlesen\nBeim ersten Schritt werden die Symbole eines Datenstroms in eine geeignete Datenstruktur überführt. Dabei werden die gelesenen Symbole überprüft, ob es sich um Werte oder um eine Trennmarkierung handelt. Die Werte werden entsprechend ihrer Position im Datenstrom oder über Markierungen einer Datenstruktur zugeordnet.\n\nDefinition 9.4 Die Zuordnung von Werten in einem Datenstrom zu einer Datenstruktur wird Parsen genannt. Eine Funktion, die einen Datenstrom in eine Datenstruktur überführt, heisst Parser.\n\nJedes Dateiformat erfordert einen eigenen Parser. Wird ein ungeeigneter Parser verwendet, dann werden die Daten nicht korrekt importiert und können nicht weiterverarbeitet werden, weil die Datenstruktur nicht die Organisation der Daten wiedergibt. Deshalb muss beim Importieren immer ein passender Parser für das vorliegende Dateiformat verwendet werden.\n\n\n\n\n\n\nHinweis\n\n\n\nFür die gängigsten Datenformate existieren eigene Parser. Die Entwicklung eines Parsers für ein bestimmtes Format ist nur selten notwendig.\n\n\nDie Auswahl eines geeigneten Parsers liegt in der Verantwortung der Person, die die Daten importiert. In manchen Fällen kann das Dateiformat automatisch erkannt werden. In diesen Fällen wird ein geeigneter Parser automatisch ausgewählt. Diese automatische Auswahl ist aber nicht immer korrekt. Deshalb muss das Ergebnis des Parsers immer überprüft werden.\n\n\n9.1.1.2 Werte zuordnen\nDer zweite Schritt beim Importieren ist die Zuordnung der Werte zu den richtigen Datentypen und der richtigen Struktur. Normalerweise versucht ein Parser bereits die richtigen Datentypen zu erkennen. Dabei kann es zu Fehlern kommen, wenn sich die Werte nicht eindeutig einem Datentyp zuordnen lassen oder ein spezieller Datentyp verwendet werden soll.\nDiesem Schritt umfasst auch das Erkennen und Behandeln von Markierungen, welche in internen Strukturen als Variablennamen oder benannten Datenfeldern abgebildet werden. Bei Separator-strukturierten Dateien umfasst dieser Teilschritt die Zuordnung von Überschriften. Bei Markup-Daten werden Tags und Markierungen für die interne Struktur verwendet.\nDieser Schritt umfasst oft auch die Behandlung von ungültigen oder fehlenden Werten.\n\n\n9.1.1.3 Daten auswählen\nGelegentlich werden mehr Daten in einem Datenstrom bereitgestellt, als für die weitere Verarbeitung benötigt werden. In solchen Fällen werden nur die Daten ausgewählt, die für die weitere Verarbeitung benötigt werden. Bei diesem Schritt werden nicht benötigte Daten aus der internen Datenstruktur entfernt.\n\n\n\n\n\n\nWichtig\n\n\n\nDas Auswählen von Daten bezieht sich ausschliesslich auf die interne Datenstruktur. Die ursprünglichen Daten im Datenstrom dürfen nicht verändert werden.\n\n\n\n\n\n9.1.2 Exportieren\n\nDefinition 9.5 Das Schreiben von Daten aus einer Datenstruktur in einen Datenstrom heisst Exportieren.\n\nBeim Exportieren werden die Daten aus einer Datenstruktur in einen Datenstrom serialisiert. Eine Funktion die eine Datenstruktur in einen Datenstrom überführt, heisst Serialisierer.\nÄhnlich wie beim Importieren muss auch beim Exportieren existiert für jedes Datenformat ein geeigneter Serializer. Die Wahl eines Serialisierers hängt von der späteren Verwendung der Serialisierung ab.\n\n\n\n\n\n\nHinweis\n\n\n\nEs ist üblich, die gleichen Daten in verschiedenen Formaten zu serialisieren.\n\n\nEinige Dateiformat sind sehr komplex. Dadurch sind unvollständige Serialisierungen möglich. Eine unvollständige Serialisierung kann zu Datenverlusten führen. Deshalb sollte für gängige Dateiformate immer ein existierender Serializer verwendet werden.\n\n\n\n\n\n\nPraxis\n\n\n\nBeim Exportieren von Daten die vorher importiert wurde dürfen die ursprüngliche Daten nicht überschrieben werden, weil sonst Daten verloren gehen können. Stattdessen sollten Daten beim Exportieren in eine separate Datei geschrieben werden."
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#textdateien",
    "href": "kapitel/04-dateiformate/kapitel.html#textdateien",
    "title": "9  Dateiformate",
    "section": "9.2 Textdateien",
    "text": "9.2 Textdateien\n\nDefinition 9.6 Eine Textformat legt fest, dass alle Werte in einer Datei als Zeichenkettensymbole interpretiert werden müssen.\n\nDie Bits einer Textdatei sind nach einem festgelegten Standard kodiert (s. Kapitel 3.5). Dadurch kann der Inhalt einer Textdatei immer zuverlässig gelesen und interpretiert werden. Inzwischen verwenden alle modernen Betriebssysteme einheitlich den Kodierungsstandard UTF-8 (ISO/IEC JTC 1/SC 2, 2020; The Unicode Consortium, 2022).\nTextdateien haben den grossen Vorteil, dass die Dekodierung der Bits automatisch erfolgt. Eine Programm oder eine Funktion kann also direkt auf die kodierten Symbole zugreifen.\n\n\n\n\n\n\nTextkodierungen\n\n\n\nÄltere Datenerfassungs- oder Steuerungssysteme sind noch heute im Einsatz. Einige dieser Systeme verwenden für Textdaten einen älteren Kodierungsstandard. In solchen Fällen muss beim Zugriff auf die Daten die abweichende Kodierung explizit angegeben werden.\nEine abweichende Textkodierung wird oft an merkwürdigen Zeichenfolgen in den Daten erkannt. Nicht immer ist die verwendete Kodierung dokumentiert. Oft lässt sich die Textkodierung aus dem kulturellen Kontext der Daten ableiten. Die folgende Tabelle gibt für Europa und die USA eine Orientierung, welche Textkodierungen in welchen Zeiträumen verwendet wurden.\n\n\n\n\n\n\n\n\n Land/Region\nZeitraum\nWahrscheinliche Kodierung\n\n\n\n\nWeltweit\nseit ca. 2012\nUTF-8 (ISO/IEC JTC 1/SC 2, 2020)\n\n\nWest-Europa\n2000-2012\niso-8859-15 (ISO/IEC JTC 1/SC 2/WG 3, 1998b)\n\n\nUSA\n2000 - 2012\niso-8859-1 (ISO/IEC JTC 1/SC 2/WG 3, 1998a)\n\n\nWest-Europa\n1990 - 2000\niso-8859-1 (ISO/IEC JTC 1/SC 2/WG 3, 1998a)\n\n\nUSA\nvor 2000\nANSI/ASCII (American National Standards Institute, 1977)"
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#festkodierung",
    "href": "kapitel/04-dateiformate/kapitel.html#festkodierung",
    "title": "9  Dateiformate",
    "section": "9.3 Festkodierung",
    "text": "9.3 Festkodierung\nBei der Festkodierung werden die Werte in einer festen Reihenfolge und festen Symbol- oder Bitlängen in den Datenstrom geschrieben. Bei der Festkodierung ist die Reihenfolge der Werte und die Länge der Werte festgelegt.\nFestkodierungen erlauben sehr effizientes speichern und lesen von Daten. Damit festkodierte Daten verarbeitet können müssen die Datenfelder in einem gemeinsamen Schema festgelegt sein, dass beim Kodieren und Dekodieren verwendet wird.\n\n\nBeispiel 9.1 (Kodierung der IBAN) Die IBAN ist ein festkodiertes Datenformat mit vier Werten. Die Kodierung ist international einheitlich festgelegt (ISO/TC 68/SC 8, 2020).\n\nLänderkennung (2 Buchstaben)\nPrüfzahl (2 Ziffern)\nBankkennung (5 Symbole)\nKontonummer (6-25 Symbole)\n\nDie Prüfzahl erlaubt die Überprüfung der anderen Werte. Dadurch lassen sich Zahlendreher oder fehlerhafte Eingaben erkennen.\nDie Länge des letzten Felds wird durch nationale Gremien vereinheitlicht. In Deutschland ist die Kontonummer 10-stellig, in der Schweiz 9-stellig und in Österreich 8-stellig. Die restlichen Stellen bis zur Maximallänge 25 werden mit Leerzeichen aufgefüllt.\nOft werden IBANs mit Leerzeichen gruppiert, um die Lesbarkeit zu erhöhen. Die Leerzeichen werden bei der Verarbeitung gelöscht."
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#zeilenbasierte-textdateien",
    "href": "kapitel/04-dateiformate/kapitel.html#zeilenbasierte-textdateien",
    "title": "9  Dateiformate",
    "section": "9.4 Zeilenbasierte Textdateien",
    "text": "9.4 Zeilenbasierte Textdateien\nNormalerweise sind Textdateien unstrukturiert und die verwendeten Symbole dienen nur der Anzeige und haben keine eigene Bedeutung. Das ist nicht immer praktisch, um Daten zu strukturieren. Hier greifen sog. zeilenbasierte Textformate. Diese Textformate sind eine einfache Form der Datenorganisation, wobei alle Symbole in der gleichen Zeile zusammengehören und von den Symbolen in den anderen Zeilen abzugrenzen sind.\nZeilenbasierte Textdateien sind eine spezielle Form der Listenkodierung, wobei das Symbol für den Zeilenumbruch als Listentrennzeichen behandelt wird.\nEine typische Anwendung der zeilenbasierten Textkodierung sind sog. Log-Dateien, mit denen Systemereignisse protokolliert werden."
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#sec-mengen-und-baeume",
    "href": "kapitel/04-dateiformate/kapitel.html#sec-mengen-und-baeume",
    "title": "9  Dateiformate",
    "section": "9.5 Mengen und Bäume",
    "text": "9.5 Mengen und Bäume\nDie Werte lassen sich auf verschiedene Arten in Datenströmen kodieren. Die einfachste Form ist die Mengenkodierung. Bei der Mengenkodierung werden die Werte in einer festen Reihenfolge in den Datenstrom geschrieben. Dabei werden die Werte als eine zusammenhängende Menge behandelt.\nDie verbreitesten Formen der Mengenkodierung sind die Listenkodierung und die Tabellenkodierung. Bei der Listenkodierung werden die einzelnen Werte nacheinander in den Datenstrom geschrieben. Dabei ist die Reihenfolge der Werte nich von Bedeutung. Bei der Tabellenkodierung werden die Werte in einer tabellarisch organisiert. Dabei werden die Werte in Zeilen und Spalten organisiert, wobei jede Zeile und jede Spalte als eine Teilmenge behandelt wird. Die Reihenfolge der Zeilen und Spalten ist dabei nicht von Bedeutung, solange die Zeilen- und Spaltenteilmengen erhalten bleiben.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Mengenkodierung ist gleichzeitig die Grundlage für Datenbanken und tabellarischen Dateien. In Datenbanken werden die Werte tabellenartig in sog. Relationen organisiert.\n\n\nDie Mengenkodierung ist einfach und effizient. Sie hat aber den Nachteil, dass die Werte nicht leicht hierarchisch organisiert werden können, weil jede Hierarchieebene eine eigene Menge erfordert und damit von den anderen Ebenen abgegrenzt wäre. Dieses Problem löst die Baumkodierung. Die Baumkodierung kodiert Werte in einer Hierarchie. Dadurch lassen sich komplex-geschachtelte Datenstrukturen in einer Datei abbilden.\nIn einer Baumkodierung werden die Werte auf einer Hierarchiestufe zusammegefasst. Eine Hierarchiestufe wird als Knoten bezeichnet. In einer solchen Kodierung hat jeder Knoten eine Vorgängerstufe. Diese Vorgängerstufe wird Elternknoten genannt. Die Knoten auf der gleichen Hierachiestufe haben immer den gleichen Elternknoten. Diese Knoten heissen Geschwisterknoten. Die Knoten ohne Nachfolger nennt man Blattknoten. Die eigentlichen Werte finden sich nur in Blattknoten.\nMit der Baumkodierung lassen sich beliebig komplexe Datenstrukturen abbilden. Für die Kodierung von Datenstrukturen mit höchstens zwei Hierarchiestufen und vielen Werten ist die Baumkodierung weniger effizient als die Mengenkodierung."
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#sec-separator-strukturierte-textdateien",
    "href": "kapitel/04-dateiformate/kapitel.html#sec-separator-strukturierte-textdateien",
    "title": "9  Dateiformate",
    "section": "9.6 Separator-strukturierte Textdateien",
    "text": "9.6 Separator-strukturierte Textdateien\nEine besondere Klasse der zeilenbasierten Textdateien sind die sog. “Separator-strukturierten” Dateien. Diese Dateiformate sind eine einfache Form der Tabellenkodierung, bei der die Werte in der gleichen Zeile durch ein zusätzlichens Trennzeichen voneinander abgegrenzt werden.\nSeparator-strukturierte Dateien sind zeilenbasierte Textdateien, bei denen die Werte in einer Zeile durch ein Trennzeichen voneinander abgegrenzt werden. Dadurch lassen sich die Werte in einer Zeile leichter als bei einer Festkodierung kodieren und dekodieren. Für die Trennung der Werte muss nur das verwendete Trennzeichen bekannt sein. Die Position und die Länge der Werte wird durch das Trennzeichen festgelegt und muss nicht vorab definiert werden.\nDie verbreitetsten Separator-strukturierten Dateiformate sind:\n\nTab-separated values (TSV)\nComma-separated values (CSV)\nPipe-separated values (PSV)\n\nDer Unterschied zwischen diesen Formaten ist das verwendete Trennzeichen. TSV-Dateien werden durch ein Tabulatorzeichen getrennt, CSV-Dateien durch ein Komma und bei PSV-Dateien durch ein Pipe-Symbol.\nDas einfachste Trennzeichen wäre das Leerzeichen. Das Leerzeichen ist als Trennzeichen nur dann geeignet, wenn es als Symbol in den Werten nicht vorkommen kann. Das ist bei vielen Daten nicht der Fall. Deshalb wird häufig das Tabulator-Symbol (\\t) als Alternative zum Leerzeichen verwendet. Das Tabulator-Symbol ist ein nicht-druckbares Zeichen, das dem Leerzeichen ähnelt, aber seltener in Werten vorkommt. Dieses einfache Format wird als Tab-separated values (TSV) bezeichnet (Lindner, 1993).\n\nBeispiel 9.2 (TSV-Daten)  \nName    Vorname Geburtsdatum    Geburtsort  Grösse\nMüller  Hans 01.01.1990  Berlin   1.76\nUntermayr Peter   01.01.1980  Wien 1.82\nOsterwalder Urs    01.01.1970   Bern  1.78\n\nDie Basis für die meisten anderen Separator-strukturierten Dateiformate ist das standardisierte CSV-Format (Shafranovich, 2005). Die Trennzeichen der CSV Spezifikation sind das Komma (,) und der Zeilenumbruch. Zusätzlich können die Werte in Anführungszeichen gesetzt werden, um die Werte zu schützen, falls diese ein Komma enthalten.\n\nBeispiel 9.3 (CSV-Daten)  \nName,Vorname,Geburtsdatum,Geburtsort,Grösse\nMüller,Hans,01.01.1990,Berlin,1.76\nUntermayr,Peter,01.01.1980,Wien,1.82\nOsterwalder,Urs,01.01.1970,Bern,1.78\n\nIm deutschsprachigen Raum wird die CSV-Spezifikation oft abgewandelt. Dabei wird das Komma durch ein Semikolon (;) ersetzt. Dadurch kann das Komma als Dezimaltrennzeichen verwendet werden, ohne es zusätzlich durch Anführungszeichen geschützt zu werden. Diese Abwandlung wird als Semikolon-separierte Werte bezeichnet und ebenfalls als CSV abgekürzt.\n\nBeispiel 9.4 (Semikolon-Daten)  \nName;Vorname;Geburtsdatum;Geburtsort;Grösse\nMüller;Hans;01.01.1990;Berlin;1,76\nUntermayr;Peter;01.01.1980;Wien;1,82\nOsterwalder;Urs;01.01.1970;Bern;1,78\n\n\n\n\n\n\n\nAchtung\n\n\n\nWeil beim CSV-Format zwei unterschiedliche Trennzeichen verwendet werden, treten beim Importieren oft Fehler auf, weil der Parser für das falsche Trennzeichen verwendet wurde. Bei der Arbeit mit CSV-Dateien sollte deshalb eine Datendatei auf das verwendete Trennzeichen geprüft werden. Diese Überprüfung kann entfallen, wenn das Trennzeichen dokumentiert wurde.\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nBeim Importieren von CSV-Dateien in der Schweiz muss zusätzlich das Dezimaltrennzeichen geprüft werden. Werden die Daten aus einer Excel-Version mit deutschen Regionseinstellungen exportiert, dann wird das Semikolon als Feldtrennzeichen und das Komma als Dezimaltrennzeichen verwendet. Werden die Daten aus einer Excel-Version mit englischen Regionseinstellungen exportiert, dann wird das Komma als Feldtrennzeichen und der Punkt als Dezimaltrennzeichen verwendet.\nIn der Schweiz wird als Dezimaltrennzeichen wie im Englischen meistens ein Punkt verwendet. Werden Daten aus einer Excel-Version mit schweizer Regionseinstellungen werden die Trennzeichen gemischt: Als Feldtrennzeichen wird das Semikolon und als Dezimaltrennzeichen der Punkt verwendet. Das kann beim Import der Daten zu Fehlern führen, wenn das Dezimaltrennzeichen von einem Parser nicht angepasst wurde oder werden kann.\n\n\nDas PSV-Format verwendet das Pipe-Symbol (|) als Trennzeichen. Während im CSV-Format Überschriften und Werte nicht klar unterschieden werden können, ist beim PSV-Format möglich. Dazu wird nach dem Überschriften eine Zeile mit Minuszeichen (-) und Trennzeichen eingefügt, um die Überschriften von den Werten abzugrenzen. Das PSV-Format wird oft als eingebettetes Format in Markdown-Dateien verwendet.\n\nBeispiel 9.5 (PSV-Daten mit Überschriften)  \nName|Vorname|Geburtsdatum|Geburtsort|Grösse\n----|-------|------------|----------|------\nMüller|Hans|01.01.1990|Berlin|1.76\nUntermayr|Peter|01.01.1980|Wien|1.82\nOsterwalder|Urs|01.01.1970|Bern|1.78\n\nEine Erweiterung des PSV-Formats ist das sog. Markdown-Tabellenformat. Dieses Format erlaubt Zellenformatierungen für die Spalten. Dazu wird im Überschriftentrenner (-) ein Doppelpunkt (:) verwendet. Die Position des Doppelpunkts legt die Ausrichtung der Spalte fest. Fehlt ein Doppelpunkt oder steht ein Doppelpunkt am Anfang der Spalte formatiert die Spalte linksbündig, ein Doppelpunkt am Ende der Spalte formatiert die Spalte rechtsbündig und ein Doppelpunkt am Anfang und Ende der Spalte formatiert die Spalte zentriert.\n\nBeispiel 9.6 (Markdown-Tabellenformat)  \nName|Vorname|Geburtsdatum|Geburtsort|Grösse\n:---|:---:|---:|---|---:\nMüller|Hans|01.01.1990|Berlin|1.76\nUntermayr|Peter|01.01.1980|Wien|1.82\nOsterwalder|Urs|01.01.1970|Bern|1.78\nDas Ergebnis wird wie folgt dargestellt.\n\n\n\nName\nVorname\nGeburtsdatum\nGeburtsort\nGrösse\n\n\n\n\nMüller\nHans\n01.01.1990\nBerlin\n1.76\n\n\nUntermayr\nPeter\n01.01.1980\nWien\n1.82\n\n\nOsterwalder\nUrs\n01.01.1970\nBern\n1.78"
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#excel-arbeitsmappen",
    "href": "kapitel/04-dateiformate/kapitel.html#excel-arbeitsmappen",
    "title": "9  Dateiformate",
    "section": "9.7 Excel-Arbeitsmappen",
    "text": "9.7 Excel-Arbeitsmappen\nExcel-Arbeitsmappen (xlsx) fassen mehrere Tabellen zusammen. Excel-Arbeitsmappen werden als komprimiertes Dateiarchiv gespeichert. Deshalb wird das Format von EXCEL-Arbeitsmappen als Binärformat bezeichnet.\nAnders als bei Textdateien in denen nur die Werte und deren Struktur kodiert wird, werden bei EXCEL-Arbeitsmappen auch komplexe Formatierungen, Grafiken und die Berechnungen kodiert (Carpenter, 2023). Die einzelnen Arbeitsblätter werden zwar als Mengenkodierung behandelt, das eigentliche Dateiformat folgt einer Baumstruktur.\nExcel-Arbeitsmappen fassen mehrere benannte Arbeitsblätter zusammen. Ein Arbeitsblatt ist eine Struktur aus Zeilen und Spalten, die tabellarisch organisiert ist. Dadurch ist es möglich, dass mehrere Tabellen auf einem Arbeitsblatt vorhanden sind. Falls diese Tabellen nicht explizit als Datentyp Tabelle markiert wurden, muss diese Kodierung separat dokumentiert werden.\n\n\n\n\n\n\nPraxis\n\n\n\nUm Excel-Arbeitsmappen mit anderen Programmiersprachen zu verarbeiten muss die Struktur der Arbeitsmappe berücksichtigt werden. Daten sind immer nur über das Arbeitsblatt zugreifbar. Deshalb muss immer zuerst ein Arbeitsblatt ausgewählt werden, bevor auf die Daten zugegriffen werden kann.\nArbeitsblätter haben immer zwei Modi: Den Wertemodus und den Formelmodus. Der gewünschte Moduls muss programmatisch festgelegt werden.\nIm Wertemodus werden die Werte der Zellen angezeigt. Im Formelmodus werden die Formeln der Zellen angezeigt. Wenn eine Zelle nur einen Wert aber keine Formel enthält, wird auch im Formelmodus der Wert bereitgestellt."
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#markup-formate",
    "href": "kapitel/04-dateiformate/kapitel.html#markup-formate",
    "title": "9  Dateiformate",
    "section": "9.8 Markup-Formate",
    "text": "9.8 Markup-Formate\nSeparator-strukturierte Textdateien sind eine einfache Form der Tabellenkodierung. Diese Kodierung ist nur für einfache Datenstrukturen geeignet. Für komplexere Datenstrukturen reichen diese Formate nicht aus.\nEin Ansatz zur Speicherung von komplexen Datenstrukturen als Textdateien sind die sog. Markup-Sprachen. Markup-Sprachen sind Textdateien, mit denen Datenstrukturen durch Markierungen beschrieben werden. Sie sind als Datenbeschreibung eine Form der Baumkodierung. Dadurch lassen sich beliebig komplexe Datenstrukturen abbilden.\nDie zwei am häufigsten benutzten Markupsprachen sind XML (Bray et al., 2008) und HTML (Hickson et al., o. J.). Beide Markupsprachen basieren auf dem gemeinsamen SGML-Standard (ISO/IEC JTC 1/SC 34, 1999). XML schränkt Datenorganisation ein, so dass Daten immer eindeutig abgebildet werden können. HTML stellt die Syntax für die Strukturierung von Webseiten bereit. Bei HTML stehen deshalb die Abbildung von Datenstrukturen nicht im Vordergrund.\nBeide Formate verwenden sog. Tags als Markierungen im Text. Ein Tag wird durch eine öffnende spitze Klammer eingeleitet und eine schliessende spitze Klammer beendet. Das Tag hat einen Namen, welcher unmittelbar der öffnenden Klammer folgt. Tags können abgeschlossen werden, indem ein Schrägstrich (/) dem Tag-Namen vorangestellt wird.\n\nBeispiel 9.7 (Markup-Tag)  \n&lt;tag-name&gt;&lt;/tag-name&gt;\n\nTags können ausserdem Attribute enthalten. Attribute sind Schlüssel-Wert-Paare, die dem Tag zugeordnet sind. Die Werte von Attributen werden in der Regel in Anführungszeichen gesetzt.\n\nBeispiel 9.8 (Markup-Tag mit einem Attribut)  \n&lt;tag-name name=\"Wert\"&gt;&lt;/tag-name&gt;\n\nTags können geschachtelt werden, wobei die Schachtelung durch die Reihenfolge der Tags festgelegt wird.\n\nBeispiel 9.9 (Geschachtelte Tags)  \n&lt;tag-name&gt;&lt;unter-tag&gt;Wert&lt;/unter-tag&gt;&lt;/tag-name&gt;\n\nBeide Markup-Sprachen ignorieren Leerzeichen und Zeilenumbrüche. Dadurch können die Daten in einer Markup-Sprache beliebig formatiert werden, ohne die Bedeutung der Daten zu verändern. Entsprechend sind Beispiel 9.9 und Beispiel 9.10 gleichwertig.\n\nBeispiel 9.10 (Geschachtelte Tags mit Zeilenumbrüchen und Leerzeichen)  \n&lt;tag-name&gt;\n   &lt;unter-tag&gt;\n      Wert\n   &lt;/unter-tag&gt;\n&lt;/tag-name&gt;\n\nDie Flexibilität von Markup-Sprachen hat die Folge, dass sie meistens sehr komplex sind und sich nicht direkt in die Datenstrukturen von Programmiersprachen übersetzen lassen. Deshalb wird für Markup-Sprachen ein sog. Document-Object-Model (DOM) definiert, damit die Daten in die für Programmiersprachen üblichen Datenstrukturen übersetzt werden können.\n\n9.8.1 XML\nXML wurde als flexibles Datenbeschreibungsformat konzipiert, dass an die Anforderungen unterschiedlicher Anwendungen angepasst werden kann. XML gibt die Formatierung von Datenserialisierungen vor. Die eigentlichen Datenstrukturen müssen über ein separates Schema spezifiziert werden. Deshalb ist XML eine Metasprache und keine Markup-Sprache im eigentlichen Sinn.\nEin XML-Tag steht dabei für eine Datenstruktur. Bei geschachtelten Strukturen erfordert XML, das die hierarchischen Abhängigkeiten explizit im Format markiert werden. Deshalb müssen geschachtelte Tags immer in der umgekehrten Reihenfolge geschlossen werden, in der sie geöffnet wurden.\nDie Namen für XML-Tags dürfen frei gewählt werden, wobei Leerzeichen im Namen von Tags und Attributen verboten sind.\nXML kann Werte als Attribut oder als Inhalt eines Tags kodieren. Die Wahl der Kodierung ist abhängig vom vorgegebenen Datenschema. Für neue Datenschema hat sich eingebürgert, Werte als Inhalte in hierarchischer Form zu kodieren.\n\nBeispiel 9.11 (XML-Format einer tabellarischen Struktur in hierarchischer Form)  \n&lt;daten&gt;\n  &lt;person&gt;\n   &lt;name&gt;Müller&lt;/name&gt; \n   &lt;vorname&gt;Hans&lt;/vorname&gt; \n   &lt;geburtsort&gt;Berlin&lt;/geburtsort&gt; \n   &lt;geburtsdatum&gt;01.01.1990&lt;/geburtsdatum&gt;\n   &lt;grösse&gt;1.76&lt;/grösse&gt;\n  &lt;/person&gt;\n  &lt;person&gt;\n   &lt;name&gt;Untermayr&lt;/name&gt; \n   &lt;vorname&gt;Peter&lt;/vorname&gt; \n   &lt;geburtsort&gt;Wien&lt;/geburtsort&gt; \n   &lt;geburtsdatum&gt;01.01.1980&lt;/geburtsdatum&gt;\n   &lt;grösse&gt;1.82&lt;/grösse&gt;\n  &lt;/person&gt;\n  &lt;person&gt;\n   &lt;name&gt;Osterwalder&lt;/name&gt; \n   &lt;vorname&gt;Urs&lt;/vorname&gt; \n   &lt;geburtsort&gt;Bern&lt;/geburtsort&gt; \n   &lt;geburtsdatum&gt;01.01.1970&lt;/geburtsdatum&gt;\n   &lt;grösse&gt;1.78&lt;/grösse&gt;\n  &lt;/person&gt;\n&lt;/daten&gt;\n\nAttribute sollten nur für die Kodierung von ergänzenden Daten verwendet. Zu solchen Daten ghört beispielsweise der Datentyp eines Wertes, weil XML alle Werte nur als Zeichenketten abbildet.\n\nBeispiel 9.12 (XML-Format einer tabellarischen Struktur mit ergänzenden Attributen)  \n&lt;daten&gt;\n  &lt;person&gt;\n   &lt;name typ=\"text\"&gt;Müller&lt;/name&gt; \n   &lt;vorname typ=\"text\"&gt;Hans&lt;/vorname&gt; \n   &lt;geburtsort typ=\"text\"&gt;Berlin&lt;/geburtsort&gt; \n   &lt;geburtsdatum typ=\"datum\"&gt;01.01.1990&lt;/geburtsdatum&gt;\n   &lt;grösse typ=\"zahl\"&gt;1.76&lt;/grösse&gt;\n  &lt;/person&gt;\n  &lt;person&gt;\n   &lt;name typ=\"text\"&gt;Untermayr&lt;/name&gt; \n   &lt;vorname typ=\"text\"&gt;Peter&lt;/vorname&gt; \n   &lt;geburtsort typ=\"text\"&gt;Wien&lt;/geburtsort&gt; \n   &lt;geburtsdatum typ=\"datum\"&gt;01.01.1980&lt;/geburtsdatum&gt;\n   &lt;grösse typ=\"zahl\"&gt;1.82&lt;/grösse&gt;\n  &lt;/person&gt;\n  &lt;person&gt;\n   &lt;name typ=\"text\"&gt;Osterwalder&lt;/name&gt; \n   &lt;vorname typ=\"text\"&gt;Urs&lt;/vorname&gt; \n   &lt;geburtsort typ=\"text\"&gt;Bern&lt;/geburtsort&gt; \n   &lt;geburtsdatum typ=\"datum\"&gt;01.01.1970&lt;/geburtsdatum&gt;\n   &lt;grösse typ=\"zahl\"&gt;1.78&lt;/grösse&gt;\n  &lt;/person&gt;\n&lt;/daten&gt;\n\nDie Kodierung von Werten als Attribute findet sich nur noch in älteren XML-Dokumenten.\n\nBeispiel 9.13 (XML-Format einer tabellarischen Struktur mit Werten als Attribute)  \n&lt;daten&gt;\n  &lt;person name=\"Müller\" vorname=\"Hans\" geburtsort=\"Berlin\" \n          geburtsdatum=\"01.01.1990\" grösse=\"1.76\"&gt;&lt;/person&gt;\n  &lt;person name=\"Untermayr\" vorname=\"Peter\" geburtsort=\"Wien\" \n          geburtsdatum=\"01.01.1980\" grösse=\"1.82\"&gt;&lt;/person&gt;\n  &lt;person name=\"Osterwalder\" vorname=\"Urs\" geburtsort=\"Bern\" \n          geburtsdatum=\"01.01.1970\" grösse=\"1.78\"&gt;&lt;/person&gt;\n&lt;/daten&gt;\n\nAus den Beispielen wird deutlich, dass die Kodierung im XML-Format zwar sehr flexibel ist, aber auch sehr komplex werden kann und wenig speichereffizient ist. Das kann ein Problem werden, wenn viele Daten zwischen Rechnern übertragen werden müssen. Deshalb wird XML heute nur noch für Anwendungen verwendet, bei denen die Flexibilität der Kodierung wichtiger ist als die Speichereffizienz.\n\n\n\n\n\n\nHinweis\n\n\n\nEine Anwendung, die alle Daten im XML-Format speichert ist Excel. Diese Daten werden aber hinter den Kulissen in einem Binärformat gespeichert. Deshalb ist es nicht möglich, Excel-Arbeitsmappen direkt als XML-Dateien zu öffnen.\n\n\n\n\n9.8.2 HTML\nHTML wurde als Format für die Strukturierung von Webseiten entwickelt. Deshalb ist HTML eine echte Markup-Sprache, bei der die Namen der zulässigen Tags vorgegeben ist. Bei HTML steht dabei die Strukturierung von Webseiten im Vordergrund.\nHTML ist für die Datenkodierung nur von Bedeutung, wenn Daten als Webseiten dargestellt werden sollen. Tabellarische Daten können auf Webseiten leicht identifiziert werden, weil es dafür spezielle HTML-Tags gibt.\n\nBeispiel 9.14 (HTML-Format einer tabellarischen Struktur)  \n&lt;table&gt;\n  &lt;tr&gt;\n    &lt;th&gt;Name&lt;/th&gt;\n    &lt;th&gt;Vorname&lt;/th&gt;\n    &lt;th&gt;Geburtsdatum&lt;/th&gt;\n    &lt;th&gt;Geburtsort&lt;/th&gt;\n    &lt;th&gt;Grösse&lt;/th&gt;\n  &lt;/tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;Müller&lt;/td&gt;\n    &lt;td&gt;Hans&lt;/td&gt;\n    &lt;td&gt;01.01.1990&lt;/td&gt;\n    &lt;td&gt;Berlin&lt;/td&gt;\n    &lt;td&gt;1.76&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;Untermayr&lt;/td&gt;\n    &lt;td&gt;Peter&lt;/td&gt;\n    &lt;td&gt;01.01.1980&lt;/td&gt;\n    &lt;td&gt;Wien&lt;/td&gt;\n    &lt;td&gt;1.82&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;tr&gt;\n    &lt;td&gt;Osterwalder&lt;/td&gt;\n    &lt;td&gt;Urs&lt;/td&gt;\n    &lt;td&gt;01.01.1970&lt;/td&gt;\n    &lt;td&gt;Bern&lt;/td&gt;\n    &lt;td&gt;1.78&lt;/td&gt;\n  &lt;/tr&gt;\n&lt;/table&gt;\n\n\n\n\n\n\n\nPraxis\n\n\n\nDer Datenaustausch über HTML-Tabellen ist inzwischen vernachlässigbar. HTML-Tabellen werden fast ausschliesslich für die Darstellung von Daten innerhalb von Anwendungen verwendet. Es gibt praktische keine Datenquellen mehr, deren Daten ausschliesslich als HTML-Tabellen vorliegen. Häufig werden Mess-Daten auch nicht mehr auf Web-Seiten bereitgestellt, sondern nur über Dateien in einem einem effizienteren Format verlinkt."
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#json",
    "href": "kapitel/04-dateiformate/kapitel.html#json",
    "title": "9  Dateiformate",
    "section": "9.9 JSON",
    "text": "9.9 JSON\nMit der wachsenden Popularität des WWW wurde eine effizientere Form zur Kodierung komplexer Datenstrukturen erforderlich, um die Komplexität von Markupsprachen zu umgehen. Deshalb wurde die JavaScript Object Notation (JSON) entwickelt. JSON ist eine einfache Form der Baumkodierung. JSON ist eine Untermenge der JavaScript-Syntax und umfasst nur die Elemente zur Beschreibung von Datenstrukturen. Ein JSON-Dokument beschreibt deshalb immer eine gültige JavaScript-Datenstruktur. Deshalb kann JSON von JavaScript-Programmen in die üblichen Datenstrukturen überführt werden. Das vereinfacht die Programmierung und die Interaktivität von Anwendungen, die in Webbrowsern ausgeführt werden.\nJSON ist ein standardisiertes Datenformat (Bray, 2017) und wird inzwischen von allen wichtigen Programmiersprachen unterstützt. Auch JSON ist ein Markup-Format, bei dem die Markierungen der JavaScript-Syntax folgen.\nJSON kennt nur sechs Datentypen, wodurch die Kodierung sehr einfach umzusetzen ist. Die Datentypen sind:\n\nZahlen\nZeichenketten\nBoole’sche Werte\nListen\nObjekte\nnull (undefiniert)\n\nZeichenketten müssen immer durch doppelte Anführungszeichen (\") eingeleitet und abgeschlossen werden.\nDer Listendatentyp wird durch Block-Klammern ([ und ]) markiert.\nDer Objekt-Datentyp gibt dem Format seinen Namen. Objekte werden durch geschweifte Klammern ({ und }) markiert und sind eine Menge von Schlüssel-Wert-Paaren. Die Schlüssel sind Zeichenketten, wobei jeder Schlüssel nur einmal pro Objekt vorkommen darf. Die Werte können von beliebigen JSON-Datentypen sein. Schlüssel und Werte sind immer durch einen Doppelpunkt getrennt.\nTabellarische Strukturen lassen sich in JSON auf zwei Arten abbilden:\n\nAls Liste von Objekten\nAls Objekt mit Listen\n\nDie erste Variante ist die gebräuchlichste, weil beim die Bedeutung der zusammenhängenden Werte durch die Schlüssel meistens einfacher verarbeitet werden kann.\n\nBeispiel 9.15 (Tabellenstruktur im JSON-Format als Liste von Objekten)  \n[\n    {\n        \"name\": \"Müller\",\n        \"vorname\": \"Hans\",\n        \"geburtsdatum\": \"01.01.1990\",\n        \"geburtsort\": \"Berlin\",\n        \"grösse\": 1.76\n    },\n    {\n        \"name\": \"Untermayr\",\n        \"vorname\": \"Peter\",\n        \"geburtsdatum\": \"01.01.1980\",\n        \"geburtsort\": \"Wien\",\n        \"grösse\": 1.82\n    },\n    {\n        \"name\": \"Osterwalder\",\n        \"vorname\": \"Urs\",\n        \"geburtsdatum\": \"01.01.1970\",\n        \"geburtsort\": \"Bern\",\n        \"grösse\": 1.78\n    }\n]\n\nDie Objekt-mit-Listen Strukturierung eignet sich, wenn die Vektorstruktur der Daten im Vordergrund steht. In diesem Fall werden die Werte in einer Liste zusammengefasst und die Schlüssel werden als Index verwendet.\n\nBeispiel 9.16 (Tabellenstruktur im JSON-Format als Objekt mit Listen)  \n{\n    \"name\": [\"Müller\", \"Untermayr\", \"Osterwalder\"],\n    \"vorname\": [\"Hans\", \"Peter\", \"Urs\"],\n    \"geburtsdatum\": [\"01.01.1990\", \"01.01.1980\", \"01.01.1970\"],\n    \"geburtsort\": [\"Berlin\", \"Wien\", \"Bern\"],\n    \"grösse\": [1.76, 1.82, 1.78]\n}\n\n\n\n\n\n\n\nWarnung\n\n\n\nDie Objekt-mit-Listen-Strukturierung ist weniger verbreitet, weil diese Strukturierung den Erhalt der Zusammenhänge zwischen den Werten nicht sicherstellt. Es wäre also denkbar, die Werte einer Liste in einer anderen Reihenfolge neu anzuordnen, ohne dass über die Positionen zusammenhängenden Werte ebenfalls angepasst werden.\nDieses Problem besteht bei der Liste-von-Objekten-Strukturierung nicht."
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#yaml",
    "href": "kapitel/04-dateiformate/kapitel.html#yaml",
    "title": "9  Dateiformate",
    "section": "9.10 YAML",
    "text": "9.10 YAML\nIn den letzten Jahren findet eine weitere Formatierung immer häufigere Verwendung: YAML (Ben-Kiki et al., 2021). YAML ist eine einfache “menschenfreundliche” Formatierung, die auf der Einrückung von Textblöcken basiert. YAML ist ein Obermenge von JSON und deshalb ist jedes JSON-Format gleichzeitig ein gültiges YAML-Format. Das Ziel des YAML-Formats ist das vereinfachte Erstellen und Bearbeiten von strukturierten Datendokumenten durch Menschen.\nYAML hat die gleichen Datentypen wie JSON und folgt den gleichen Prinzipien zur Datenkodierung. Dadurch hat YAML die gleichen Vorteile wie JSON. YAML erlaubt zusätzlich die Verwendung von Kommentaren, die in JSON nicht vorgesehen sind. Solche Kommentare dienen nur der Dokumentation für die menschliche Interaktion und werden beim Laden eines YAML-Dokuments ignoriert.\nDer Aufälligste Unterschied zwischen YAML und JSON ist die Verwendung von Einrückungen zur Strukturierung von Daten. Dadurch ist YAML für Menschen etwas leichter lesbar und verständlich. Auch müssen Zeichenketten meistens nicht explizit markiert werden. YAML legt Regeln zur automatischen Erkennung des Datentyps fest. So müssen nur in Ausnahmefällen Zeichenketten explizit markiert werden, was bspw. zur Unterscheidung von Wahrheitswerten und Zeichenketten müssen Zeichenketten explizit markiert werden, wenn eine Zeichenkette nur aus einem Schlüsselwort für einen Boole’schen Wert besteht. Zeichenketten müssen auch mit doppelten Anführungszeichen (\") markiert werden, wenn die Zeichenkette einen Doppelpunkt enhält.\n\nBeispiel 9.17 (Zeichenkettenmarkierung in YAML)  \n# Zeichenkette mit Doppelpunkt\n- \"Müller: Hans\"\n# Objekt mit Schlüssel \"Müller\" und Wert \"Hans\"\n- Müller: Hans\n# Zeichenkette mit Wahrheitswert\n- \"true\"\n- \"no\"\n# Wahrheitswerte werden intern in Wahr und Falsch umgewandelt\n- true\n- no\n\nWeil YAML die Objektstruktur visuell unterstützt, erfolgt eine Datenkodierung von tabellarischen Strukturen in der Regel über Listen von Objekten.\n\nBeispiel 9.18 (Tabellenstruktur im YAML-Format als Liste von Objekten)  \n- name: Müller\n  vorname: Hans\n  geburtsdatum: 01.01.1990\n  geburtsort: Berlin\n  grösse: 1.76\n- name: Untermayr\n  vorname: Peter\n  geburtsdatum: 01.01.1980\n  geburtsort: Wien\n  grösse: 1.82\n- name: Osterwalder\n  vorname: Urs\n  geburtsdatum: 01.01.1970\n  geburtsort: Bern\n  grösse: 1.78"
  },
  {
    "objectID": "kapitel/04-dateiformate/kapitel.html#dateiformate-und-versionierung",
    "href": "kapitel/04-dateiformate/kapitel.html#dateiformate-und-versionierung",
    "title": "9  Dateiformate",
    "section": "9.11 Dateiformate und Versionierung",
    "text": "9.11 Dateiformate und Versionierung\nBei der Versionierung von Daten spielt das Dateiformat eine zentrale Rolle.\nDaten in separator-strukturierte Textdateien oder im YAML-Format lassen sich besonders einfach versionieren, weil sie als zeilenorientierte Formate direkt von den Versionierungssystemen unterstützt werden.\nBei XML- und JSON-Daten ist die Situation etwas komplexer: Diese Formate sind nicht zeilenorientiert und die gleiche Struktur kann auf unterschiedliche Arten im gleichen Format serialisiert werden. Dadurch wird die Versionierung dieser Dateiformate erschwert.\nDie Versionierung von Binärformaten ist noch komplexer, weil Versionierungssystem diese Formate nicht auf der Inhaltsebene unterstützen. Deshalb ist es üblich, Daten in diesem Formaten vor der Versionierung in ein zeilenorientiertes Format überführt werden. Das betrifft sehr häufig Excel-Arbeitsmappen, weil sich die Binärdaten bei jedem Zugriff ändern, ohne dass die Daten selbst verändert wurden.\n\n\n\n\n\n\nPraxis\n\n\n\nEs ist üblich Daten anstatt in Excel-Arbeitsmappen in CSV-Dateien zu speichern, um die Daten versionieren zu können. Die CSV-Dateien werden dann in Excel als externe Daten importiert.\n\n\n\n\n\n\nAmerican National Standards Institute. (1977). Code for Information Interchange (ANSI X3.4-1977). https://nvlpubs.nist.gov/nistpubs/Legacy/FIPS/fipspub1-2-1977.pdf\n\n\nBen-Kiki, O., Evans, C., & Net, I. döt. (2021). YAML Ain’t Markup Language (Version v1.2.2). https://yaml.org/spec/1.2.2/\n\n\nBray, T. (2017). The JavaScript Object Notation (JSON) Data Interchange Format (RFC 8259). https://datatracker.ietf.org/doc/html/rfc8259\n\n\nBray, T., Paoli, J., Sperberg-McQueen, C. M., Maler, E., & Yergeau, F. (2008). Extensible Markup Language (XML) 1.0 (Fifth Edition) (Version 1.0). https://www.w3.org/TR/xml/\n\n\nCarpenter, M. (2023). [MS-XLSX]: Excel (.xlsx) Extensions to the Office Open XML SpreadsheetML File Format (Version v23.4). https://learn.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/2c5dee00-eff2-4b22-92b6-0738acd4475e\n\n\nHickson, I., Pieters, S., Kesteren, A. van, Jägenstedt, P., & Denicola, D. (o. J.). HTML (Version 5). https://html.spec.whatwg.org/multipage/\n\n\nISO/IEC JTC 1/SC 2. (2020). Information technology — Universal coded character set (UCS) (ISO/IEC 10646:2020). https://www.iso.org/standard/76835.html\n\n\nISO/IEC JTC 1/SC 2/WG 3. (1998a). DIS 8859-1, 8-bit single-byte coded graphic character sets – Part 1: Latin alphabet No.1 (N 411). https://www.open-std.org/JTC1/sc2/wg3/docs/n411.pdf\n\n\nISO/IEC JTC 1/SC 2/WG 3. (1998b). ISO/IEC FCD 8859-15 Information technology – 8 –bit singlebyte coded graphic character sets – Part 15 : Latin Alphabet 0 (Covering the EURO symbol and full support for the French and Finish languages (N 404). https://www.open-std.org/JTC1/SC2/WG3/docs/n404.pdf\n\n\nISO/IEC JTC 1/SC 34. (1999). Information processing — Text and office systems — Standard Generalized Markup Language (SGML) (ISO 8879:1986). https://www.iso.org/standard/16387.html\n\n\nISO/TC 68/SC 8. (2020). Financial services — International bank account number (IBAN) — Part 1: Structure of the IBAN (ISO 13616-1:2020). https://www.iso.org/standard/81090.html\n\n\nLindner, P. (1993). Definition of tab-separated-values (tsv). https://www.iana.org/assignments/media-types/text/tab-separated-values\n\n\nShafranovich, Y. (2005). Common Format and MIME Type for Comma-Separated Values (CSV) Files (RFC 4180). https://datatracker.ietf.org/doc/html/rfc4180\n\n\nThe Unicode Consortium. (2022). Unicode. https://www.unicode.org/versions/latest/"
  },
  {
    "objectID": "kapitel/06-variablen/kapitel.html#variablen",
    "href": "kapitel/06-variablen/kapitel.html#variablen",
    "title": "10  Variablen, Funktionen und Operatoren",
    "section": "10.1 Variablen",
    "text": "10.1 Variablen\nBei der Datenverarbeitung müssen Daten auch gespeichert werden, um sie wiederzufinden. Dazu werden die Daten mit einem Bezeichner versehen, über den auf die Daten zugegriffen werden kann. Diese Bezeichner sind in der Folge mit dem zugewiesenen Wert gleichwertig.\n\nDefinition 10.1 Ein Bezeichner ist ein Platzhalter für Werte. Ein Bezeichner hat immer einen eindeutigen Namen in einem Geltungsbereich.\n\nDer Begriff Wert ist hier möglichst allgemein zu denken. Ein Wert kann ein fundamentaler Datentyp oder eine Datenstruktur sein. Dateien oder git-Versionen können ebenfalls als Werte behandelt werden.\nBezeichner sind in einem Geltungsbereich immer eindeutig. Das bedeutet, dass Bezeichner mit dem gleichen Namen auf den gleichen Wert verweisen. Ein Bezeichner kann nicht gleichzeitig auf zwei Werte verweisen. Das Wort Geltungsbereich bezieht sich auf dem Zusammenhang, in dem ein Bezeichner verwendet wird. Die Definition besagt daher, dass ein Bezeichner genau einmal im gleichen Zusammenhang verwendet werden darf. Deshalb ist es wichtig, den Geltungsbereich von Bezeichnern genau zu definieren.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Definition eines Geltungsbereichs ist in den meisten Programmiersprachen und -Umgebungen genau festgelegt.\n\n\nMit Bezeichnern kann wie mit Werten gearbeitet werden, weil ein Bezeichner für einen Wert steht. Ein Bezeichner kann einen einzelnen Wert oder eine beliebige komplexe Datenstruktur aufnehmen. Ein Bezeichner kann auf einen einzelne Zahl oder Zeichenkette genauso verweisen, wie auf einen Vektor, eine Liste oder eine Matrix. Bezeichner sind nicht auf die fundamentalen Datentypen beschränkt. Z.B. ist ein Dateiname ein Bezeichner für die Daten in einer Datei oder ein git-Tag ist ein Bezeichner für eine bestimmte Version eines Projektes. Durch den Bezeichner wird vom eigentlichen Wert abstrahiert.\nDamit ein Wert über einen Bezeichner abstrahiert werden kann, muss er benannt werden. Das Benennen eines Wertes wird Zuweisen genannt. Der Wert wird also einem Bezeichner zugewiesen. Eine Zuweisung wird in der mathematischen Notation über einen Pfeil (\\to) dargestellt. Dabei zeigt der Pfeil vom Bezeichner auf den Wert. Diese Schreibweise bedeutet, dass ein Bezeichner auf den angegebenen Wert verweist. Die Formel 10.1 zeigt die Zuweisung des Wertes 12 an den Bezeichner Wert.\n\nWert \\to 12\n\\tag{10.1}\nEs werden zwei Arten von Bezeichnern unterschieden:\n\nunveränderliche Bezeichner\nveränderliche Bezeichner\n\n\nDefinition 10.2 Eine Konstante ist ein unveränderlicher Bezeichner.\n\nKonstanten verweisen in ihrem Geltungsbereich immer auf den gleichen Wert. Einer Konstante kann nur einmal ein Wert zugewiesen werden.\n\nDefinition 10.3 Eine Variable ist ein veränderlicher Bezeichner.\n\nVariablen kann im gleichen Geltungsbereich mehrmals ein Wert zugewiesen werden. Welcher Wert gerade für eine Variable gültig ist, hängt vom Zeitpunkt einer Verarbeitung ab."
  },
  {
    "objectID": "kapitel/06-variablen/kapitel.html#funktionen",
    "href": "kapitel/06-variablen/kapitel.html#funktionen",
    "title": "10  Variablen, Funktionen und Operatoren",
    "section": "10.2 Funktionen",
    "text": "10.2 Funktionen\nFunktionen bilden die Grundlage für die Arbeit mit Daten. Funktionen legen fest, wie zu einem bestimmten Ergebnis gelangt wird.\n\n\n\n\n\n\nMerke\n\n\n\nEine Funktion erzeugt Ergebnisse.\n\n\nAlle Ergebnisse einer Funktion sind die Funktionseffekte. Nicht alle Effekte einer Funktion sind erwünscht. Solche unerwünschten Effekte werden Nebeneffekte genannt.\nIst das Ergebnis einer Funktion ein Wert, dann heisst dieser Wert, der Rückgabewert der Funktion. Eine Funktion kann mehr als einen Effekt haben. Entsprechend muss das Ergebnis einer Funktion in einer Rückgabeliste zusammengefasst werden.\nWie eine Funktion die Effekte erzeugt, wird im Funktionskörper festgelegt.\nManche Funktionen benötigen Eingaben, um daraus die Ergebnisse zu erzeugen.\n\nDefinition 10.4 Die Eingaben einer Funktion heissen Parameter oder Funktionsargumente. Eine Funktion akzeptiert diese Parameter als Eingabe.\n\nParameter sind spezielle Variablen mit dem Geltungsbereich des Funktionskörpers.\nEine Funktion kann natürlich auch mehrere Parameter haben. Die Parameter einer Funktion werden als Parameterliste bezeichnet. Eine solche Parameterliste darf auch eine leere Liste sein.\nDie Datentypen der Parameter legen den Definitionsbereich einer Funktion fest. Der Datentyp der Rückgabe werde legt den Zielbereich fest. Eine Funktion stellt also eine Beziehung zwischen dem Definitionsbereich und dem Zielbereich her.\nEine Funktion, die keine Parameter akzeptiert, wird ist eine parameterlose Funktion. Eine parameterlose Funktion hat deshalb eine leere Parameterliste als Eingabe.\nSo lässt sich die Funktionsdefinition erweitern und präzisieren:\n\nDefinition 10.5 Eine Funktion erzeugt Effekte im Zielbereich mithilfe einer Parameterliste mit Werten im Definitionsbereich.\n\nFormal lässt sich diese Defition wird der durch die Rückgabeliste definierte Zielbereich dem Bezeichner E zugewiesen und den Defitionsbereich der Parameterliste mit P gekennzeichnet, dann ist entsprechend dieser Definition jede Funktion entsprechend Formel 10.2 definiert.\n\nf: P \\to E\n\\tag{10.2}\nDiese Formel wird wie folgt gelesen: Die Funktion f bildet den Definitionsbereich P auf den Zielbereich E ab. Die Formel kann auch analog zur Definition von Bezeichnern gelesen werden: Für die Funktion f verweisen alle Werte im Definitionsbereich P auf Werte im Zielbereich E. Diese Beziehung zwischen Definitionsbereich P und Zielbereich E legt die Funktion fest. f ist der Bezeichner der Funktion. Durch den Bezeichner und den Definitionsbereich der Parameterliste ist eine Funktion eindeutig beschrieben.\nDiese Funktionsdefinition benötigt keinen Funktionskörper. Tatsächlich können die gleichen Ergebnisse auf unterschiedlichen Wegen aus den gleichen Parametern erzeugt werden. Das kann bspw. durch die Verwendung unterschiedlicher Programmiersprachen sein.\n\nDefinition 10.6 Wenn zwei Funktionen für die gleichen Parameter das gleiche Ergebnis erzeugen, dann sind diese Funktionen funktional gleich.\n\nUm eine Funktion zu verwenden, muss diese aufgerufen werden. Ein Funktionsaufruf wird meistens durch eine rundes Klammerpaar dargestellt. Wird eine Funktion aufgerufen, wird der Funktionskörper mit den Werten in den Parametern ausgeführt. Der Funktionsaufruf f(x) wählt für einen Wert x aus dem Definitionsbereich P den entsprechenden Wert y aus dem Zielbereich E aus.\nManche Programmiersprachen ermöglichen die Verwendung des gleichen Bezeichners für unterschiedliche Definitions- und Zielbereiche.\n\nDefinition 10.7 Hat ein Funktionsbezeichner mehrere Definitionsbereiche, dann heisst diese Funktion polimorph (gr. poli: viel, gr. morphos: Gestalt).\n\nBei polimorphen Funktionen muss der Funktionsbezeichner und die Parameterliste gemeinsam eindeutig sein.\nIn den Datenwissenschaften kommen im Wesentlichen drei Arten von Funktionen zum Einsatz:\n\nTransformationen, welche einen Wert in einen anderen Wert überführen;\nAggregatoren, die mehrere Werte zusammenfassen; und\nGeneratoren, mit denen Werte erzeugt werden.\n\n\n10.2.1 Spezielle Funktionen\n\n10.2.1.1 Konstante Funktionen\n\nDefinition 10.8 Eine konstante Funktion erzeugt für jede Eingabe immer den gleichen Ergebniswert w.\n\nKonstante Funktionen sind formal wie in Formel 10.3 definiert:\n\nf_{kW}(x) \\to W\n\\tag{10.3}\nDas bedeutet, dass unabhängig von der Eingabe immer der Wert von W als Ergebnis folgt.\n\n\n10.2.1.2 Die Identitätsfunktion\nDie nächste Funktion ähnelt in ihrer Definition konstanten Funktionen.\n\nDefinition 10.9 Die Identitätsfunktion gibt für eine Eingabe diese Eingabe als Ergebnis zurück.\n\nDie formale Definition der Identitätsfunktion zeigt Formel 10.4.\n\nf_{id}(x) \\to x\n\\tag{10.4}\nIm Unterschied zu konstanten Funktionen ist das Ergebnis kein konstanter Wert, sondern der Wert der Parameter. Auf den ersten Blick erscheint diese Funktion sinnlos, denn sie verändert die Eingabeparameter nicht. Diese Funktion erfüllt in der Mathematik und in den Datenwissenschaften die gleiche Bedeutung wie die Zahl 1 für die Multiplikation oder die Zahl 0 für die Addition.\nDie Identitätsfunktion ist umkehrbar. Die Umkehrfunktion der Identitätsfunktion ist die Identitätsfunktion selbst.\n\n\n10.2.1.3 Projektionen\n\nDefinition 10.10 Eine Projektion bezeichnet eine Funktion, die den gleichen Eingaben immer die gleichen Ergebnisse zuweist.\n\n\nDefinition 10.11 Eine Projektion heisst umkehrbar, wenn eine zweite Funktion existiert, welche die Rückgabeliste der ersten Funktion als Parameterliste hat und aus dieser die Parameterliste der ersten Funktion als Rückgabeliste erzeugt. Diese zweite Funktion ist die Umkehrfunktion der ersten Funktion.\n\nDie Umkehrfunktion einer Funktion f wird als f^{-1} geschrieben.\nAus diesen beiden Definitionen folgt im Umkehrschluss, dass nicht jede Funktion eine Projektion und nicht jede Projektion umkehrbar ist."
  },
  {
    "objectID": "kapitel/06-variablen/kapitel.html#operatoren",
    "href": "kapitel/06-variablen/kapitel.html#operatoren",
    "title": "10  Variablen, Funktionen und Operatoren",
    "section": "10.3 Operatoren",
    "text": "10.3 Operatoren\nAus den Grundrechenarten sind Operatoren bekannt. Diese Operatoren sind z.B. +, -, * und /. Diese Operatoren sind in der Mathematik und den Datenwissenschaften Funktionen.\n\nDefinition 10.12 Eine Operation bezeichnet die Anwendung eines Operators. Eine Operation besteht aus einem Operator und den Operanden.\n\nEin Operator ist eine alternative Schreibweise für häufig verwendete Funktionen.\nDie meisten Operatoren sind unär oder binär. Unäre Operatoren haben nur einen Parameter. Ein unärer Operator ist das Vorzeichen - oder das %-Zeichen. Binäre Operatoren haben zwei Parameter. Alle Grundrechenarten sind binäre Operatoren.\nBei Operatoren wird zwischen Präfix, Infix und Postfix unterschieden. Präfix-Operatoren stehen vor den Parametern, Infix-Operatoren zwischen den Parametern und Postfix-Operatoren stehen nach den Parametern. Die Grundrechenarten sind Infix-Operatoren.\n\n10.3.1 Precedence - Prioriät von Operatoren\nIn komplexen Operationen ist nicht immer eindeutig, welche Parameter zu welchem Operator gehören. Damit richtigt gerechnet wird, besteht zwischen den Operatoren eine Hierachie, in welcher jeder Operator eine bestimmte Priorität für die Ausführung hat. Das bedeutet, dass ein Operator mit höherer Priorität vor einem Opeartor mit niedrigerer Priorität ausgeführt wird. Bei Operatoren mit gleicher Priorität wird immer der am weitesten links stehende Operator zuerst ausgeführt.\nUm einen Operator in der Anwendung vorzureihen, werden Klammern verwendet. Klammern legen die Reihenfolge der Operationen fest.\nEine wichtige Hierarchie für die Grundrechenarten ist die sog. KEPS-Regel. Diese Regel legt die Reihenfolge der Operationen fest. Die KEPS-Regel ist eine Abkürzung für die Operationen:\n\nKlammern\nExponenten\nPunktrechnung\nStrichrechnung.\n\nDiese Abkürzung dient als Eselsbrücke für die Prioritäten der Grundrechenarten. Sind zwei Operationen auf der gleichen Hierarchiestufe, dann werden die Operationen von links nach rechts ausgeführt.\nExponenten werden in der Mathematik in der Regel hochgestellt dargestellt. Die meisten Programmiersprachen unterstützen keine Formatierung von Formeln als Kennzeichnung von Operatoren. Deshalb wird der Potenz-Operator mit einem expliziten Operator dargestellt. Meist ist dies der ^-Operator.\n\n\n\n\n\n\nAchtung\n\n\n\nDie Programmiersprache Python weicht von dieser Konvention ab und verwendet den **-Operator für Exponenten. Der ^-Operator ist in Python der sog. bitweise XOR-Operator. (Python Software Foundation, 2013)\n\n\n\n\n10.3.2 Substitution\n\n\n\n\n\n\nHinweis\n\n\n\nWird ein Teil einer komplexen Operation in eine einfachere Funktion ausgelagert, dann spricht man von Substitution.\n\n\nIn der Mathematik wird beim Substituieren die Teiloperation in der Regel nur durch Bezeichner der ersetzenden Funktion angegeben. In der Praxis müssen solche Ersetzungsfunktionen explizit parametrisiert und ausgeführt werden.\nDie folgenden beiden Beispile illustrieren die Substituion mit einfachen mathematischen Funktionen.\nDie Operation in Formel 10.5 führt zwei Operationen nacheinander aus.\n\nf(a,b) \\to (a - b)^2\n\\tag{10.5}\nWird die Teiloperation a - b substituiert, dann ergibt sich Formel 10.6.\n\nf(a,b) \\to s^2 ;  s = a - b\n\\tag{10.6}\nIn diesem Beispiel wurde nur die Subtraktion substituiert. Weil der Bezeichner s die Subtraktion versteckt, können die Klammern der ursprünglichen Operation entfallen.\nDurch Substituieren lassen sich häufig die grundsätzlichen Ideen von komplexen Operationen leichter erkennen und vereinfachen. Das Beispiel in Formel 10.7 zeigt diesen Effekt.\n\ng(a,b) \\to \\frac{a + b - 2ab}{b-a} \\Leftrightarrow -\\frac{(a-b)^2}{a-b}\n\\tag{10.7}\nFür die rechte Operation wird in Formel 10.8 wieder die Substitution s = a - b verwendet.\nBei einer Substitution sollen möglichst viele Teilterme mit dem gleichen Bezeichner substituiert werden. Deshalb wurde der Nenner b-a so umgeformt, dass auch im Nenner der Term a-b steht. Dazu wurde ausgenutzt, dass gilt b-a \\Leftrightarrow -(a-b). Das Vorzeichen kann in diesem Fall vor dem Bruch gezogen werden, so dass die Klammern um a-b entfallen können.\n\ng(a,b) \\to - \\frac{s^2}{s} \\Leftrightarrow - s; s = a - b\n\\tag{10.8}\nDer Bezeichner der Substitution unterscheidet sich nicht von anderen Bezeichnern. Es kann also angenommen werden, dass s ein beliebiger Wert ist. So lässt sich leicht erkennen, dass s gekürzt werden kann. Rein technisch wurde für den Substitutionsterm eine Funktion s mit zwei Parametern erstellt. Diese Funktion ist in diesem Beispiel identisch mit der Funktion subtraktion(), mit der ein Wert von einem anderen abgezogen wird.\nUm die ursprüngliche Operation zu erhalten, muss die Substitution rückgängig gemacht werden. Dazu wird der substituierte Bezeichner durch die ursprüngliche Teiloperation ersetzt. Daraus ergibt sich Formel 10.9.\n\ng(a,b) \\to -(a-b) \\Leftrightarrow b-a\n\\tag{10.9}\nDiese Operation b-a ist wesentlich einfacher als die ursprüngliche Funktion. Solches Vereinfachen von Funktionen ist für die Praxis wichtig, weil dadurch zum einen die Komplexität von Operationen verringert werden kann und zum anderen die Ausführungsgeschwindigkeit durch den Wegfall von Operationen erhöht werden kann.\n\n\n10.3.3 Besondere Operatoren\n\n10.3.3.1 Divisions-Operatoren\nUnter den Grundrechenarten ist die Division ein Unikum. Als Einzige der Grundrechenarten kann das Ergebnis einen anderen Zahlentyp haben als die Operanden. Beispielsweise ergeben sich aus ganzen Zahlen rationale Zahlen und aus reellen Zahlen können sich ganze oder rationale Zahlen ergeben. Daraus ergibt sich, dass die Division über einen kontinuierlichen Wertebereich arbeitet.\nDie Division kann in zwei Unteroperationen gegliedert werden:\n\nDer Ganzzahldivision\nDem Modulo\n\nDie Ganzzahldivision hat den ganzzahligen Anteil einer Division als Ergebnis. Damit ist der Wert vor dem Komma gemeint. Diese Operation ähnelt dem Runden, allerdings wird nur der Nachkommateil entfernt.\nDie Ganzzahldivision eignet sich zur Gruppierung von Werten in gleich grosse Blöcke. Ein Block ist dabei ein Intervall im Wertebereich der Variablen. Die Grösse eines Blocks wird durch den Divisor festgelegt.\nWeil die Ganzzahldivision für mehrere Werte in einem Intervall das gleiche Ergebnis hat, wird die Ganzzahl mit der Intervallschreibweise gekennzeichnet.\n\nBeispiel 10.1 (Ganzzahldivision) \n\\lfloor \\frac{6}{4} \\rfloor = 1\n\n\nDie Modulo-Operation gibt den Rest nach der Ganzzahldivision zurück. Das Ergebnis von Modulo ist die Differenz des Dividenden bis zum Ergebnis der Ganzzahldivision mulipliziert mit dem Divisor.\n\nBeispiel 10.2 (Modulo-Operation) \nmod(6,4) = 6 - 4 \\cdot \\lfloor \\frac{6}{4} \\rfloor = 2\n\n\nModulo erzeugt nur Werte im Intervall 0 \\le m &lt; |d|, wobei m das Ergebnis von Modulo und d der Divisor ist. Auf diese Weise lassen sich beliebige Werte auf ein Intervall mit fester Länge d projizieren.\n\n\n\n\n\n\nPraxis\n\n\n\nDie Ganzzahldivision und Modulo werden häufig als einfache und effiziente Gruppiereungsoperatoren verwendet.\n\n\n\n\n10.3.3.2 Der Zuweisungsoperator\nDer Zuweisungsoperator ist ein besonderer Operator. Er ist ein binärer Operator, der einen Wert einem Bezeichner zuweist. Die meisten Programmiersprache verwenden dafür den =-Zeichen. Dabei steht der Bezeichner links und der Wert rechts vom Operator.\nManche Programmiersprachen unterstützen gerichtete Zuweisungsoperatoren, bei denen der Bezeichner rechts vom Operator steht. Diese gerichteten Zuweisungsoperatoren sind in der Regel eine Abkürzung für eine Operation mit dem Bezeichner und dem Wert.\nDer Zuweisungsoperator ist zu allen anderen Operatoren nachrangig. Das bedeutet, dass der Zuweisungsoperator immer als letzter Operator einer Operation ausgeführt wird.\n\n\n\n\n\n\nTipp\n\n\n\nDer Zuweisungsoperator ist beim Programmieren wichtig, deshalb sollte man sich beim Erlernen einer Programmiersprache unbedingt mit allen Formen dieses Operators vertraut machen.\n\n\n\n\n10.3.3.3 Der Anwendungsoperator\nWerden Klammern unmittelbar nach einem Funktionsbezeicher angegeben, dann ändern diese Klammern ihre Bedeutung, indem sie die Anwendung der bezeichneten Funktion erfordern. Mithilfe des Anwendungsoperators kann zwischen der Anwendung einer Funktion und ihrem Bezeichner unterschieden werden.\n\n\n\n\n\n\nWarnung\n\n\n\nDer Anwendungsoperator kann ausschliesslich mit Bezeichnern verwendet werden, die auf eine Funktion verweisen.\n\n\nDie Funktion addieren(a, b) hat den Bezeichner addieren und die Parameter a und b. Der Bezeichner addieren ohne den Anwendungsoperator (()), verweist auf die Funktion selbst. So kann die gleiche Funktion einem anderen Bezeichner zugewiesen werden, bspw. dem Bezeichner zusammenzählen. Es gilt dann Formel 10.10.\n\n\\begin{aligned}\naddieren(a,b) &\\to a + b \\\\\nzusammenzählen &\\to addieren\n\\end{aligned}\n\\tag{10.10}\nNun können die beiden Bezeichner mit dem Anwendungsoperator verwendet werden, um die Ergebnisse der Addition zu erhalten.\n\n\\begin{aligned}\naddieren(1, 2) &= 3 \\\\\nzusammenzählen(2, 3) &= 5 \\\\\nzusammenzählen(2, 1) &= 3\n\\end{aligned}\n\n\n\n10.3.3.4 Der Index-Operator\nIn der Mathematik werden Idicees durch tieferstellen gekennzeichnet. Ein Index wird dann verwendet, wenn ein Bezeichner auf eine Datenstruktur verweist. Der Index bezeichnet den Wert an der entsprechende Position in der Datenstruktur. Am Beispiel des Summe-Operators wird dies in Formel 10.11 verdeutlicht.\n\n\\sum_{i=1}^{n} x_i \\cdot y_i\n\\tag{10.11}\nDas Symbol \\Sigma ist der Summe-Operator. Dieser Operator addiert alle Werte im angegebenen Bereich. Hier ist das der Bereich i = 1 bis n, wobei n für die Anzahl der Werte in einer Datenstruktur steht. In diesem Fall werden zwei Listen x und y verwendet. Das tiefergestellte i bei x_i und y_i ist der rechte Operand des Indexoperators. Das i ist weiterhin ein Bezeichner. Die Summe-Funktion zählt diesen Wert hoch, bis der Wert n erreicht ist. Dieser Index gibt an, welche Werte aus den Datenstrukturen x und y addiert werden sollen. Weil der Bezeichner n nicht explizit angegeben ist, wir dieser als Konstante für die Anzahl der Werte in den Datenstrukturen angenommen. Weil der Wert von n bei zwei Datenstrukturen mehrdeutig sein könnte, bedeutet diese Schreibweise, dass beide Datenstrukturen gleich lang sind."
  },
  {
    "objectID": "kapitel/06-variablen/kapitel.html#das-neutrale-element",
    "href": "kapitel/06-variablen/kapitel.html#das-neutrale-element",
    "title": "10  Variablen, Funktionen und Operatoren",
    "section": "10.4 Das neutrale Element",
    "text": "10.4 Das neutrale Element\nManche Funktionen haben die besondere Eigenschaft, dass es einen Wert im Definitionsbereich gibt, der für alle Werte im Definitionsbereich das gleiche Ergebnis unabhängig davon erzeugt, als welcher Operand dieser Wert verwendet wird. Dieser Wert wird als das neutrales Element des Operators bezeichnet. Für die Addition ist das die Zahl 0 und für die Multiplikation ist das die Zahl 1.\n\nDefinition 10.13 Das neutrale Element eines Operators ist ein Wert im Definitionsbereich, der für alle Werte im Definitionsbereich des jeweils anderen Operanden diesen Wert als Ergebnis erzeugt.\n\nIst der Definitionsbereich durch den Datentyp Zahl festgelegt, dann muss das neutrale Element genau eine Zahl sein.\nGemäss dieser Definition muss für das neutrale Element die Gleichung Formel 10.12 gelten.\n\ne_n \\circ x = x \\circ e_n = x\n\\tag{10.12}\ne_n ist hier kein Index, sondern der Bezeichner für das neutrale Element. \\circ ist ein Operator, für den ein neutrales Element geprüft werden soll. Dieses Symbol ist ein Bezeichner für einen geeigneten Operator. x ist der jeweils andere Operand. e_n ist für den jeweiligen Operator konstant. D.h. Es muss genau einen Wert geben, für den mit allen anderen Werten des Definitionsbereichs, inklusive sich selbst, diese Gleichung erfüllt ist.\n\n10.4.1 Überprüfung\nDas neutrale Element einer Operation muss auf beiden Positionen des zugehörigen Operators immer den jeweilig anderen Operanden als Ergebnis erzeugen, so dass Formel 10.12 gilt.\nFür die Grundrechenarten lässt sich das neutrale Element durch Umformen der Definition des neutralen Elements bestimmen. Formel 10.13 zeigt das für die Addition.\n\n\\begin{aligned}\n& & e_n + a &= a \\\\\n\\Leftrightarrow & & e_n &=  a - a \\\\\n\\Leftrightarrow & & e_n &=  0\n\\end{aligned}\n\\tag{10.13}\nDieses Ergebnis wird durch Einsetzen in den restlichen Teil der Definition in Formel 10.14 überprüft.\n\n\\begin{aligned}\n& & e_n + a &= a + e_n \\\\\n\\Leftrightarrow & & 0 + a &= a + 0 \\\\\n\\Leftrightarrow & & a &= a + 0 - 0 \\\\\n\\Leftrightarrow & & a &= a\n\\end{aligned}\n\\tag{10.14}\nDie gleichen Überlegungen lassen sich auf andere Operationen, wie z.B. der Division anwenden. Das wird in Formel 10.15 gezeigt.\n\n\\begin{aligned}\n& & a : e_n &=  a \\\\\n\\Leftrightarrow & & \\frac{a}{e_n} &=  a \\\\\n\\Leftrightarrow & & e_n &=  \\frac{a}{a} \\\\\n\\Leftrightarrow & & e_n &=  1\n\\end{aligned}\n\\tag{10.15}\nZum Überprüfen wird dieses Ergebnis entsprechend eingesetzt, wie Formel 10.16.\n\n\\begin{aligned}\n& & a :  e_n &=  e_n : a \\\\\n& & a : 1 &=  1 : a \\\\\n\\Leftrightarrow & & a &=  1 : a \\\\\n\\Leftrightarrow & & a \\cdot a &=  1 \\\\\n\\Leftrightarrow & & a ^ 2 &=  1\n\\end{aligned}\n\\tag{10.16}\nDieses Ergebnis gilt nicht für alle möglichen Werte von a, sondern nur für den einen Fall a = 1. Damit kann die Lösung e_n = 1 nicht das neutrale Element der Division sein. Möglicherweise liefert die andere Teilgleichung ein besseres Ergebnis.\n\n\\begin{aligned}\n& & e_n : a &=  a \\\\\\\n\\Leftrightarrow & & \\frac{e_n}{a} &= a \\\\\n\\Leftrightarrow & & e_n &=  a\\cdot a \\\\\n\\Leftrightarrow & & e_n &=  a^2\n\\end{aligned}\n\\tag{10.17}\nAuch dieser Weg führt zu keinem Ergebnis für das neutrale Element, weil e_n ein Element des Definitionsbereich sein muss. In diesem Fall muss dieser Wert eine Zahl sein. Die Lösung e_n = a^2 liefert für unterschiedliche Werte für a verschiedene Werte für e_n kann deshalb auch keine Lösung für das neutrale Element sein.\nAus diesen Betrachtungen folgt, dass die Division kein neutrales Element hat, weil über beide Definitionen des neutralen Elements kein eindeutiges Ergebnis für die Division gefunden wurde.\n\n\n\n\n\n\nMerke\n\n\n\nNicht jede Operation hat ein neutrales Element.\n\n\n\n\n10.4.2 Redundanz\nFür das neutrale Element eines Operators ist die Operation mit der Identitätsfunktion funktional gleich.\n\nDefinition 10.14 Ergeben mehrere Teiloperationen immer das neutrale Element für die nächste Operation, dann sind diese Operationen redundant.\n\n\n\n\n\n\n\nMerke\n\n\n\nRedundante Operationen können aus einer Operation entfernt werden, ohne dass sich das Ergebnis ändert.\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nRedundante Operationen sollten in der Praxis möglichst immer vermieden werden, weil sie keinen Einfluss auf das Ergebnis haben, aber trotzdem Kapazitäten beanspruchen. Das verlangsamt den Arbeitsprozess unnötig. Leider sind redundante Operationen nicht immer als solche erkennbar."
  },
  {
    "objectID": "kapitel/06-variablen/kapitel.html#sec-funktionsketten",
    "href": "kapitel/06-variablen/kapitel.html#sec-funktionsketten",
    "title": "10  Variablen, Funktionen und Operatoren",
    "section": "10.5 Funktionsketten",
    "text": "10.5 Funktionsketten\nWenn das Ergebnis einer Funktion als Parameter einer beliebigen anderen Funktion verwendet wird, dann sind die beiden Funktionen verkettet. Mit verketteten Funktionen lassen sich komplexere Funktionen bilden. Umgekehrt lassen sich komplexe Funktionen in eine Verkettung einfacherer Teilfunktionen gliedern. Diese Technik heisst Problemzerlegung\n::: {#def-fkt-kette} Eine Funktionskette ist eine Abfolge von Funktionen, wobei eine nachfolgende Funktion das Ergebnis einer vorangehenden Funktion als Parameter akzeptiert.\nDie Funktionsverkettung dient dem Festlegen der Reihenfolge von Operationen. Das Prinzip der Funktionsverkettung ist einfach: Es wird das Ergebnis einer Funktion als Parameter einer anderen Funktion verwendet.\n\n\n\n\n\n\nHinweis\n\n\n\nIn der Literatur wird die Funktionsverkettung auch als Composting bezeichnet.\n\n\nDas folgende Beispiel nutz aus, dass die Operatoren der Grundrechenarten eigentlich Funktionen sind. Die Operation aus Formel 10.5 verwendet also die beiden Funktionen subtraktion() und potenz(). Formel 10.18 zeigt die Operation aus Formel 10.5 als verkettete Funktionen.\n\nf(a,b) \\to potenz(subtraktion(a,b),2)\n\\tag{10.18}\nBei dieser Funktionsdefinition fällt auf, dass die Funktionen die durch die Verkettung gebildete Funktion f zwei Parameter hat. Die beiden verketteten Funktionen subtraktion() und potenz() verwenden jedoch die drei Parameter a, b und 2. In diesem Fall ist der Wert 2 eine Konstante, die nur im Geltungsbereich der Funktion f verwendet wird.\nIm Gegensatz zu Operatoren ist die Ausführungsreihenfolge verketteter Funktionen eindeutig: Verkettete Funktionen werden immer von innen nach aussen ausgeführt. In Formel 10.18 wird die Funktion subtraktion() vor der Funktion potenz() ausgeführt.\nWerden Funktionsaufrufe als Parameter von anderen Funktionen geschrieben, dann sind diese Funktionen geschachtelt geschrieben. In geschachtelten Funktionsketten lässt sich die Reihenfolge der Funktionsaufrufe nicht immer leicht erkennen. Das ist immer dann der Fall, wenn viele Funktionen verkettet wurden. In solchen Fällen hilft die Darstellung der Funktionskette als Baum. Abbildung 10.1 zeigt den Funktionsbaum für Formel 10.18.\n\n\n\n\n\n\nHinweis\n\n\n\nEin Funktionsbaum ist eine Spezialform eines sog. Abstract Syntax Tree. (Knuth, 1968)\n\n\n\n\n\n\n\ngraph TB\n\np([potenz]) --- Basis --&gt; s([subtraktion])\np --- Exponent ----&gt; w((2))\n\ns --- Minuent --&gt; a((a))\ns --- Subtrahend --&gt; b((b))\n\n\nAbbildung 10.1: Funktionsbaum für Formel 10.18\n\n\n\n\nIn Abbildung 10.1 sind Funktionsnamen in den abgerundeten Feldern und Parameter in Rechtecken dargestellt. Werte und Variablen sind in Kreisen dargestellt. Ein Funktionsbaum wird von unten nach oben gelesen: Je weiter unten im Baum eine Funktion steht, desto früher wird sie ausgeführt. Die Funktionskette wird deutlich, indem man den Verbindungen zwischen den Funktionen folgt.\nUm die Ausführungsreihenfolge bereits in der Notation einer Funktionskette zu verdeutlichen, wird der allgemeine Verkettungsoperator (\\circ) verwendet. Dieser Operator ist ein spezieller Operator für Funktionen, der zwei Funktionen miteinander verkettet. Die mit diesem Operator verkettete Version von Formel 10.18 wird in Formel 10.19 gezeigt.\n\nf(a, b) \\to (potenz \\circ subtraktion)(a, b, 2)\n\\tag{10.19}\nIn dieser Schreibweise wird die Ausführungsreihenfolge von rechts nach links gelesen. Die Parameter werden von links nach rechts den Funktionen übergeben.\nDer allgemeine Verkettungsoperator findet sich regelmässig in Literatur über die Analyse von Algorithmen, um verkettete Funktionen anzuzeigen. In diesem Fall fehlen in der Regel die Parameter, wie in Formel 10.20.\n\nf \\to potenz \\circ subtraktion\n\\tag{10.20}\nAusgehend vom allgemeinen Vekettungsoperator hat sich in den Datenwissenschaften ein spezieller Verkettungsoperator (\\triangleright) für die Praxis als bedeutsam herausgestellt. Bei dieser Verkettung folgt die Ausführungsreihenfolge dem Fluss der Daten durch eine Funktionskette von links nach rechts. Dabei wird angenommen, dass das Ergebnis einer vorangehenden Funktion der erste Parameter der nachfolgenden Funktion ist. Bei den nachfolgenden Funktionen wird in dieser Notation der erste Parameter bei nachfolgenden Funktionen weggelassen. Ansonsten bleiben die Funktionsaufrufe unverändert. Formel 10.21 zeigt diese Schreibweise mit dem speziellen Verkettungsoperator für die Funktionskette aus Formel 10.18.\n\nf(a, b) \\to subtraktion(a, b) \\triangleright potenz(2)\n\\tag{10.21}\nDie Funktionsverkettung mit dem speziellen Verkettungsoperator zeigt in vielen Fällen die Logik einer komplexen Funktion besser als die geschachtelte Schreibweise. Die Parameterliste P einer verketteten Funktion wird so getrennt, dass der erste Parameter P_1 nicht mehr Teil der gekürzten Parameterliste P' ist, so dass Formel 10.22 gilt.\nFür diese Eigenschaft der geteilten Parameterliste für die spezielle Funktionsverkettung muss der Spezialfall berücksichtigt werden, dass die Parameterliste P leer ist. In diesem Fall kann diese Liste nicht geteilt werden, weil es keinen ersten Parameter P_1 gibt. Formel 10.22 gilt also nur, wenn die Parameterliste P nicht leer ist.\n\nP = P_1 \\cap P'; P \\neq \\varnothing\n\\tag{10.22}\nAus dieser Bedingung hat die Konsequenz, dass die spezielle Funktionsverkettung nur verwendet werden kann, wenn die nachfolgende Funktion mindestens einen Parameter hat.\n\n\n\n\n\n\nMerke\n\n\n\nDie spezielle Funktionsverkettung ist für parameterlose Funktionen undefiniert.\n\n\nWeil die verbleibende Parameterliste Teil der Operation ist, darf sie vom Operator nicht vernachlässigt werden. Der Operator muss also den ersten Parameter, die nachfolgende Funktion und die restlichen Parameter der nachfolgenden Funktion berücksichtigen. Daraus ergibt sich, dass der spezielle Funktionsverkettungsoperator kein binärer Operator ist. Die Funktion der speziellen Funktionsverkettung ist in Formel 10.23 definiert.\n\nP_1 \\triangleright f(P') \\Leftrightarrow \\triangleright(P_1, f, P') \\to f(P_1, P')\n\\tag{10.23}\nIn der Definition der speziellen Funktionsverkettung fehlt die vorangehende Funktion. Dieses Fehlen ergibt sich aus der Logik von Operatoren, weil höherwertige Teiloperationen vor niederwertigen Teiloperationen oder weiter links stehende Teiloperationen zuerst ausgeführt werden müssen. Der erste Parameter der nachfolgenden Funktion ist deshalb immer das Ergebnis einer vorangehenden Funktion. Diese Überlegung lässt sich weiter verallgemeinern:\n\n\n\n\n\n\nMerke\n\n\n\nJeder Wert oder Bezeichner im Wertebereich von P_1 kann als linker Operand der speziellen Funktionsverkettung verwendet werden.\n\n\n\n10.5.1 Anwendung von Funktionsketten\nFunktionsketten sind ein leistungsfähiges Werkzeug für die Problemzerlegung bei der Datenarbeit. Funktionen lassen sich jedoch nicht beliebig verketten.\n\n\n\n\n\n\nMerke\n\n\n\nFunktionen lassen sich nur verketten, wenn die Rückgabewerte der vorangehenden Funktion den gleichen Wertebereich haben, wie der entsprechende Parameter der nachfolgenden Funktion.\n\n\nWeil unter dieser Voraussetzung jede Funktion als Parameter einer anderen Funktion verkettet werden kann, lassen sich mit verketteten Funktionen beliebig komplexe Operationen bilden. Jede diese Operationen ist automatisch eine Funktion. Deshalb werden Funktionsketten in der Praxis häufig als zentraler Teil von Funktionen eingesetzt.\nMit diesem Wissen lassen sich die Eigenschaften von Funktionen in Funktionsketten untersuchen."
  },
  {
    "objectID": "kapitel/06-variablen/kapitel.html#sec-funktionen-als-werte",
    "href": "kapitel/06-variablen/kapitel.html#sec-funktionen-als-werte",
    "title": "10  Variablen, Funktionen und Operatoren",
    "section": "10.6 Funktionen als Werte",
    "text": "10.6 Funktionen als Werte\nBei der Substitution im Abschnitt 10.3.2 wurde eine Teiloperation einem Bezeichner zugewiesen, der anschliessend wie eine normale Variable behandlet wurde. Gleichzeitigt war dieser Bezeicher eine Funktion für die substituierte Teiloperation. Diese Überlegungen behandeln Funktionen genau gleich wie andere Datentypen.\nDer Datentyp Funktion gibt einen gültigen Wertebereich vor. Die Symbole dieses Wertebereichs sind jedoch nicht Zahlen oder Zeichenfolgen, sondern Funktionen. Der Bezeichner einer Funktion kann so durch Zuweisung geändert werden, ohne die Funktion anzuwenden.\nEine Funktion ohne Bezeichner wird eine anonyme Funktion genannt.\n\n\n\n\n\n\nExkurs\n\n\n\nIm Internet und (seltener) in der Literatur werden anonyme Funktionen auch als Lambda-Funktionen bezeichnet. Dieser Name ist dem sog. \\lambda-Kalkül (Church, 1940) aus der Berechenbarkeitstheorie entlehnt, weil das \\lambda-Kalkül keine Bezeichner und Operatoren benötigt. Deshalb können Operationen im \\lambda-Kalkül ausschliesslich durch anonyme Funktionen realisiert werden.\nEine Lambda-Funktion unterscheidet sich nicht von anderen Funktionen!\n\n\nDieser besondere Datentyp kann wie jeder andere Datentyp für Parameter und Ergebnisse von Funktionen verwendet werden.\n\n10.6.1 Callback-Funktionen\n\nDefinition 10.15 Eine Callback-Funktion ist eine Funktion, die als Parameter an eine andere Funktion übergeben wurde.\n\nBei der Übergabe einer Callback-Funktion wird die Funktion als Parameter übergeben. Das entspricht der Zuweisung einer Funktion an einen neuen Bezeichner. Dadurch muss die aufgerufene Funktion den Bezeichner der Callback-Funktion zum Zeitpunkt ihrer Definition nicht kennen, sondern kann über den Parameternamen auf diese Funktion zugreifen.\nBei der Verwendung von Callback-Funktionen muss klar zwischen dem Funktionsbezeicher und der Anwendung der Funktion unterschieden werden. Damit eine Funktion und nicht ihr Ergebnis als Parameter an eine andere Funktion übergeben werden kann, muss der Anwendungsoperator und die Parameterliste der Funktion weggelassen werden.\nIn Formel 10.24 wird der Funktion g das Ergebnis der Funktionsanwendung f(3) übergeben. Im Gegensatz dazu wird in Formel 10.25 die Funktion f selbst an die Funktion g übergeben. Die Funktion g kann nun die Funktion f aufrufen.\n\ng(f(3))\n\\tag{10.24}\n\ng(f)\n\\tag{10.25}\nCallback-Funktionen ermöglichen das Verallgemeinern von Algorithmen, indem der spezielle Teil einer Funktion durch eine Callback-Funktion festgelegt wird.\n\n\n10.6.2 Closure-Funktionen\n\nDefinition 10.16 Closure-Funktionen sind Funktionen, die als Rückgabewert von einer anderen Funktion erzeugt werden.\n\nEine Closure-Funktion wird im Geltungsbereich der erzeugenden Funktion definiert und übernimmt alle Bezeichner dieses Geltungsbereichs, so dass für eine komplexe Operation alle notwendigen Werte vorhanden sind.\nDas Beispiel in Formel 10.26 erzeugt die Funktion pDef Closure-Funktionen zum Potenzieren mit einem festen Exponenten.\n\npDef(exponent) \\to \\\\ (closure(basis) \\to potenz(basis, exponent))\n\\tag{10.26}\nDie Funktion pDef kann nun dazu verwendet werden, neue Funktionen zu erzeugen. Z.B. die Funktionen quadrat und kubik. Die Funktion quadrat hat den festen Exponenten 2 und die Funktion kubik den festen Exponenten 3. Diese Funktionsdefinitionen zeigt Formel 10.27.\n\n\\begin{aligned}\nquadrat &\\to pDef(2) \\\\\nkubik &\\to pDef(3)\n\\end{aligned}\n\\tag{10.27}\nDie beiden Bezeichner enthalten nun eigene Versionen der closure-Funktion.\nJede Anwendung von pDef erzeugt eine neue Funktion. Dabei ist der Bezeichner closure auf den Geltungsbereich von pDef beschränkt. Deshalb kann dieser nach dem Anwenden der Funktion pDef nicht direkt verwendet werden.\nDie erzeugten Funktionen lassen sich wie andere Funktionen über ihre Bezeichner anweden. Im aktuellen Beispiel ergeben sich so die Gleichungen in Formel 10.28.\n\n\\begin{aligned}\nquadrat(2) &= 4 \\\\\nquadrat(3) &= 9 \\\\\nkubik(2) &= 8 \\\\\nkubik(3) &= 27\n\\end{aligned}\n\\tag{10.28}\nClosure-Funktionen vereinfachen komplexe Funktionen, indem deren Parameter über die erzeugende Funktion festgelegt werden. Diese Technik wird in der Literatur gelegentlich als currying bezeichnet."
  },
  {
    "objectID": "kapitel/06-variablen/kapitel.html#besonderheiten-von-funktionsketten",
    "href": "kapitel/06-variablen/kapitel.html#besonderheiten-von-funktionsketten",
    "title": "10  Variablen, Funktionen und Operatoren",
    "section": "10.7 Besonderheiten von Funktionsketten",
    "text": "10.7 Besonderheiten von Funktionsketten\n\n10.7.1 Die Identitätsfunktion\nAls erstes soll die Verkettung einer beliebigen Projektion F mit der Identitätsfunktion f_{id} untersucht werden. Es ist wichtig, dass F eine Projektion ist, weil nur diese einer Eingabe immer den gleichen Ergebniswert zuweisen. Die Identitätsfunktion ist in Formel 10.4 definiert. Diese Funktion kann für jeden Wertebereich angepasst werden, so dass für jeden Wertebereich eine geeignete Identitätsfunktion für die Verkettung existiert. All diese Versionen der Identitätsfunktion werden unter f_{id} zusammenfasst und als die Identitätsfunktion bezeichnet.\nZuerst wird die Funktionsverkettung mit dem allgemeinen Verkettungsoperator betrachtet.\nWird die Identitätsfunktion mit einer beliebigen Funktion F nachfolgend verkettet, dann wird das Ergebnis dieser Funktion an die Identitätsfunktion als Parameter übergeben. Weil die Identitätsfunktion die übergebenen Parameter unverändert als Ergebnis zurückgibt, ist das Ergebnis der nachfolgenden Verknüpfung gleich dem Ergebnis der Funktion F. Es gilt also Formel 10.29.\n\nf_{id} \\circ F = F\n\\tag{10.29}\nIm vorangehenden Fall wird das Ergebnis der Identitätsfunktion an die Funktion F als Parameter übergeben. Weil F beliebig viele Parameter haben kann, werden ihre Parameter als eine Parameterliste behandelt. Diese Parameterliste wird der Identätsfunktion übergeben, weil der Wertebereich der Parameter und der Rückgabewerte der Identitätsfunktion identisch sind, kann die Identitätsfunktion immer mit einer Funktion verkettet werden, die diese Parameterliste akzeptiert. Weil die Parameter unverändert der Funktion F übergeben werden und F eine Projektion ist, ist das Ergebnis dieser Funktionskette identisch mit dem Ergebnis von F. Es gilt also Formel 10.30.\n\nF \\circ f_{id} = F\n\\tag{10.30}\nAus Formel 10.29 und Formel 10.30 ergibt sich Formel 10.31.\n\nf_{id} \\circ F = F \\circ f_{id} = F\n\\tag{10.31}\nDiese Beziehung erfüllt die Kriterien für das neutrale Element aus Formel 10.12 für den allgemeinenen Verkettungsoperator.\nFür die spezielle Funktionsverkettung vereinfachen sich diese überlegungen, weil nur der erste Parameter P_1 und nicht die ganze Parameterliste P betrachtet werden muss. Wie oben beschrieben, darf die restliche Parameterliste der Funktion F nicht vernachlässigt werden.\nFür den Fall, dass die Identitätsfunktion die vorangehende Funktion ist, gilt Formel 10.32. Die Identitätsfunktion betrifft also nur den ersten Parameter von F. Wegen der Definition der Identitätsfunktion gilt die Gleichung f_{id}(P_1) = P_1.\n\nf_{id}(P_1) \\triangleright F(P') = P_1 \\triangleright F(P') = F(P)\n\\tag{10.32}\nEntsprechend dieser Logik kann auch Ergebnis der vorangehenden Funktion als ein einzelner Wert behandelt werden. Das ist für den zweiten Fall wichtig, wenn die Identitätsfunktion die nachfolgende Funktion ist. In diesem Fall wird die Identitätsfunktion auf das Ergebnis angewandt, so dass die Gleichung f_{id}(E) = E gilt. Weil die Identitätsfunktion keine weiteren Parameter akzeptiert, entfällt die Behandlung von P'. Daraus ergibt sich die Gleichung 10.33.\n\nF(P) \\triangleright f_{id}() = E = F(P)\n\\tag{10.33}\nWerden die beiden Fälle zusammengefasst, dann ergibt sich die Gleichung 10.34.\n\nF(P) \\triangleright f_{id}() = f_{id}(P_1) \\triangleright F(P') = F(P)\n\\tag{10.34}\nDie Identitätsfunktion ist also auch das neutrale Element der speziellen Funktionsverkettung.\n\n\n\n\n\n\nMerke\n\n\n\nDie Identitätsfunktion ist das neutrale Element der allgemeinen und speziellen Funktionsverkettungsoperators.\n\n\n\n\n10.7.2 Verkettung mit Umkehrfunktionen\nIn Abschnitt 10.2.1 wurden Projektionen definiert und festgehalten, dass einige Projektionen eine Umkehrfunktion haben.\nExistiert für eine beliebige Projektion F eine Umkehrfunktion F^{-1}, dann kann die Verkettung zwischen der Funktion und der Umkehrfunktion untersucht werden. Die Umkehrfunktion einer Funktion akzeptiert die Rückgabewerte der Funktion als Parameter und hat als Rückgabewert die Parameter der ursprünglichen Funktion. Die Parameter von F^{-1} und die Rückgabewerte von F haben gemäss dieser Definition den gleichen Wertebereich. Das Gleiche gilt für die Rückgabewerte von F^{-1} und die Parameter von F. Damit ist für beide Richtungen die Voraussetzung für die Verkettung erfüllt. Es sind also sowohl die Verkettung F^{-1} \\circ F als auch F \\circ F^{-1} für alle umkehrbaren Funktionen zulässig.\nWerden nun die beiden Funktion F und F^{-1} als F \\circ F^{-1} verkettet, dann werden die Parameter von F^{-1} auf die Rückgabewerte projiziert. Dieser werden anschliessend als Parameter der F als Paramter übergeben und wieder projiziert. Weil das Ergebnis einer umkehrbaren Funktion identisch mit den Parametern ihrer Umkehrfunktion ist, muss das Ergebnis dieser Funktionskette den eingegebenen Parametern entsprechen.\nWird die Verkettung zu F^{-1} \\circ F umgekehrt, dann muss das Ergebnis dieser Funktionskette aus den gleichen Gründen wie oben, mit den Parametern von F gleich sein.\nFunktionen mit der Eigenschaft, dass Ergebnis und Parameter gleich sind, sind mit der Identitätsfunktion funktional gleich. Es gilt also Formel 10.35.\n\nF^{-1} \\circ F = F \\circ F^{-1} =  f_{id}\n\\tag{10.35}\n\n\n\n\n\n\nMerke\n\n\n\nWird eine umkehrbare Projektion mit ihrer Umkehrfunktion verkettet, dann ist diese verkettete Funktion mit der Identitätsfunktion funktional gleich.\n\n\nNun ist f_{id} auch das neutrale Element der Funktionsverkettung. Deshalb gilt zusätzlich, dass jede Verkettung einer umkehrbaren Projektion mit ihrer Umkehrfunktion redundant ist. Diese Überlegung lässt sich weiter verallgemeinern:\n\n\n\n\n\n\nMerke\n\n\n\nJede (Teil-)Funktionskette, die mit der Identitätsfunktion funktional gleich ist, ist redundant und kann weggelassen werden.\n\n\n\n\n\n\nChurch, A. (1940). A formulation of the simple theory of types. Journal of Symbolic Logic, 5(2), 56–68. https://doi.org/10.2307/2266170\n\n\nKnuth, D. E. (1968). Semantics of context-free languages. Mathematical Systems Theory, 2(2), 127–145. https://doi.org/10.1007/BF01692511\n\n\nPython Software Foundation. (2013, Juli 6). Bitwise Operators. https://wiki.python.org/moin/BitwiseOperators"
  },
  {
    "objectID": "kapitel/05-zeichenketten/kapitel.html#nicht-druckbare-zeichen",
    "href": "kapitel/05-zeichenketten/kapitel.html#nicht-druckbare-zeichen",
    "title": "11  Zeichenketten",
    "section": "11.1 Nicht-druckbare Zeichen",
    "text": "11.1 Nicht-druckbare Zeichen\n\nDefinition 11.3 Nicht-druckbare Zeichen sind Symbole, die bei der Darstellung einer Zeichenkette nicht angezeigt werden können. Die nicht-druckbaren Zeichen zählen zur Länge einer Zeichenkette und verändern den Inhalt einer Zeichenkette.\n\nBeispiel: Die Zeichenkette Hallo unterscheidet sich von der Zeichenkette Hal&lt;0x08&gt;lo.\nZu den nicht-druckbaren Zeichen gehören auch Leerzeichen, Tabulatoren und Zeilenumbrüche. Diese speziellen nicht-druckbaren Zeichen sind nur dann zu erkennen, wenn sie von druckbaren Zeichen umgeben sind.\n\n\nBeispiel 11.1 Deutlich wird das an den folgenden Zeichenketten:\n\nHallo\nHal&lt;0x07&gt;lo, wobei das Symbol 0x07 für einen Piepton steht\nHal&lt;0x08&gt;lo, wobei das Symbol 0x08 für einmal Rückwärtslöschen steht.\n\nDie erste Zeichenkette hat die Länge 5, die zweite Zeichenkette hat die Länge 6 und die dritte Zeichenkette hat ebenfalls die Länge 6."
  },
  {
    "objectID": "kapitel/05-zeichenketten/kapitel.html#die-leere-zeichenkette",
    "href": "kapitel/05-zeichenketten/kapitel.html#die-leere-zeichenkette",
    "title": "11  Zeichenketten",
    "section": "11.2 Die leere Zeichenkette",
    "text": "11.2 Die leere Zeichenkette\n\nDefinition 11.4 Eine Zeichenkette der Länge 0 enthält keine Symbole. Diese Zeichenkette heisst die leere Zeichenkette.\n\nIn einigen Umgebungen lässt sich die leere Zeichenkette nicht leicht von Zeichenketten unterscheiden, die aus nicht-druckbaren Zeichen bestehen. Für viele Funktionen ist die leere Zeichenkette problematisch oder als Wert nicht zulässig. In solchen Fällen muss die leere Zeichenkette über die Länge einer Zeichenketten-Variablen explizit kontrolliert werden."
  },
  {
    "objectID": "kapitel/05-zeichenketten/kapitel.html#symbolvektoren",
    "href": "kapitel/05-zeichenketten/kapitel.html#symbolvektoren",
    "title": "11  Zeichenketten",
    "section": "11.3 Symbolvektoren",
    "text": "11.3 Symbolvektoren\nIn einer Zeichenkette sind die Symbole angeordnet, so dass jedes Symbol über dessen Position angesprochen werden kann.\nWird eine Zeichenkette in die einzelnen Symbole gegliedert, dann ergibt sich in den meisten modernen Programmiersprachen ein Zeichenkettenvektor mit Zeichenketten der Länge 1."
  },
  {
    "objectID": "kapitel/05-zeichenketten/kapitel.html#texttrennung",
    "href": "kapitel/05-zeichenketten/kapitel.html#texttrennung",
    "title": "11  Zeichenketten",
    "section": "11.4 Texttrennung",
    "text": "11.4 Texttrennung\nDamit Zeichenketten getrennt werden können wird eine spezielle Funktion benötigt. Diese Funktion wird als Texttrennung (engl. split) bezeichnet. Die Funktion hat zwei Parameter: Die Zeichenkette und ein Trennsymbol. Das Trennsymbol ist eine Zeichenkette, die zwei Teile einer Zeichenkette trennt. Beispiele für solche Trennsymbole wurden im Kapitel 9 vorgestellt.\nDie Texttrennung teilt eine Zeichenkette so auf, dass für alle Vorkommnisse des Trennsymbols in der Zeichenkette der Teil vor dem Trennsymbol und der Teil nach dem Trennsymbol als zwei separate Zeichenketten vorliegen. Das Trennsymbol wird entfernt. Das Ergebnis der Texttrennung ist ein Zeichenkettenvektor mit den getrennten Zeichenketten.\n\n\n\n\n\n\nMerke\n\n\n\nDie Länge des Vektors nach der Texttrennung entspricht der Anzahl der Vorkommnisse des Trennsymbols in der Zeichenkette plus 1.\n\n\n\nDefinition 11.5 Die durch die Texttrennung entstehenden Zeichenketten heissen Token.\n\nToken können Sätze, Worte oder auch einzelne Buchstaben sein. Ein Token muss nicht zwingend sprachlich sinnvoll sein.\n\nDefinition 11.6 Ein Vektor der Tokens enthält heisst Token-Vektor.\n\nDie Texttrennung hat also einen Token-Vektor als Ergebnis.\nUm die einzelnen Symbole einer Zeichenkette zu erhalten, muss etwas um die Ecke gedacht werden, um die Zeichenkette zu erkennen, die zwischen jedem Symbol steht: Der Abstand zwischen zwei Symbolen in einer Zeichenkette ist immer genau 1. Weil Zeichenketten diskrete Daten sind, muss die Zeichenkette zwischen zwei Symbolen eine Länge von 0 haben. Die Zeichenkette mit der Länge 0 ist nach Definition 11.4 die leere Zeichenkette.\nEntsprechend enthält der Token-Vektor nach der Texttrennung mit der leeren Zeichenkette den einzelnen Symbolen der ursprünglichen Zeichenkette."
  },
  {
    "objectID": "kapitel/05-zeichenketten/kapitel.html#textverkettung",
    "href": "kapitel/05-zeichenketten/kapitel.html#textverkettung",
    "title": "11  Zeichenketten",
    "section": "11.5 Textverkettung",
    "text": "11.5 Textverkettung\nDie Texttrennung ist umkehrbar. Die Umkehrfunktion der Texttrennung ist die Textverkettung. Die Textverkettung fügt mehrere Zeichenketten zu einer neuen Zeichenkette zusammen.\nDie Textverkettung ist eine spezielle From der Konkatenation von Vektoren (s. Kapite 13.2).\nDie Textverkettung hat zwei Parameter:\n\nEinen Token-Vektor\nEin Trennsymbol\n\nDie Textverkettung fügt alle Zeichenketten des Token-Vektors zusammen, indem die erst das vorangehende Token, dann das Trennsymbol und zuletzt die nachfolgende Zeichenkette zusammengefügt werden. Das Ergebnis ist eine neue Zeichenkette.\nWird der Token-Vektor einer Texttrennung mit dem gleichen Trennsymbol wieder verkettet, dann ist das Ergebnis die ursprüngliche Zeichenkette.\nDie leere Zeichenkette ist das neutrale Element der Textverkettung."
  },
  {
    "objectID": "kapitel/05-zeichenketten/kapitel.html#normalisierung",
    "href": "kapitel/05-zeichenketten/kapitel.html#normalisierung",
    "title": "11  Zeichenketten",
    "section": "11.6 Normalisierung",
    "text": "11.6 Normalisierung\n\nDefinition 11.7 Das Entfernen und Vereinheitlichen von Leerzeichen und nicht-druckbaren Zeichen aus einer Zeichenkette heisst Normalisieren von Zeichenketten.\n\nEine normalisierte Zeichenkette enthält keine führenden oder nachfolgenden Leerzeichen, keine nicht-druckbaren Zeichen und keine aufeinanderfolgenden Leerzeichen.\nDie Operation des Normalisieren ist das Suchen und Ersetzen. Beim Suchen und Ersetzen werden Zeichenketten durch andere Zeichenketten ersetzt. Die Basis-Funktion des Suchens und Ersetzens hat drei Parameter:\n\nDie Zeichenkette, in der gesucht werden soll\nDie gesuchte Zeichenkette (das Suchmuster)\nDie Ersetzungszeichenkette\n\nDie Funktion sucht in der Zeichenkette nach dem Suchmuster und ersetzt das Suchmuster durch die Ersetzungszeichenkette. Das Ergebnis ist eine neue Zeichenkette, in der das Suchmuster durch die Ersetzungszeichenkette ersetzt wurde.\nWird als Ersetzung die leere Zeichenkette verwendet, dann wird das Suchmuster aus der Zeichenkette entfernt.\nWenn das Ergebnis einer Suchen-und-Ersetzen-Funktion die ursprüngliche Zeichenkette ist, wurde keine Ersetzung durchgeführt.\nBeim Normalisieren von Zeichenketten werden Suchen-und-Ersetzen-Funktionen solange angewendet, bis keine Ersetzung mehr vorgenommen wird. Die Zeichenkette ist dann normaliesiert.\nWeil das Normalisieren von Zeichenketten eine sehr häufige Operation ist, gibt es dafür spezielle Funktionen. Die wichtigsten dieser Funktionen sind:\n\nDie Bereinigung von Leerzeichen am Anfang und Ende einer Zeichenkette (engl. trim)\nDie Bereinigung von aufeinanderfolgenden Leerzeichen.\n\n\n\n\n\n\n\nPraxis\n\n\n\nOft müssen Zeichenketten auch von anderen Symbolen bereinigt werden. Dabei handelt es sich um Erweiterungen des Normalisierens."
  },
  {
    "objectID": "kapitel/05-zeichenketten/kapitel.html#gross--und-kleinschreibung",
    "href": "kapitel/05-zeichenketten/kapitel.html#gross--und-kleinschreibung",
    "title": "11  Zeichenketten",
    "section": "11.7 Gross- und Kleinschreibung",
    "text": "11.7 Gross- und Kleinschreibung\nZeichenketten können in der Gross- oder Kleinschreibung variieren. Die Gross- und Kleinschreibung ist ein semantisches Merkmal von Zeichenketten, kann aber auch auf Tippfehler zurückgehen. Um Varianten der Gross- und Kleinschreibung zu ignorieren, werden alle Symbole einer Zeichenkette in Gross- oder in Kleinbuchstaben umgewandelt, falls es sich um Buchstaben handelt. Alle anderen Symbole bleiben unverändert.\nDie Umwandlung von Gross- in Kleinbuchstaben ist leicht umzusetzen, weil Kleinbuchstaben in der Zeichenkodierung immer um den gleichen Wert (0x20)grösser sind als Grossbuchstaben. Die Umwandlung wird in der Regel mit einer entsprechenden Funktion durchgeführt und muss nicht selbst implementiert werden.\nSatzzeichen, Zahlen und viele Schriften verfügen über keine grossen und kleinen Buchstaben. Die entsprechen Symbole werden nicht umgewandelt."
  },
  {
    "objectID": "kapitel/08-boolsche-operationen/kapitel.html#mathematische-operationalisierung-der-aussagenlogik",
    "href": "kapitel/08-boolsche-operationen/kapitel.html#mathematische-operationalisierung-der-aussagenlogik",
    "title": "12  Boole’sche Operationen",
    "section": "12.1 Mathematische Operationalisierung der Aussagenlogik",
    "text": "12.1 Mathematische Operationalisierung der Aussagenlogik\nGeorge Boole hat mit seiner Arbeit “The Mathematical Analysis of Logic” (Boole, 1847) die Grundlagen für die moderne Informatik gelegt. Er hat die Grundlagen für die Boole’sche Algebra gelegt, die die Grundlage sowohl für die moderne Kommunikationstechnologie als auch für die Informatik ist. Seine Überlegungen standen im Kontext der industriellen Revolution und der damit verbundenen Entwicklung von Maschinen, die mit Hilfe von mathematischen Gleichungen gesteuert werden. Er erkannte, dass die Sprache und damit die Philosophie der Logik genau wie die Mathematik auf Grundlage von Symbolen basierte. Er fragte sich, ob Sprache und Logik einer mathematischen Analyse unterzogen werden können. Speziell interessierte ihn für seine Analyse der Zweig des Syllogismus in der Logik, der sich mit dem deduktiven Schlussfolgern aus Argumenten beschäftigt.\nBoole wurde durch die Arbeiten von Leibniz beeinflusst, die sich mit der Formalisierung von Argumenten beschäftigten. Leibniz hatte die Idee, dass Argumente in Form von mathematischen Gleichungen dargestellt werden können. Boole hat diese Idee aufgegriffen und weiterentwickelt.\nBoole versuchte, die klassische Aussagenlogik mathematisch zu formalisieren, indem er jeder Aussage einen Wahrheitswert in Form von 0 für falsch und 1 für wahr zuordnete. Auf dieser Grundlage untersuchte er, welche mathematischen Operationen zu den bekannten Ergebnissen der klassischen Aussagenlogik führen.\nAusgehend von den Beziehungsarten der klassischen Aussagenlogik stellte er die Belegungen für die möglichen Kombinationen von Wahrheitswerten in der jeweiligen Beziehung auf. D.h. er stellte die möglichen Kombinationen von Wahrheitswerten der Prämissen den Wahrheitswerten der Konklusion gegenüber. Für jede dieser Belegungen suchte Boole anschliessend nach einer arithmetischen Operation, die alle Belegungen einer Beziheung erzeugt.\n\n12.1.1 Belegungstafeln oder Wahrheitstafeln\nEine Wahrheitstafel oder Wahrheitstabelle ist eine Tabelle, die alle möglichen Kombinationen von Wahrheitswerten für einen logischen Ausdruck enthält. Weil die klassische Aussagenlogik nur zwei Wahrheitswerte kennt, müssen nur alle Kombinationen dieser beiden Werte für einen logischen Ausdruck gefunden werden.\nDie Wahrheitstafel für die Negation NICHT sieht wie folgt aus:\n\n\n\na\nNICHT a\n\n\n\n\n0\n1\n\n\n1\n0\n\n\n\nDie in den Wahrheitstafeln aufgeführten Ergebniswerte werden auch als Belegungen bezeichnet. Für die logischen Basisoperationen werden diese Belegungen als Grundbelegung bezeichnet.\nDie Grundbelegungen sind die Basis für die Boole’sche Algebra und Arithmetik.\nDie Wahrheitstafel für die Konjunktion UND sieht wie folgt aus:\n\n\n\na\nb\na UND b\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\nFür Wahrheitstafeln ist auch die Matrix-Schreibweise üblich. Dabei werden die Wahrheitswerte als Spaltenvektoren geschrieben. Die Wahrheitstafel für die Konjunktion UND sieht wie folgt aus:\n\n\n\n\\downarrow b | a \\to\n0\n1\n\n\n\n\n0\n0\n0\n\n\n1\n0\n1\n\n\n\nVerkürzt werden die Spalten und Zeilenüberschriften weggelassen und können die Belegung als Matrix schreiben:\n\n\\begin{matrix}\n0 & 0 \\\\\n0 & 1\n\\end{matrix}\n\nDie Wahrheitstafel für die Disjunktion ODER sieht wie folgt aus:\n\n\n\na\nb\na ODER b\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n1\n\n\n\nOder in der Matrix-Schreibweise:\n\n\\begin{matrix}\n0 & 1 \\\\\n1 & 1\n\\end{matrix}\n\nDie Wahrheitstafel für die Exklusiv-Oder XODER sieht wie folgt aus:\n\n\n\na\nb\na XODER b\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\nDie entsprechende Belegung sieht als Matrix wie folgt aus:\n\n\\begin{matrix}\n0 & 1 \\\\\n1 & 0\n\\end{matrix}\n\n\n\n12.1.2 Boole’sche Arithmetik\nObwohl die Arbeit von Geoge Boole wegweisend für die Logik als mathematische Disziplin war, konzentrierte sich seine Arbeit auf der Übersetzung von logischen Aussagen in arithmetische Ausdrücke. Die Boole’sche Arithmetik ist eine Erweiterung der Arithmetik. Dabei werden logische Ausdrücke mithilfe der Grundrechenarten in berechenbare Ausdrücke übersetzt.\nDie Boole’schen Arithmetik im engeren Sinn basiert auf der Übersetzung von Wahrheitswerten in Zahlen. Dabei wird WAHR als 1 und FALSCH als 0.\n\n\n\nLogische Operation\nArithmetische Operation\n\n\n\n\nNICHT\n1 - a\n\n\nUND\na \\cdot b\n\n\nODER\na + b - ab\n\n\nEntweder-Oder (XODER)\na + b - 2ab oder (a-b)^2\n\n\n\nWeil Wahrheitswerte immer 0 oder 1 sein müssen, stellen diese Operationen sicher, dass die Ergebnisse logischer Ausdrücke ebenfalls immer 0 oder 1 sind. Das ist vor allem für die beiden Oder-Operationen wichtig, weil die arithmetische Addition einen Wert ausserhalb der erlaubten Werte liefert, wenn beide Operanden Wahr bzw. 1 sind.\nBoole konnte zeigen, dass die arithmetischen Operationen die gleichen Ergebnisse liefern wie die logischen Operationen der klassischen Aussagenlogik. Ausgehend von den Wahrheitstafeln zeigte Boole auch, dass die Begrenzung aus Wahrheitswerte 0 und 1 bei Additionen eine Ausgleichsoperation erfordert, damit das Ergebnis in den gleichen Wertebereich fällt."
  },
  {
    "objectID": "kapitel/08-boolsche-operationen/kapitel.html#boolesche-algebra",
    "href": "kapitel/08-boolsche-operationen/kapitel.html#boolesche-algebra",
    "title": "12  Boole’sche Operationen",
    "section": "12.2 Boole’sche Algebra",
    "text": "12.2 Boole’sche Algebra\nDie Bool’sche Arithmetik ist für regelmässige Aufgaben etwas unhantlich, weil die beiden Operationen ODER und Entweder-Oder sich nicht mit einer arithmetischen Operation ausdrücken lassen. Weil die logischen Operationen einen besonderen Fall der Mengenlehre darstellen, wurden die Symbole für die Konjunktion und Disjunktion der Symbolik der Mengenlehre entlehnt.\n\n\n\n\n\n\n\n\n\nLogische Operation\nlogischer Operator\nMengenoperator\nMengenoperation\n\n\n\n\nNegation\n\\neg\n\\notin\nNegation\n\n\nKonjunktion (UND)\n\\land\n\\cap\nSchnittmenge\n\n\nDisjunktion (ODER)\n\\lor\n\\cup\nVereinigung\n\n\nAntivalenz (XODER)\n\\oplus\n\\triangle\nSymmetrische Differenz\n\n\n\nDie Antivalenz kann durch die anderen drei Operationen ausgedrückt werden, weshalb sie seltener in logischen Ausdrücken verwendet wird.\n\n12.2.1 Grundregeln der Boole’schen Algebra\nGrundsätzlich gelten für die Boole’sche Algebra die gleichen Regeln wie für die Arithmetik. D.h. zuerst wird die Negation berechnet, dann UND abschliessend ODER. Diese Reihenfolge ist damit begründet, dass die UND-Operation der Multiplikation und die ODER-Operation der Addition entsprecht. Um die Reihenfolge zu ändern, werden wie üblich Klammern verwendet.\nLogische Ausdrücke werden schnell komplex und unübersichtlich. Die Boole’sche Algebra definiert Regeln, die die Umformung von logischen Ausdrücken vereinfachen. Die wichtigsten Regeln sind in der folgenden Tabelle aufgelistet.\n\n\n\nName\nGleichung\n\n\n\n\nIdempotenzgesetz\na \\land a = a\n\n\n\na \\lor a = a\n\n\nTautologie\na \\lor \\neg a = 1\n\n\nKontradiktion\na \\land \\neg a = 0\n\n\nKommutativgesetz\na \\land b = b \\land a\n\n\n\na \\lor b =b \\lor a\n\n\nAssoziativgesetz\n(a \\land b) \\land c = a \\land (b \\land c)\n\n\n\n(a \\lor b) \\lor c = a \\lor (b \\lor c)\n\n\nDistributivgesetz\na \\land (b \\lor c) = a \\land b \\lor a \\land c\n\n\n\na \\lor b \\land c = (a \\lor b) \\land (a \\lor c)\n\n\nAbsorptionsgesetz\na \\land (a \\lor b) = a\n\n\n\na \\lor a \\land b = a\n\n\nDe Morgan’sche Regeln\n\\neg (a \\land b) = \\neg a \\lor \\neg b\n\n\n\n\\neg (a \\lor b) = \\neg a \\land \\neg b\n\n\n\nViele Programmiersprachen werten logische Ausdrücke von links nach rechts aus und brechen die Auswertung ab, sobald das Ergebnis feststeht. Das ist bei der Boole’schen Algebra eigentlich nicht möglich, weil die Reihenfolge der Auswertung nicht festgelegt ist. Um die Auswertung logischer Ausdrücke in Programmiersprachen zu unterstützen, sollten die Teilaussagen in ihrer Wichtigkeit und Komplexität absteigend angeordnet werden.\n\n\n\n\n\n\nPraxis\n\n\n\nLogische Ausdrücke haben in der Programmierpraxis eine grosse Bedeutung. Aus diesem Grund verfügen alle Programmiersprachen die Möglichkeit, beliebige Zahlen als Wahrheitswerte zu behandeln. Dabei gilt die Konvention, dass die Zahl 0 als FALSCH und alle anderen Zahlen als WAHR interpretiert werden."
  },
  {
    "objectID": "kapitel/08-boolsche-operationen/kapitel.html#vergleiche",
    "href": "kapitel/08-boolsche-operationen/kapitel.html#vergleiche",
    "title": "12  Boole’sche Operationen",
    "section": "12.3 Vergleiche",
    "text": "12.3 Vergleiche\nDie Vergleichsoperatoren sind in der Programmierung sehr wichtig, weil sie die Grundlage für die Kontrollstrukturen bilden.\n\nDefinition 12.1 Vergleichsoperatoren sind binäre Operatoren, die zwei Operanden miteinander vergleichen. Das Ergebnis ist immer ein Wahrheitswert.\n\nDer zentrale Vergleich ist die Gleichheit (=). Die Gleichheit ist gegeben, wenn beide Operanden des Vergleichs gleich sind. In diesem Fall gibt dieser Vergleich WAHR zurück.\nFür Zahlenwerte und andere sortierbare Werte sind die Vergleiche kleiner als (&lt;) und grösser als (&gt;) definiert. Dabei wird der Vergleich WAHR zurückgegeben, wenn der linke Operand kleiner bzw. grösser als der rechte Operand ist.\nZusätzlich sind die kombinierten Vergleiche wichtig:\n\n\n\nOperation\nSymbol\nAlternative Schreibweise\n\n\n\n\nungleich\na \\neq b\n\\neg(a = b)\n\n\nkleiner oder gleich\na \\leq b\n(a &lt; b) \\lor (a = b)\n\n\ngrösser oder gleich\na \\geq b\n(a &gt; b) \\lor (a = b)\n\n\n\nBei Vergleichsoperatoren muss darauf geachtet werden, dass die Operanden vom gleichen Typ sind. Eine Zahl kann nicht mit einer Zeichenkette verglichen werden.\nFür logische Ausdrücke sind direkte Vergleiche zwischen zwei Werten nicht immer geeignet. Immer wenn der gleiche Wert mit mehreren anderen verglichen werden muss werden logische Ausdrücke mit direkten Vergleichen schnell komplex. Für solche Vergleiche ist der Existenz-Vergleich wichtig. Dabei wird der Wert WAHR zurückgegeben, wenn der linke Operand ein Element des rechten Operanden ist.\nDie Existenz wird mithilfe des \\in-Operators überprüft. Der \\in-Operator ist ein spezieller Vergleichsoperator, der Wahr zurückgibt, wenn der linke Operand im rechten Operand vorkommt. Dabei steht der linke Operand für den Suchwert und der rechte Operand für den Suchbereich. Der Suchbereich ist dabei immer eine Menge bzw. ein Vektor. Der Vergleich der beiden Operanden wird formal als a \\in B geschrieben, wobei B eine Menge bzw. ein Vektor von Werten ist. Dieser Vergleich entspricht einer ODER-Operation, mit der die Elemente des Vektors B einzeln mit dem Wert a auf Gleichheit geprüft werden, wie Formel 12.1 zeigt.\n\n\\begin{aligned}\n& a \\in \\{ 1, 2, 3, 4, 5 \\} \\\\\n\\Leftrightarrow & (a = 1) \\lor (a = 2) \\lor (a = 3) \\lor (a = 4) \\lor (a = 5)\n\\end{aligned}\n\\tag{12.1}\nIn vielen Fällen sind die zu prüfenden Elemente in B nicht vorab bekannt oder die Anzahl der Elemente variiert. In diesem Fall ist eine explizite ODER-Operation nicht möglich. Auch in weniger komplexen Fällen, empfielt es sich, die ODER-Operation zu vermeiden und die Existenzprüfung vorzuziehen, weil sie die Lesbarkeit eines logischen Ausdrucks erhöht.\nFormel 12.2 zeigt die Anwendung des \\in-Operators.\n\n    7 \\in \\{ 1; 2; 3; 4; 5; 6; 7; 8; 9; 10 \\}\n\\tag{12.2}\nDieser Ausdruck ist in diesem Beispiel Wahr.\nDer \\in-Operator kann für Vektoren als linker Operator verallgemeinert werden. In diesem Fall werden die linken Operanden ebenfalls als Vektor dargestellt. Nun wird für jeden Wert des linken Operators der Vergleich mit der rechten Seite durchgeführt.\n\n    \\{ 7; 11 \\} \\in \\{ 1; 2; 3; 4; 5; 6; 7; 8; 9; 10 \\}\n\\tag{12.3}\nDer Vergleich in Formel 12.3 entspricht also den beiden separaten Vergleichen in Formel 12.4.\n\n\\begin{aligned}\n    7 &\\in \\{ 1; 2; 3; 4; 5; 6; 7; 8; 9; 10 \\} \\\\\n    11 &\\in \\{ 1; 2; 3; 4; 5; 6; 7; 8; 9; 10 \\}\n\\end{aligned}\n\\tag{12.4}\nIm Beispiel von Formel 12.3 ist das Ergebnis des Vergleichs: {WAHR; FALSCH}."
  },
  {
    "objectID": "kapitel/08-boolsche-operationen/kapitel.html#entscheidungen",
    "href": "kapitel/08-boolsche-operationen/kapitel.html#entscheidungen",
    "title": "12  Boole’sche Operationen",
    "section": "12.4 Entscheidungen",
    "text": "12.4 Entscheidungen\n\nDefinition 12.2 Eine Entscheidung beschreibt eine Funktion, die mit Hilfe eines logischen Ausdrucks aus eines von zwei alternativen Ergebnissen auswählt.\n\nBei Entscheidungen werden in der Regel die beiden Fälle des logischen Ausdrucks unterschieden. Dabei wird der Fall, der WAHR ergibt als positiver Fall und der Fall, der FALSCH ergibt als negativer Fall bezeichnet.\nEntscheidungen können nacheinander ausgeführt werden. Dabei führen die beiden Fälle der ersten Entscheidung in jeweils eine weitere Entscheidung. Solche verschachtelten Entscheidungen werden als Entscheidungsbäume bezeichnet.\n\nDefinition 12.3 Eine Verkettung von Entscheidungen wird als Entscheidungsbaum bezeichnet.\n\nDie logischen Ausdrücke eines Entscheidungsbaums sind grundsätzlich unabhängig voneinander. Die einzige Beziehung zwischen den logischen Ausdrücken ist die Reihenfolge, in der sie geprüft werden. Abbildung 12.1 zeigt das Schema eines einfachen Entscheidungsbaum mit zwei aufeinanderfolgenden Entscheidungen.\n\n\n\n\n\ngraph TB\n  a([erster logischer Ausdruck]) ---&gt;|Wahr| b\n  a ---&gt;|Falsch| c\n  b([zweiter logischer Ausdruck]) ---&gt;|Wahr| d([Ergebnis Wahr-Wahr])\n  b ---&gt;|Falsch| e([Ergebnis Wahr-Falsch])\n  c([dritter logischer Ausdruck]) ---&gt;|Wahr| f([Ergebnis Falsch-Wahr])\n  c ---&gt;|Falsch| g([Ergebnis Falsch-Falsch])\n\n\nAbbildung 12.1: Schema eines Entscheidungsbaums mit zwei Entscheidungen\n\n\n\n\nEin oft vorkommender Speziallfall von Entscheidungsbäumen sind verschachtelte Entscheidungen, die so arrangiert sind, dass jeder logische Ausdruck genau ein Ergebnis auswählt.\n\nDefinition 12.4 Ein Entscheidungsbaum, der für einen logischen Ausdruck mindestens ein Ergebnis und höchstens einen nachfolgende Entscheidung, heisst linearer Entscheidungsbaum.\n\nLineare Entscheidungsbäume können das Ergebnis sowohl für den Wahr oder den Falsch-Fall festlegen. Per Konvention werden die logischen Ausdrücke linearer Entscheidungsbäume so formuliert, dass die Ergebnisse immer für den Fall Wahr und die nachfolgende Entscheidung immer für den Fall Falsch folgen. Abbildung 12.2 zeigt das Schema eines linearen Entscheidungsbaums mit zwei Entscheidungen.\n\n\n\n\n\ngraph TB\n  a([erster logischer Ausdruck]) ---&gt;|Wahr| b([Ergebnis Wahr])\n  a ---&gt;|Falsch| c\n  c([zweiter logischer Ausdruck]) ---&gt;|Wahr| f([Ergebnis Falsch-Wahr])\n  c ---&gt;|Falsch| g([Ergebnis Falsch-Falsch])\n  \n\n\nAbbildung 12.2: Schema eines linearen Entscheidungsbaum mit zwei Entscheidungen"
  },
  {
    "objectID": "kapitel/08-boolsche-operationen/kapitel.html#sec-filtern",
    "href": "kapitel/08-boolsche-operationen/kapitel.html#sec-filtern",
    "title": "12  Boole’sche Operationen",
    "section": "12.5 Filtern",
    "text": "12.5 Filtern\n\nDefinition 12.5 Als Filter werden Funktionen bezeichnet, die Werte eines Vektors mithilfe eines logischen Ausdrucks auswählen.\n\nEin Vektor ist gefiltert, wenn der logische Ausdruck für alle Werte Wahr ergibt. Als Konsequenz werden alle Werte aus einem Vektor entfernt, für die der logische Ausdruck Falsch ergibt.\n\n\n\n\n\n\n\nMerke\n\n\n\nDurch das Filtern wird die Länge von Vektoren verändert. Das Ergebnis ist immer höchstens so lang wie der ursprüngliche ungefilterte Vektor.\n\n\nDer logische Ausdruck muss sich nicht auf die Werte des Vektors beziehen. Damit Werte mit einem solchen logischen Ausdruck ausgewählt werden können, bedarf es einen Referenzvektor mit gleicher Länge. Ein Wert wird mit dieser Technik ausgewählt, wenn der logische Ausdruck für den Wert an der gleichen Position im Referenzvektor Wahr ergibt.\nWeil die Vektoren von Stichprobenobjekten immer die gleiche Länge haben, lassen sich Filter zum Auswählen von Datensätzen verwenden."
  },
  {
    "objectID": "kapitel/08-boolsche-operationen/kapitel.html#sortieren",
    "href": "kapitel/08-boolsche-operationen/kapitel.html#sortieren",
    "title": "12  Boole’sche Operationen",
    "section": "12.6 Sortieren",
    "text": "12.6 Sortieren\n\nDefinition 12.6 Als Sortieren werden Funktionen bezeichnet, die Reihenfolge von Werten mittels eines logischen Ausdrucks bestimmen.\n\n\n\n\n\n\n\nMerke\n\n\n\nDurch Sortieren wird die Länge von Vektoren nicht verändert.\n\n\nDie Basis für das Sortieren sind Vektoren. Ein Vektor ist sortiert, wenn der logische Ausdruck für alle Werte paarweise Wahr ergibt. Die einfachsten logischen Ausdrücke zum Sortieren sind die Vergleiche grösser oder gleich und kleiner oder gleich.\nDie Reihenfolge der Werte wird beim Sortieren immer dann vertauscht, wenn der logische Ausdruck Falsch ergibt. Das Falsch bedeutet in diesem Fall, dass die Werte noch nicht in der richtigen Reihenfolge vorliegen.\n\n\n\n\n\n\nMerke\n\n\n\nDer Vergleich auf Gleichheit ist zum Sortieren ungeeignet, weil es keine Reihenfolge gibt, so dass die Gleichheit für alle Wertepaar Wahr ergibt.\n\n\nGrundsätzlich werden 2 Sortierreihenfolgen unterschieden. Diese sind für Zahlen, Zeichenketten und Wahrheitswerte definiert:\n\nAufsteigende Sortierung (engl. ascending)\nAbsteigende Sortierung (engl. descending)\n\nDie Sortierrichtung basiert auf zwei paarweisen Vergleichen zwischen den Elementen. Um die Sortierung zu ändern, muss nur der logische Vergleichsoperator umgekehrt werden.\n\nDie aufsteigende Sortierung beginnt mit dem kleinsten Wert des Sortierkriteriums und endet mit dem grössten Wert der Sortierung. Dabei gilt für alle Werte des sortierten Vektors die Ungleichung 12.5.\n\n\nv_{Vorgänger} \\le v_{Nachfolger}\n\\tag{12.5}\n\nDie absteigende Sortierung arbeitet genau entgegengesetzt vom grössten Wert des Sortierkriteriums zum kleinsten Wert. Entsprechend gilt für diese Reihenfolge die Ungleichung 12.6.\n\n\nv_{Vorgänger} \\ge v_{Nachfolger}\n\\tag{12.6}\n\n\n12.6.1 Sortieren für Fortgeschrittene\nWie beim Filtern können sich die logischen Ausdrücke beim Sortieren auf andere Vektoren beziehen. Dabei wird ebenfalls ein Referenzvektor benötigt. Die Sortierung des Vektors erfolgt entsprechend der Positionen im Referenzvektor. Deshalb müssen Referenzvektoren immer die gleiche Länge wie die Sortiervektoren haben.\n\nBeim Sortieren können komplexe logische Ausdrücke für spezielle Sortiuerungen eingesetzt werden. Dabei muss beachtet werden, dass diese Ausdrücke eine eindeutige Reihenfolge zulassen.\n\n\n\n\n\nBoole, G. (1847). The Mathematical Analysis of Logic,Being an Essay Towards a Calculus of Deductive Reasoning. https://www.gutenberg.org/files/36884/36884-pdf.pdf\n\n\nRautenberg, W. (2008). Einführung in die mathematische Logik: ein Lehrbuch (3., überarb. Aufl). Vieweg + Teubner."
  },
  {
    "objectID": "kapitel/09-vektor-operationen/kapitel.html#sec-sequenzen",
    "href": "kapitel/09-vektor-operationen/kapitel.html#sec-sequenzen",
    "title": "13  Vektor-Operationen",
    "section": "13.1 Sequenzen",
    "text": "13.1 Sequenzen\nEine besondere Gruppe von Vektoren sind Sequenzen. Sequenzen sind Vektoren deren Werte der Ordnung des Wertebereichs folgen.\n\nv_i &lt; v_{i+1}, \\text{wenn aufsteigende Reihenfolge} \\\\\\\nv_i &gt; v_{i+1}, \\text{wenn absteigende Reihenfolge}\n\\tag{13.1}\nEine Sequenz erfordert also immer einen ordinalen Wertebereich.\n\n\n\n\n\n\nSequenzen in den Life Sciences\n\n\n\nIn den Life Sciences werden zusammenhängende Abfolgen von Werten als Sequenzen bezeichnet. In diesen Sequenzen ist die Reihenfolge der Werte in diesen Sequenzen von Interesse. Solche Sequenzen haben nicht zwingend einen ordinalen Wertebereich und werden in der Regel als eigenständige Werte und nicht als Vektoren behandelt.\n\n\nNachfolgend werden nur Sequenzen vom Datentyp Zahl behandelt.\n\nDefinition 13.4 Eine lineare Sequenz ist ein Vektor, bei dem die Werte aufeinanderfolgender Indizes immer den gleichen Abstand haben.\n\nDeshalb gilt für lineare Sequenzen Formel 13.2.\n\nv_{i+1} - v_i = v_{j+1} - v_j\n\\tag{13.2}\n\n\n\n\n\n\nKonvention\n\n\n\nFür die praktische Anwendung sind lineare Sequenzen von zentraler Bedeutung. Deshalb wird im Folgenden der Begriff Sequenz synonym für lineare Sequenz verwendet. Alle anderen Sequenzen werden als Reihenfolgen bezeichnet oder explizit hervorgehoben.\n\n\n\nDefinition 13.5 Der Abstand einer Sequenz wird als Schrittweite bezeichnet. Wird keine Schrittweite für eine Sequenz angegeben, wird die Schrittweite 1 angenommen.\n\n\nDefinition 13.6 Der Anfangswert einer Sequenz wird auch Startwert oder Initialwert genannt. Wird kein Anfangswert für eine Sequenz angegeben, dann wird der Wert 1 angenommen.\n\n\nBeispiel 13.1 (Anfangswert) Eine Sequenz mit der Länge 5 entspricht dem Vektor {1,2,3,4,5}.\n\n\nBeispiel 13.2 (Länge und Schrittweite) Eine Sequenz mit der Schrittweite 3 und der Länge 4 entspricht dem Vektor {1,4,7,10}.\n\n\nBeispiel 13.3 (Startwert und Länge) Eine Sequenz mit dem Startwert 3 und der Länge 6 entspricht dem Vektor {3,4,5,6,7,8}.\n\n\nBeispiel 13.4 (Startwert, Schrittweite und Länge) Eine Sequenz mit dem Startwert 3, der Schrittweite 3 und der Länge 10 entspricht dem Vektor {3,6,9,12,15,18,21,24,27,30}.\n\n\n\n\n\n\n\nMerke\n\n\n\nEine Sequenz mit gleichem Anfangswert und Schrittweite entspricht der jeweiligen Multiplikationsreihe. Der Startwert und die Indizes der Sequenz sind hierbei den Multiplikatoren.\n\n\n\n13.1.1 Besondere Sequenzen\n\nDefinition 13.7 Der Einheitsvektor ist ein Vektor mit der geometrischen Länge 1.\n\nDer Einheitsvektor ist keine Sequenz, weil die Werte der Indizes nicht mit der gleichen Schrittweite ansteigen.\n\nDefinition 13.8 Ein Vektor mit beliebiger Länge heisst Nullvektor, wenn an allen Indizes der Wert 0 steht.\n\nDer Nullvektor ist damit eine besondere Sequenz, bei der der Startwert und die Schrittweite 0 ist.\nEin zweiter Vektor mit der Schrittweite 0 ist der Einsvektor.\n\nDefinition 13.9 Der Einsvektor ist ein Vektor mit beliebiger Länge mit dem Wert 1 bei jedem Index.\n\nDer Einsvektor ist damit eine besondere Sequenz, mit dem Startwert 1 und der Schrittweite 0.\nIn der mathematischen Literatur wird der Einsvektor oft nicht benannt. Wegen der besonderen Bedeutung dieses Vektors für verschiedene Operationen, wird diese Sequenz hier benannt.\n\n\n\n\n\n\nWichtig\n\n\n\nDer Einsvektor darf nicht mit dem Einheitsvektor verwechselt werden. Im Gegensatz zum Einsvektor hat der Einheitsvektor die geometrische Länge 1. Der Einsvektor der Länge 3 hat etwa die geometrische Länge von \\sqrt{3} \\approx 1.7321"
  },
  {
    "objectID": "kapitel/09-vektor-operationen/kapitel.html#sec-konkatenation",
    "href": "kapitel/09-vektor-operationen/kapitel.html#sec-konkatenation",
    "title": "13  Vektor-Operationen",
    "section": "13.2 Konkatenation",
    "text": "13.2 Konkatenation\nDatenvektoren können zu neuen Vektoren zusammengefügt werden. Dieser Vorgang heisst Konkatenation. Dabei werden zwei Vektoren vom gleichen Datentyp hintereinander aneinandergehängt.\nBei der Konkatenation muss die Bedingung des gleichen Datentyps zwingend erfüllt sein. Eine Konkatenation von Vektoren mit unterschiedlichen Datentypen ist unzulässig, weil die resultierende Datenstruktur kein Vektor mehr wäre.\n\n\nBeispiel 13.5 (Konkatenation) Die Konkatenation der Vektoren v = \\{1;2;3\\} und w = \\{4;5;6\\} ergibt einen neunen Vektor v \\circ w. Es gilt dabei die folgende Vorgehensweise:\n\nv\\circ w = \\{1;2;3\\} \\circ \\{4;5;6\\} = \\{1;2;3;4;5;6\\}\n\n\n\nDer leere Vektor ist das neutrale Element der Konkatenation. D.h. die Konkatenation eines Vektors mit dem leeren Vektor ergibt den ursprünglichen Vektor. Es gilt als Formel 13.3.\n\nv \\circ \\varnothing = \\varnothing \\circ v = v\n\\tag{13.3}\nEin Skalar kann als Vektor mit der Länge 1 aufgefasst werden. Die Konkatenation eines Vektors mit einem Skalart ergibt einen Vektor, der um 1 länger als der ursprüngliche Vektor ist. Es gilt also Formel 13.4.\n\nv \\circ a \\Leftrightarrow v \\circ \\{ a \\}\n\n\n\\begin{aligned}\nv \\circ a &= \\{v_1; v_2; \\dots; v_n\\} \\circ a \\\\\n&= \\{v_1; v_2; \\dots; v_n\\} \\circ \\{a\\} \\\\\n&= \\{v_1; v_2; \\dots; v_n; a\\}\n\\end{aligned}\n\\tag{13.4}\nWeil die Reihenfolge der Konkatenation bedeutungsvoll ist, kann ein einzelner Wert auch vor einem Vektor angefügt werden.\n\n\\begin{aligned}\na \\circ v &= a \\circ \\{v_1; v_2; \\dots; v_n\\} \\\\\n&= \\{a\\} \\circ \\{v_1; v_2; \\dots; v_n\\}  \\\\\n&= \\{a; v_1; v_2; \\dots; v_n\\}\n\\end{aligned}"
  },
  {
    "objectID": "kapitel/09-vektor-operationen/kapitel.html#tranformationen",
    "href": "kapitel/09-vektor-operationen/kapitel.html#tranformationen",
    "title": "13  Vektor-Operationen",
    "section": "13.3 Tranformationen",
    "text": "13.3 Tranformationen\n\nDefinition 13.10 Eine Transformation bezeichnet eine Umformung der Element eines Vektors, wobei die Länge des Vektors unverändert bleibt.\n\nEine Transformation erfordert also immer eine Funktion, die auf die Elemente des Vektors angewandt wird. Diese Funktion wird für jedes Element des Vektors separat ausgeführt. Dadurch ist sichergestellt, dass es für jedes Element des Vektors genau ein Ergebnis gibt.\n\n\n\n\n\n\nMerke\n\n\n\nBeim Transformieren sind alle Operationen auf die Elemente eines Vektors unabhängig voneinander und die Ergebnisse beeinflussen sich nicht gegenseitig.\n\n\nBeim Transformieren kann der Datentyp eines Vektors verändert werden.\n\n13.3.1 Transformationen mit einem Skalar\nEine Transformation mit einem Skalar wird auch als Skalierung bezeichnet.\nFür die Skalierung eines Vektors ist eine Transformationsfunktion mit zwei Parametern erforderlich. Beim Skalieren wird die Transformationsfunktion mit dem Skalar mit jedem Element des Vektors separat durchgeführt.\nEs gilt also die Logik der Formel 13.5. Der Operator \\circ ist hier der Platzhalter für die Transformationsfunktion.\n\n\\begin{aligned}\ns \\circ v &= s \\circ \\{v_1; v_2; \\dots; v_n\\} \\\\\n&= \\{s \\circ v_1; s \\circ v_2; \\dots; s \\circ v_n\\}\n\\end{aligned}\n\\tag{13.5}\n\n\nBeispiel 13.6 (Skalierung mit Zahlen) Die Skalierung eines Vektors v = \\{1;2;3\\} mit dem Skalar s = 2 ergibt den Vektor v' = \\{3;4;5\\}. Es gilt dabei die folgende Vorgehensweise:\n\n\\begin{aligned}\ns + v &= 2 + \\{1;2;3\\} \\\\\n&= \\{2 + 1; 2 + 2; 2 + 3\\} \\\\\n&= \\{3; 4; 5\\}\n\\end{aligned}\n\nDiese Vorgehensweise wird als Skalaraddition bezeichnet. Die Skalaraddition ist eine Transformation mit einem Skalar und der Addition als Transformationsfunktion.\nAnalog zur Skalaraddition gibt es die Skalarmultiplikation. Bei der Skalarmultiplikation wird die Multiplikation als Transformationsfunktion verwendet. Die Skalarmultiplikation wird wie folgt durchgeführt.\n\n\\begin{aligned}\ns \\cdot v &= 2 \\cdot \\{1;2;3\\} \\\\\n&= \\{2 \\cdot 1; 2 \\cdot 2; 2 \\cdot 3\\} \\\\\n&= \\{2; 4; 6\\}\n\\end{aligned}\n\n\n\n\n\n13.3.2 Transformationen mit einem Vektor\nDie Transformation mit einem Skalar kann auf Vektoren erweitert werden. Dabei wird die Transformationsfunktion mit den Elementen eines zweiten Vektors anstelle des Skalars durchgeführt. Eine solche Transformation erfordert, dass die Werte der beiden Vektoren paarweise durch die Transformationsfunktion verknüpft werden. Damit solche paarweisen Operationen möglich sind, müssen die beiden Vektoren die gleiche Länge haben.\n\n\n\n\n\n\nMerke\n\n\n\nDie Skalar-Transformation kann nur mit einem Vektor der Länge 1 oder mit einem Vektor mit der gleichen Länge wie der zu transformierende Vektor durchgeführt werden.\n\n\nDann gilt die Logik der Formel 13.6. Der Operator \\circ ist hier der Platzhalter für die Transformationsfunktion.\n\n\\begin{aligned}\nv \\circ w &= \\{v_1; v_2; \\dots; v_n\\} \\circ \\{w_1; w_2; \\dots; w_n\\} \\\\\n&= \\{v_1 \\circ w_1; v_2 \\circ w_2; \\dots; v_n \\circ w_n\\}\n\\end{aligned}\n\\tag{13.6}\n\n\nBeispiel 13.7 (Vektoraddition) Für die beiden gleichlangen Vektoren v = \\{1;2;3\\} und w = \\{4;5;6\\} wird die Vektoraddition paarweise durchgeführt.\n\n\\begin{aligned}\nv + w &= \\{v_1; v_2; v_3\\} + \\{w_1; w_2; w_3\\} \\\\\n&= \\{1;2;3\\} + \\{4; 5; 6\\} \\\\\n&= \\{1 + 4; 2 + 5; 3 + 6\\} \\\\\n&= \\{5; 7; 9\\}\n\\end{aligned}\n\nDeutlicher wird diese Mechanik, wenn die Vektoren als Spaltenvektoren geschrieben werden.\n\n\\begin{aligned}\nv + w &= \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\end{pmatrix} + \\begin{pmatrix} w_1 \\\\ w_2 \\\\ w_3 \\end{pmatrix} \\\\ \\\\\n&= \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix} + \\begin{pmatrix} 4 \\\\ 5 \\\\ 6 \\end{pmatrix} \\\\ \\\\\n&= \\begin{pmatrix} 1 + 4 \\\\ 2 + 5 \\\\ 3 + 6 \\end{pmatrix} \\\\ \\\\\n&= \\begin{pmatrix} 5 \\\\ 7 \\\\ 9 \\end{pmatrix}\n\\end{aligned}"
  },
  {
    "objectID": "kapitel/09-vektor-operationen/kapitel.html#aggregationen",
    "href": "kapitel/09-vektor-operationen/kapitel.html#aggregationen",
    "title": "13  Vektor-Operationen",
    "section": "13.4 Aggregationen",
    "text": "13.4 Aggregationen\n\nDefinition 13.11 Eine Aggregation ist eine Funktion, die Elemente eines Vektors zusammenfasst. Durch aggregieren kann sich die Länge des Vektors verändern.\n\nEine Aggregationsfunktion heisst Aggregator. Aggregatoren haben in der Regel nur einen Parameter, der ein Vektor ist. Ein Aggregator wendet eine zweite Funktion auf die Elemente des Vektors an. Diese zweite Funktion heisst Reduktionsfunktion. Die Reduktionsfunktion legt fest, wie die Elemente des Vektors zusammengefasst werden.\n\n\n\n\n\n\nMerke\n\n\n\nBeim Aggregieren hängen die Operationen von der jeweiligen vorangehenden Operation ab. Die einzelnen Operationen sind voneinander abhängig und die Ergebnisse beeinflussen sich gegenseitig.\n\n\n\n\nBeispiel 13.8 (Aggregation und Reduktion beim Summieren) Der \\sum{}-Operator ist ein Aggregator. Die dem Operator nachfolgenden Terme legen die zu aggregierenden Vektorelement fest. Die Reduktionsfunktion ist die Addition (+).\nFür den Vektor v = \\{1;2;3;4;5\\} kann die die Summe der Quadrate wie folgt geschrieben werden.\n\n\\sum_{i=1}^5 v_i^2\n\nDiese Schreibweise legt fest, dass die Vektorelemente quadriert werden müssen. Dabei handelt es sich um eine Transformation mit einem Skalar (2) und der Potenz als Transformationsfunktion. Diese vorgelagerte Transformation erzeugt einen impliziten Vektor mit den quadrierten Elementen \\{1, 4, 9, 16, 25\\}.\nDie Reduktionsfunktion der Summe ist die Addition (+). Beim Reduzieren werden die Elemente des impliziten Vektors nacheinander addiert. Dabei wird das Element mit dem bisherigen Ergebnis reduziert. Beim ersten Schritt liegt noch kein Ergenis vor, weshalb das Element direkt übernommen wird. Dadurch ergeben sich in diesem Beispiel die folgenden Reduktionsschritte.\n\n\\begin{aligned}\n\\sum{v^2} = \\sum_{i=1}^5 v_i^2 &= 1 + 4 + 9 + 16 + 25 \\\\\n&= 5 + 9 + 16 + 25 \\\\\n&= 14 + 16 + 25 \\\\\n&= 30 + 25 \\\\\n&= 55\n\\end{aligned}\n\nDie Summe der Quadrate des Vektors v ist also 55.\n\n\nIm Kapitel 12.5 wurden Filter als Funktionen eingeführt, die Werte aus Vektoren mithilfe eines logischen Ausdrucks auswählen. Das Filtern ist eine spezielle Aggregation, bei dem die ursprünglichen Werte unverändert bleiben, aber die Länge des Vektors verändert wird. Anders als die Summe, liefert das Filtern einen Vektor und keinen einzelnen Wert als Ergebnis. Beim Filtern wird die Reduktionsfunktion als Selektionsfunktion bezeichnet. Die Selektionsfunktion fügt einen Wert dem Ergebnisvektor durch Konkatenation hinzu, wenn der logische Ausdruck Wahr ergibt. Der Startwert für die Reduktion ist beim Filtern der leere Vektor."
  },
  {
    "objectID": "kapitel/09-vektor-operationen/kapitel.html#zählen",
    "href": "kapitel/09-vektor-operationen/kapitel.html#zählen",
    "title": "13  Vektor-Operationen",
    "section": "13.5 Zählen",
    "text": "13.5 Zählen\n\nDefinition 13.12 Als Umfang bezeichnen wir die Anzahl der Elemente eines Vektors oder einer Liste.\n\n\nDefinition 13.13 Zählen bezeichnet das Bestimmen der Anzahl von Elementen eines Vektors oder einer Liste.\n\nDie Anzahl der Elemente eines Vektors ist immer gleich der Länge des Vektors. Deshalb kann der Umfang eines Vektors direkt aus der Länge des Vektors abgelesen werden.\n\n\n\n\n\n\nMathematik vs. Datenwisssenschaft\n\n\n\nIn der Mathematik (Mengenlehre) existiert das Konzept der Abzählbarkeit. Dieses Konzept wird auf beliebige und insbesondere unendliche Mengen angewandt, um deren abstrakte Umfänge zu vergleichen.\nBeim Rechnen und Problemlösen mit Computern liegen immer mit speziellen, endlichen Strukturen vor. Damit muss beim Zählen immer die Frage nach dem konkreten Umfang der vorliegenden Elemente beantwortet werden.\n\n\nNicht immer muss der Umfang des gesamten Vektors bestimmt werden. Stattdessen sollen einzelne Elemente eines Vektors gezählt werden, die bestimmte Bedingungen erfüllen. Eine solche Bedingung wird immer als logischer Ausdruck formuliert.\n\nDefinition 13.14 Eine zählbare Einheit bezeichnet ein Element, für das eine Zählbedingung Wahr ergibt. Eine nicht zählbare Einheit bezeichnet ein Element, für das eine Zählbedingung Falsch ergibt.\n\n\nEine zählbare Einheit wird durch den Wert 1 (oder Wahr) repräsentiert. Ein zählbares Element wird gezählt.\nEine nicht-zählbare Einheit wird durch den Wert 0 (oder Falsch) repräsentiert. Diese Elemente werden nicht gezählt.\n\n\n13.5.1 Zählen durch Summieren\nBeim Zählen durch Summieren geht eine Transformation in die Werte 0 und 1 mithilfe eines logischen Ausdurcks einer Summen-Aggregation unmittelbar voraus.\nGelegentlich werden nicht alle Elemente einer Datenstruktur gezählt, sondern nur diejenigen, die bestimmte Bedingungen erfüllen.\n\nDefinition 13.15 Es wird vom Abzählen gesprochen, wenn zum Zählen eine Summe über die zählbaren Einheiten gebildet wird.\n\nDabei wird ausgenutzt, dass die Summe über einen Vektor von 0 und 1 die Anzahl der 1-Werte ergibt.\n\n\n\n\n\n\nMerke\n\n\n\nImmer wenn eine Summe über einen Vektor von 0 und 1 gebildet wird, wird eine Zählen-Operation vorbereitet.\n\n\nDie Transformation in die Werte 0 und 1 durch einen logischen Ausdruck wird als Indikatorfunktion bezeichnet. Die Indikatorfunktion ist eine Transformation mit einem logischen Ausdruck. Eine solche Funktion kann für nachgelagerte arithmetische Transformations-Operationen als Ersatz für eine vorgelagerte Entscheidung verwendet werden. In solchen Fällen wird das Ergebnis der Indikatorfunktion über eine Skalar-Multiplikation mit der nachgelagerten Operation verknüpft. Dabei stellt die Indikatorfunktion sicher, dass der Vektor die gleiche Länge wie die nachgelagerte Operation hat.\n\n\n13.5.2 Zählen durch Filtern\nBeim Zählen durch Filtern wird die Summe über die zählbaren Einheiten durch eine Filter-Aggregation zusammegefasst. Nach dem Filtern bleibt ein Vektor mit den zählbaren Einheiten übrig, der keine nicht-zählbaren Elemente enthält. Die Länge dieses Vektors entspricht der Anzahl der zählbaren Einheiten.\n\n\n\n\n\n\nMerke\n\n\n\nWerden die zählbaren Einheiten durch einen Filter ausgewählt, dann entspricht die Summe der zählbaren Einheiten der Länge des gefilterten Vektors.\n\n\nWeil das Filtern die Länge des Vektors verändert, kann das Filtern nicht als Indikatorfunktion verwendet werden.\n\n\n13.5.3 Zählen durch Nummerieren\nBeim Nummerieren wird eine Sequenz erzeugt, die für jede zählbare Einheit einen Wert enthält. Die Länge dieser Sequenz entspricht der Anzahl der zählbaren Einheiten. Gleichzeigit entspricht der Maximal-Wert der Sequenz ebenfalls der Anzahl der zählbaren Einheiten.\n\n\n\n\n\n\nMerke\n\n\n\nWenn die zählbaren Einheiten durchnummeriert werden, dann entspricht der Umfang dieser Einheiten der grössten Nummerierung (dem Maximum).\n\n\nNummerierungen werden häufig verwendet, um einzelnen Datensätzen eindeutige Identifikatoren zuzuweisen. Diese Nummerierungen können zum Zählen leicht benutzt werden."
  },
  {
    "objectID": "kapitel/10-matrix-operationen/kapitel.html#grundbegriffe",
    "href": "kapitel/10-matrix-operationen/kapitel.html#grundbegriffe",
    "title": "14  Matrix-Operationen",
    "section": "14.1 Grundbegriffe",
    "text": "14.1 Grundbegriffe\n\nDefinition 14.1 Die Hauptdiagonale einer Matrix sind alle Positionen mit gleichen Zeilen- und Spaltenindizes.\n\n\nDefinition 14.2 Eine symmetrische Matrix ist eine quadratische Matrix, die bezüglich der Hauptdiagonalen symmetrisch ist.\n\nDaraus folgt, dass die Werte einer symmetrischen Matrix an einer Position (i, j) gleich den Werten an der Position (j, i) sind.\n\nBeispiel 14.1 (Symmetrische Matrix) \n\\begin{bmatrix}\n1 & 0 & 6 & 4 & 9 \\\\\n0 & 2 & 2 & 6 & 14 \\\\\n6 & 2 & 3 & 7 & 8 \\\\\n4 & 6 & 7 & 4 & 9 \\\\\n9 & 14 & 8 & 9 & 5\n\\end{bmatrix}\n\n\n\nDefinition 14.3 Eine Diagonalmatrix hat nur Werte auf der Hauptdiagonalen. Alle anderen Werte sind 0.\n\n\nDefinition 14.4 Die Einheitsmatrix ist eine Diagonalmatrix mit 1 entlang der Hauptdiagonalen.\n\n\nBeispiel 14.2 (Einheitsmatrix mit 3 Zeilen und 6 Spalten) \n\\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 & 0\n\\end{bmatrix}\n\n\n\nDefinition 14.5 Die Identitätsmatrix ist eine quadratische Einheitsmatrix.\n\nDie Identitätsmatrix wird in Formeln als I gekennzeichnet.\n\nBeispiel 14.3 (Identitätsmatrix) \n\\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1\n\\end{bmatrix}\n\n\n\nDefinition 14.6 Eine Dreiecksmatrix ist eine Matrix, die nur Werte unterhalb oder oberhalb der Hauptdiagonalen hat.\n\nDie Hauptdiagonale einer Dreiecks-Matrix wird nicht immer zum Wertebereich hinzugezählt. Je nach Anforderung, muss dieser Wertebereich entsprechend ein- oder ausgeschlossen werden.\n\nBeispiel 14.4 (Untere Dreiecksmatrix) \n\\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 \\\\\n11 & 2 & 0 & 0 & 0 \\\\\n6 & 2 & 3 & 0 & 0 \\\\\n4 & 6 & 7 & 4 & 0 \\\\\n9 & 14 & 8 & 9 & 5\n\\end{bmatrix}\n\n\n\nBeispiel 14.5 (Obere Dreiecksmatrix) \n\\begin{bmatrix}\n1 & 11 & 6 & 4 & 9 \\\\\n0 & 2 & 2 & 6 & 14 \\\\\n0 & 0 & 3 & 7 & 8 \\\\\n0 & 0 & 0 & 4 & 9 \\\\\n0 & 0 & 0 & 0 & 5\n\\end{bmatrix}\n\n\n\nDefinition 14.7 Eine dünnbesetzte Matrix (oder Sparse Matrix) ist eine Matrix, die überwiegend 0-Werte enthält.\n\n\nBeispiel 14.6 (Sparse Matrix) \n\\begin{bmatrix}\n0 & 1 & 0 & 0 & 9 \\\\\n0 & 0 & 2 & 6 & 0 \\\\\n6 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 7 & 0 \\\\\n0 & 4 & 0 & 3 & 0\n\\end{bmatrix}\n\n\n\nDefinition 14.8 Eine Matrix, welche die Werte einer anderen Matrix A mit vertauschten Zeilen- und Spaltenindizes enthält, wird transponierte Matrix von A genannt.\n\nFür die transponierte Matrix von A wird A^T geschrieben.\n\nBeispiel 14.7 (Transponierte Matrix) \n\\begin{aligned}\nA &= \\begin{bmatrix}\n1 & 0 \\\\\n0 & 2 \\\\\n6 & 2  \\\\\n4 & 6  \\\\\n9 & 7\n\\end{bmatrix} \\\\\\\n\\\\\nA^T &= \\begin{bmatrix}\n1 & 0 & 6 & 4 & 9 \\\\\n0 & 2 & 2 & 6 & 7\n\\end{bmatrix}\n\\end{aligned}\n\n\nWir beachten, dass per Konvention der Zeilenindex immer als Erstes und der Spaltenindex immer als Zweites angegeben wird. Anstelle der mathematischen Schreibweise trennen wir die beiden Indizes. Auf diese Weise können wir auf jeden Wert in einer Matrix zugreifen."
  },
  {
    "objectID": "kapitel/10-matrix-operationen/kapitel.html#matrixaddition",
    "href": "kapitel/10-matrix-operationen/kapitel.html#matrixaddition",
    "title": "14  Matrix-Operationen",
    "section": "14.2 Matrixaddition",
    "text": "14.2 Matrixaddition\nDie Matrizenaddition addiert die Elemente zweier Matrizen paarweise. Damit die Addition funktioniert, muss es für jeden Wert in Matrix A einen Partnerwert in Matrix B mit gleichem Zeilenindex i und Spaltenindex j geben. Daraus folgt direkt, dass die Matrixaddition nur für Matrizen mit gleichen Dimensionen m und n definiert ist."
  },
  {
    "objectID": "kapitel/10-matrix-operationen/kapitel.html#vektoraddition",
    "href": "kapitel/10-matrix-operationen/kapitel.html#vektoraddition",
    "title": "14  Matrix-Operationen",
    "section": "14.3 Vektoraddition",
    "text": "14.3 Vektoraddition\nDie Vektoraddition funktioniert etwas anders als die Matrixaddition. In diesem Fall liegt uns eine m x n-Matrix und ein m-Vektor vor.\nDie Vektoraddition ist nur dann definiert, wenn die Matrix und der Vektor die gleiche Anzahl an Zeilen haben.\nBei der Vektoraddition wird der Vektor zu jeder Spalte in der Matrix addiert. Dabei werden die Werte paarweise zusammengezählt.\n::: {#exm-matrix-vektoraddition} ## Vektoraddition eines 2-Vektor und eine 2 x 3-Matrix.\n\n\\begin{aligned}\nv + M &= \\begin{bmatrix}\nv_{1}  \\\\\nv_{2}\n\\end{bmatrix} + \\begin{bmatrix}\nm_{11} & m_{12}  & m_{13}  \\\\\nm_{21} & m_{22} & m_{23}  \n\\end{bmatrix} \\\\\\\n\\\\\n&= \\begin{bmatrix}\nv_1 + m_{11} & v_1 + m_{12}  & v_1 + m_{13}  \\\\\nv_2 + m_{21} & v_2 + m_{22} & v_2 + m_{23}  \n\\end{bmatrix}\n\\end{aligned}"
  },
  {
    "objectID": "kapitel/10-matrix-operationen/kapitel.html#skalarmultiplikation-punktprodukt",
    "href": "kapitel/10-matrix-operationen/kapitel.html#skalarmultiplikation-punktprodukt",
    "title": "14  Matrix-Operationen",
    "section": "14.4 Skalarmultiplikation (Punktprodukt)",
    "text": "14.4 Skalarmultiplikation (Punktprodukt)\nDie Skalarmultiplikation oder das Punktprodukt multipliziert einen Wert a mit einer Matrix (oder Vektor) M. Dabei wird \\( a \\) als Skalar bezeichnet, weil dieser alle Werte um den gegebenen Wert skaliert. Bei der Skalarmultiplikation wird jeder Wert in der Matrix mit dem Skalar multipliziert.\n\n\\begin{aligned}\na \\cdot M &= a \\cdot \\begin{bmatrix}\nm_{11} & m_{12}  & m_{13}  \\\\\nm_{21} & m_{22} & m_{23}  \n\\end{bmatrix} \\\\\\ \\\\\\\n&= \\begin{bmatrix}\na \\cdot m_{11} & a \\cdot m_{12}  & a \\cdot m_{13}  \\\\\na \\cdot m_{21} & a \\cdot m_{22} & a \\cdot m_{23}  \n\\end{bmatrix}\n\\end{aligned}\n\nDieses Konzept lässt sich auf Vektoren übertragen. Dabei ist der Skalar a ein Vektor mit der gleichen Anzahl an Zeilen für den Vektor und die Matrix. Danach funktioniert die Skalarmultiplikation analog zur Vektoraddition.\n\n\\begin{aligned}\na \\cdot M &= \\begin{bmatrix}\na_1\\\\\na_2\n\\end{bmatrix} \\cdot \\begin{bmatrix}\nm_{11} & m_{12}  & m_{13}  \\\\\nm_{21} & m_{22} & m_{23}  \n\\end{bmatrix} \\\\\\ \\\\\\\n&= \\begin{bmatrix}\na_1 \\cdot m_{11} & a_1 \\cdot m_{12}  & a_1 \\cdot m_{13}  \\\\\na_2 \\cdot m_{21} & a_2 \\cdot m_{22} & a_2 \\cdot m_{23}  \n\\end{bmatrix}\n\\end{aligned}"
  },
  {
    "objectID": "kapitel/10-matrix-operationen/kapitel.html#matrixmultiplikation-kreuzprodukt",
    "href": "kapitel/10-matrix-operationen/kapitel.html#matrixmultiplikation-kreuzprodukt",
    "title": "14  Matrix-Operationen",
    "section": "14.5 Matrixmultiplikation/ Kreuzprodukt",
    "text": "14.5 Matrixmultiplikation/ Kreuzprodukt\nDas Kreuzprodukt ist eine andere Variante zwei Matrizen zu multiplizieren. Dabei werden zwei Matrizen A und B über Kreuz multipliziert. Dazu muss gegeben sein, dass die Matrix A gleich viel Spalten hat, wie Matrix B Zeilen. Es muss also gelten, dass wir eine m x n-Matrix mit einer n x p-Matrix multiplizieren, wobei n für beide Matrizen gleich sein muss. Sind diese Voraussetzungen nicht erfüllt, kann das Kreuzprodukt nicht gebildet werden.\nDas Kreuzprodukt ist wie folgt definiert:\n\n\\begin{aligned}\nA \\times B &= \\begin{bmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\cdots & a_{mn} \\\\\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\nb_{11} & b_{12} & \\cdots & b_{1p} \\\\\nb_{21} & b_{22} & \\cdots & b_{2p} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nb_{n1} & b_{n2} & \\cdots & b_{np} \\\\\n\\end{bmatrix} \\\\\\\n\\\\\\\n&= \\begin{bmatrix}\n\\sum_{i=1}^{n}{a_{1i} \\cdot b_{i1}} & \\sum_{i=1}^{n}{a_{1i} \\cdot b_{i2}} & \\cdots & \\sum_{i=1}^{n}{a_{1i} \\cdot b_{ip}} \\\\\n\\sum_{i=1}^{n}{a_{2i} \\cdot b_{i1}} & \\sum_{i=1}^{n}{a_{2i} \\cdot b_{i2}} & \\cdots & \\sum_{i=1}^{n}{a_{2i} \\cdot b_{ip}} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\sum_{i=1}^{n}{a_{mi} \\cdot b_{i1}} & \\sum_{i=1}^{n}{a_{mi} \\cdot b_{i2}} & \\cdots & \\sum_{i=1}^{n}{a_{mi} \\cdot b_{ip}} \\\\\n\\end{bmatrix}\n\\end{aligned}\n\nDas Ergebnis eines Kreuzprodukts ist immer eine Matrix mit m-Zeilen und p-Spalten.\nAus der Definition des Kreuzprodukts zeigt sich, dass die Operanden beim Kreuzprodukt nur vertauscht werden können, wenn beide Matrizen quadratisch sind. Dabei gilt für beliebige Matrizen ausserdem Formel 14.1.\n\nA \\times B \\ne B \\times A\n\\tag{14.1}\nDas Kreuzprodukt hat ein neutrales Element: Die Identitätsmatrix I. Die Identitätsmatrix ist eine quadratische Matrix, die an den Positionen der abfallenden Diagonalen den Wert 1 und sonst den Wert 0 hat.\n\nBeispiel 14.8 (3-dimensionale Einheitsmatrix) \n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\n\nFür die Identitätsmatrix gilt Formel 14.2.\n\nA \\times I = I \\times A = A\n\\tag{14.2}\n\n14.5.1 Kreuzprodukt für Vektoren\nAus der Anforderung für das Kreuzprodukt folgt direkt das Kreuzprodukt für Vektoren, die wir als m x 1- sowie als 1 x p-Matrizen verstehen können. Es gilt also: n = 1. Deshalb mussten wir für das Einmaleins-Beispiel den zweiten Vektor transponieren. Dadurch vereinfacht sich die komplizierte Formel des Kreuzprodukts auf die paarweise-überkreuzte Multiplikation.\n\n\n14.5.2 Inverse Matrix\n\nDefinition 14.9 Die inverse Matrix A^{-1} ist die Matrix, die mit der Matrix A multipliziert die Identitätsmatrix I ergibt. Es gilt also Formel 14.3.\n\n\nA \\times A^{-1} = A^{-1} \\times A = I\n\\tag{14.3}\nDie inverse Matrix kann nicht für beliebige Matrizen gebildet werden, sondern ist nur für bestimme quadratische Matrizen definiert. Die Inverse Matrix wird für verschiedene Anwendungen benötigt und wird deshalb von den meisten Softwarepaketen bereitgestellt. Es ist deshalb selten notwendig, eine inverse Matrix selbst zu berechnen.\n\n\n14.5.3 Anwendungen des Kreuzprodukts\n\n14.5.3.1 Zeilen- und Spaltensummen berechnen\nFür Zeilen- bzw. Spaltensummen werden drei Eigenschaften ausgenutzt:\n\nVektoren lassen sich als 1 \\times n- bzw. n \\times 1-Matrizen verstehen.\nDas Ergebnis des Kreuzpodukts ist immer eine Matrix mit m \\times p-Dimensionen.\nDas neutrale Element der Multiplikation ist 1.\n\nWeil für jede Ergebnisposition des Kreuzprodukts Formel 14.4 gilt.\n\n\\sum_{i=1}^{n}{a_{ji} \\cdot b_{ik}}\n\\tag{14.4}\nWird einer der beiden Parameter a_{ji} oder b_{ik} eins, dann reduziert sich dieser Term auf eine einfache Summe entsprechend Formel 14.5.\n\n\\sum_{i=1}^{n}{a_{ji} \\cdot b_{ik}} = \\sum_{i=1}^{n}{a_{ji} \\cdot 1} = \\sum_{i=1}^{n}{a_{ji}}\n\\tag{14.5}\nFür die Spalten- bzw. Zeilensumme soll jeweils ein Vektor bestimmt werden, der die Summe der Werte in der jeweiligen Zeile bzw. Spalte enthält. Dazu wird die Matrix mit einem geeigneten Einsvektor multipliziert.\nFür die Spaltensumme, muss dieser Einsvektor die Länge der Anzahl der Zeilen haben. Für die Zeilensumme muss der Einsvektor die Länge der Anzahl der Spalten haben.\n\nBeispiel 14.9 (Spaltensumme für eine 3 \\times 4-Matrix) \n\\begin{bmatrix}\n1 & 1 & 1\n\\end{bmatrix}\n\\times \\begin{bmatrix}\n3 & 6 & 2  &1 \\\\\n4 & 3 & 2 & 1 \\\\\n1 & 2 & 3 & 4\n\\end{bmatrix} =\n\\begin{bmatrix}\n8 & 11 & 7 & 6\n\\end{bmatrix}\n\n\n\nBeispiel 14.10 (Zeilensumme für eine 3 \\times 4-Matrix) \n\\begin{bmatrix}\n3 & 6 & 2  &1 \\\\\n4 & 3 & 2 & 1 \\\\\n1 & 2 & 3 & 4\n\\end{bmatrix} \\times \\begin{bmatrix}\n1 \\\\\n1 \\\\\n1 \\\\\n1\n\\end{bmatrix}=\n\\begin{bmatrix}\n12 \\\\ 10 \\\\ 10\n\\end{bmatrix}\n\n\n\n\n14.5.3.2 Vorgänger- und Nachfolgersummen\nWird ein Vektor mit einer Dreiecks-Matrix multipliziert, dann werden die Vorgänger- bzw. Nachfolgerwerte addiert.\n\nBeispiel 14.11 (Nachfolgersumme für einen Vektor der Länge 4) \n\\begin{bmatrix}3 &6 &2 &1\\end{bmatrix} \\times \\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n1 & 1 & 0 & 0 \\\\\n1 & 1 & 1 & 0 \\\\\n1 & 1 & 1 & 1\n\\end{bmatrix} = \\begin{bmatrix}12 & 9 & 3 & 1\\end{bmatrix}\n\n\nDiese Logik lässt sich auch auf Matrizen erweitern. Dabei werden die Vorgänger- bzw. Nachfolgerwerte für jede Zeile berechnet.\n\nBeispiel 14.12 (Nachfolgersumme für eine 2 \\times 4-Matrix) \n\\begin{bmatrix}\n3 & 6& 2  &1 \\\\\n4 & 3 & 2 & 1\n\\end{bmatrix}\n\\times \\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n1 & 1 & 0 & 0 \\\\\n1 & 1 & 1 & 0 \\\\\n1 & 1 & 1 & 1\n\\end{bmatrix} =\n\\begin{bmatrix}\n12& 9& 3 &1 \\\\\n10 & 6 & 3 & 1\n\\end{bmatrix}"
  },
  {
    "objectID": "kapitel/10-matrix-operationen/kapitel.html#das-äussere-matrixprodukt",
    "href": "kapitel/10-matrix-operationen/kapitel.html#das-äussere-matrixprodukt",
    "title": "14  Matrix-Operationen",
    "section": "14.6 Das äussere Matrixprodukt",
    "text": "14.6 Das äussere Matrixprodukt\nBei den Vektoren und Matrizen haben wir bereits das Kreuzprodukt kennengelernt, mit dem wir aus zwei Vektoren eine Matrix konstruieren können. Das Kreuzprodukt ist allerdings nur für die Multiplikation als paarweiser Operator definiert. Neben dem Kreuzprodukt gibt es noch eine zweite und flexiblere Möglichkeit, um aus zwei Vektoren eine Matrix zu generieren: Das sog. äussere Produkt.\nBeim äusseren Produkt oder dyadischen Produkt werden die Werte zweier Vektoren paarweise miteinander verknüpft, wodurch eine Matrix erzeugt wird, bei der die Anzahl der Zeilen entsprechend der Länge des linken und die Anzahl der Spalten mit der Länge des rechten Vektors übereinstimmt.\nWenn also zwei Vektoren x mit der Länge m und y mit der Länge n gegeben sind, dann können wir das äussere Produkt wie folgt schreiben:\n\nx \\otimes y = M^{m \\times n }\n\nDas Ergebnis des äusseren Produkts ist also immer eine Matrix. Wir beachten, dass die Definition nur eine Verknüpfung fordert, aber nicht festlegt, welche Verknüpfung verwendet werden soll. Wir können also beliebige Operationen zur Verknüpfung verwenden.\nWird als Verknüpfungsoperator für das äussere Produkt die Multiplikation gewählt, dann entspricht das Ergebnis des äusseren Produkts für zwei Vektoren dem Kreuzprodukt zwischen Vektoren.\nAnders als beim Kreuzprodukt, können beim äusseren Matrixprodukt beliebige Operatoren verwendet werden. In der Praxis werden sehr oft Vergleichsoperatoren für die Verknüpfung verwendet.\n\n\nBeispiel 14.13 (Eine Dreiecks-Matrix mit dem äusseren Produkt erzeugen.) Eine Dreiecks-Matrix eine wichtige Matrix, weil durch die 0 ober- bzw. unterhalb der Hauptdigonalen bei der Matrixmultiplikation viele Rechenoperationen eingespart werden können. Diese Einsparung kommt in der Praxis immer dann zum Tragen, wenn nur Vorgänger- oder Nachfolgerwerte berückstichtigt werden müssen. Dafür ist es oft sinnvoll, eine Dreiecks-Matrix zu erzeugen, die nur die Werte 1 und 0 enthält.\nEine Dreiecksmatrix lässt sich mit dem äusseren Produkt aus zwei Sequenzen erzeugen. Dazu wird in zwei Schritten vorgegangen.\n\nEine Sequenz wird mit der gewünschten Länge erzeugt.\nDie Sequenz wird mit sich selbst multipliziert. Als Operator wird ein Vergleichsoperator verwendet, der die Werte der Sequenz paarweise vergleicht.\n\nEine Dreiecks-Matrix entsteht, wenn ein grösser- oder kleiner-Vergleich durchgeführt wird. Soll die Hauptdiagonale einbezogen werden, dann jeweils ein grösser-oder-gleich- bzw. kleiner-oder-gleich-Vergleich durchgeführt werden.\nUm eine 3\\times 3-Matrix zu erzeugen, wird eine Sequenz mit der Länge 3 benötigt.\n\n\\{1;2;3\\}\n\nDiese Sequenz wird mit sich selbst multipliziert. Als Operator wird ein grösser-Vergleich verwendet.\n\n\\{1;2;3\\} \\otimes_{&gt;} \\{1;2;3\\} = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n1 & 0 & 0 \\\\\n1 & 1 & 0\n\\end{bmatrix}\n\n\n\nWeil das äussere Produkt beliebige Operatoren erlaubt, lassen sich mit der gleichen Technik wie für die Dreiecks-Matrix auch andere Strukturen systematisch erzeugen. Falls dabei komplexe logische Ausdrücke verwendet werden, ist es sinnvoll, diese in einer Funktion zu kapseln.\n\n\nBeispiel 14.14 (Eine komplexe Struktur mit dem äusseren Produkt erzeugen.) Es soll eine 6 \\times 6-Matrix erzeugt werden, die entlang Hauptdiagonalen und der direkt benachbarten Nebendiagonalen den Wert 1 enthält. Alle anderen Werte sollen 0 sein.\nDazu wird Sequenz der Länge 6 als Basis für das äussere Produkt verwendet.\n\n\\{1;2;3;4;5;6\\}\n\nWeil diese Struktur nicht durch einen direkten Vergleich erzeugt werden kann, wird eine Funktion f für den logischen Ausdruch erstellt. Daraus ergibt sich das folgende äussere Produkt.\n\n\\{1;2;3;4;5;6\\} \\otimes_{f} \\{1;2;3;4;5;6\\}\n\nUm die gewünschte Struktur zu erzeugen, bedarf es eines komplexen logischen Ausdrucks mit zwei Vergleichen. Zum einen muss für die Struktur der eine Index kleiner oder gleich dem um eins erhöhten anderen Index sein. Zum anderen darf die Differenz zwischen den beiden Indizes nicht grösser als eins sein. Daraus ergibt sich die folgende Definition für die Funktion f.\n\nf(i, j) \\to (i \\le j+1) \\land (j - i \\le 1)\n\nDas Ergebnis des äusseren Produkts mit dieser Funktion als Operator ist die gewünschte Matrix.\n\n\\begin{bmatrix}\n1 &  1 &  0 &  0 &  0 &  0 \\\\\n1 &  1 &  1 &  0 &  0 &  0 \\\\\n0 &  1 &  1 &  1 &  0 &  0 \\\\\n0 &  0 &  1 &  1 &  1 &  0\\\\\n0 &  0 &  0 &  1 &  1 &  1 \\\\\n0 &  0 &  0 &  0 &  1 &  1\n\\end{bmatrix}\n\n\n\nDas äussere Produkt erlaubt beliebige Operatoren für die Multiplikation und ist deshalb sehr flexibel. Weil Operatoren nur spezielle Funktionen sind, lassen sich komplexe Operatoren z.B. mittels logischer Ausdrücke erzeugen.\n\n\nBeispiel 14.15 (Werte in einem Vektor markieren) Häufig ist es notwendig, bestimmte Werte in einem Vektor zu markieren, damit sie von nachfolgenden Matrix-Operationen berücksichtigt werden können. Ein typisches Beispiel für solche Markierungen ist das Markieren der einzelnen Werte eines diskreten Wertebereichs.\nDazu wird zuerst ein Hilfsvektor erstellt, der alle (vorkommenden) Werte des Wertebereichs enthält. Anschliessend wird das äussere Produkt zwischen dem originalen Vektor und dem Hilfsvektor mit einem Vergleichsoperator durchgeführt.\nHier soll der Wertebereich die Werte 1 bis 5 enthalten. Daraus ergibt sich der Hilfsvektor v_h = \\{1;2;3;4;5\\}. Der Vektor v soll markiert werden. Dieser Vektor enthält die Werte \\{1;3; 2; 3; 4; 5; 3; 2; 4; 4; 5; 1; 4\\}.\nAls Vergleichsoperator wird die Gleichheit verwendet, um die Werte zu markieren. Das Ergebnis ist die folgende Matrix.\n\nv \\otimes_{=} v_h = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1 \\\\\n1 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0\n\\end{bmatrix}\n\nNun lässt sich bspw. die Spaltensumme entsprechend von Beispiel 14.9 mithilfe eines Einsvektors v_1 der Länge 13 berechnen, um die Häufigkeit der einzelnen Werte zu bestimmen.\n\nv_1 \\times \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1 \\\\\n1 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0\n\\end{bmatrix} = \\begin{bmatrix} 2 & 2 & 3 & 4 & 2 \\end{bmatrix}"
  },
  {
    "objectID": "kapitel/10-matrix-operationen/kapitel.html#co-occurence-matrizen-erzeugen",
    "href": "kapitel/10-matrix-operationen/kapitel.html#co-occurence-matrizen-erzeugen",
    "title": "14  Matrix-Operationen",
    "section": "14.7 Co-Occurence-Matrizen erzeugen",
    "text": "14.7 Co-Occurence-Matrizen erzeugen\nCo-Occurance Matrizen helfen beim Feststellen der Häufigkeiten des gemeinsamen Auftretens von Werten in zwei Vektoren. Das Ergebnis zeigt an den einzelnen Positionen jeweils die Anzahl steht mit der die korrespondierenden Werte der jeweiligen Spalte bzw. Zeilen gleichzeitig vorkommen. Bei der Erstellung einer Co-Occurrence-Matrix müssen zuerst die zählbaren Elemente identifiziert werden. Das wird durch das äussere Produkt erreicht. Das erfolgt in drei Schritten.\n\nEs werden zwei Vektoren erstellt, in dem die Werte aus den Vektoren genau einmal vorkommen.\nEs werden zwei Matrizen über das äussere Produkt des jeweiligen original Vektors und dem zugehörigen eindeutigen Vektor aus Schritt 1 erstellt. Der Operator für das äussere Produkt ist in diesem Fall der Gleichheitsoperator.\nMit den beiden Matrizen aus Schritt 2 wird das Kreuzprodukt gebildet. Dazu muss eine der beiden Matrizen transponiert werden. Dieses Kreuzprodukt ist immer zulässig, weil beide Matrizen die gleiche Anzahl an Zeilen haben, wenn sie aus dem gleichen Datenrahmen gebildet wurden.\n\nDie Schritte 1 und 2 sind eine direkte Anwendung von Beispiel 14.15.\nDas Ergebnis ist eine Matrix mit der Anzahl der gemeinsamen Vorkommen der Werte aus den beiden eindeutigen Vektoren aus Schritt ein. Die Werte lassen sich über das Kreuzprodukt zuordnen:\n\nDie Spalten entsprechen den eindeutigen Werten der linken (nicht transponierten) Matrix.\nDie Zeilen entsprechen den eindeutigen Werten der rechten (transponierten) Matrix.\n\nAlternativ zur Position der Werte kann auch ein Sekundärindex (s.Kapitel 16) für das äussere Produkt verwendet werden.\nEine Co-occurance-Matrix ist immer symmetrisch. Durch eine Skalarmultiplikation mit einer Dreiecks-Matrix aus Beispiel 14.13 kann die Matrix in eine untere oder obere Dreiecksmatrix umgewandelt werden."
  },
  {
    "objectID": "kapitel/11-daten-kodieren/kapitel.html#kombinieren",
    "href": "kapitel/11-daten-kodieren/kapitel.html#kombinieren",
    "title": "15  Daten kombinieren und kodieren",
    "section": "15.1 Kombinieren",
    "text": "15.1 Kombinieren\n\nDefinition 15.1 Kombinieren von Daten bedeutet die Verknüpfung von Daten aus verschiedenen Quellen zu einer Datenstruktur.\n\nBeim Kombinieren von Daten werden die Daten aus verschiedenen Quellen zu einer gemeinsamen Datenstruktur zusammengeführt. Es gibt verschiedene Arten von Kombinationen, die sich in der Art der Verknüpfung unterscheiden.\n\n15.1.1 Kombinationsarten\n\nZeilenweise Konkatenation\n\nBei der Konkatenation wird davon ausgegangen, dass beide Quellen genau die gleichen Merkmale haben. Die Daten werden dann einfach aneinandergehängt. Die Reihenfolge der Datensätze bleibt dabei erhalten.\n\nVereinigung (union/ outer join)\n\nBei der Vereinigung werden alle Werte aus beiden Quellen über ein gemeinsames Merkmal kombiniert. Das Ergebnis enthält anschliessend Datensätze mit allen Merkmalen aus beiden Quellen. Gibt es für Datensätze in einer Quelle keine Entsprechung in der anderen, werden die fehlenden Werte mit einem speziellen Wert (z.B. undefinierte Werte) aufgefüllt.\n\nspaltenkonkatenation ist eine spezielle Form der Vereinigung\n\nFür eine Spaltenkonkatenation müssen beide Stichproben den gleichen Umfang haben. Meistens fehlen jedoch gemeinsame Merkmale für die Vereinigung. In diesem Fall wird die Vereinigung über einen gedachten Wert durchgeführt. Dazu werden alle Datensätze in beiden Quellen durchnummeriert. Diese Nummer wird dann als gemeinsames Merkmal verwendet. Anschliessend wird die Nummerierung aus dem Ergebnis entfernt.\n\npartielle Vereinigung (partial union)\n\nDie partielle Vereinigung kombiniert nur Werte, die in beiden Quelle ein gemeinsames Merkmal teilen. Das Ergebnis enthält anschliessend nur noch Datensätze mit allen Merkmalen aus beider Quellen für die es eine Entsprechung für die gemeinsamen Merkmale gibt.\n\nSchnittmenge (intersection/inner join)\n\nDie Schnittmenge kombiniert nur Werte, die in beiden Quellen vorkommen. Die Schnittmenge ist also eine Teilmenge der Vereinigung.\n\nDifferenz (difference)\n\nBei der Differenz werden alle Datensätze mit einer Entsprechung von gemeinsamen Merkmalen in beiden Quellen aus dem Ergebnis entfernt. Das Ergebnis umfasst also nur Datensätze, die in der ersten Quelle vorkommen, aber nicht in der zweiten Quelle.\nDie Differenz entspricht einen Filter mit einem oder mehreren \\notin-Vergleichen."
  },
  {
    "objectID": "kapitel/11-daten-kodieren/kapitel.html#kodieren",
    "href": "kapitel/11-daten-kodieren/kapitel.html#kodieren",
    "title": "15  Daten kombinieren und kodieren",
    "section": "15.2 Kodieren",
    "text": "15.2 Kodieren\n\nDefinition 15.2 Kodieren von Daten bedeutet die Umwandlung von Daten in ein anderes Format oder einen anderen Wertebereich.\n\nBeim Kodieren wird eine Kodierungsfunktion verwendet, die jeden Wert des urspünglichen Wertebereichs einem Wert des gewünschten Wertebereichs zuordnet. Dabei ist es nicht notwendig, dass alle ursprünglichen Werte eindeutig zugewiesen werden. Das heisst, dass mehrere Werte des ursprünglichen Wertebereichs dem gleichen Wert des neuen Wertebereichs zugeordnet werden können.\nSehr häufig werden Kodierungsfunktionen als Entscheidungsbäume (s. Definition 12.3) umgesetzt. Dabei werden logische Ausdrücke für die Zuweisung der Ergebniswerte verwendet. Die logischen Ausdrücke werden dabei der Reihe nach geprüft. Die erste zutreffende Entscheidung, bestimmt den Ergebniswert.\n\n15.2.1 Kodierungstabellen\nEine besondere Technik des Kodierens ist die Verwendung von Kodierungstabellen.\n\nDefinition 15.3 Eine Kodierungstabelle ist eine Tabelle, die jedem Wert eines Wertebereichs einen Wert eines anderen Wertebereichs zuordnet.\n\nDie Kodierungsfunktion ist in diesem Fall die Vereinigung oder eine partielle Vereinigung der Stichprobe mit der Kodierungstabelle.\n\n\n\n\n\n\nPraxis\n\n\n\nKodierungstabellen sollten immer für die Kodierung von nominal- oder ordinalskalierten Wertebereichen verwendet werden, weil sie die Kodierungsfunktion explizit machen und gleichzeitig die Kodierung dokumentieren."
  },
  {
    "objectID": "kapitel/11-indizieren-gruppieren/kapitel.html#indizieren",
    "href": "kapitel/11-indizieren-gruppieren/kapitel.html#indizieren",
    "title": "16  Indizieren und Gruppieren",
    "section": "16.1 Indizieren",
    "text": "16.1 Indizieren\n\nDefinition: Mit Indizieren wird die Arbeitsweise von Algorithmen bezeichnet, mit der Datensätze identifiziert werden.\n\n\nDefinition: Ein Index bezeichnet Werte, mit denen sich ein oder mehrere Datensätze von anderen Datensätzen unterscheiden lassen.\n\nEs werden drei Arten von Indizes unterschieden:\n\nDer Primärindex, mit dem ein einzelner Datensatz eindeutig identifiziert werden kann.\nSekundärindizes erlauben Querverweise auf eine zweite Stichprobe (eine sog. Indextabelle oder engl. Lookup-Table).\nSekundärindizes erlauben die Identifikation von Datensätzen mit gemeinsamen Eigenschaften. Diese Indizes werden auch als Gruppenindex bezeichnet.\n\nWeil ein Index Werte über einen Datensatz enthält, gehört ein Index zum jeweiligen Datensatz und wird über einen Indexvektor in einer Stichprobe abgebildet.\n\nDefinition: Ein Indexvektor bezeichnet einen Vektor, mit dessen Werten Datensätze identifiziert werden können.\n\nDefinition: Ein Hash bezeichnet einen Wert in einem Indexvektor.\n\n16.1.1 Existierende Indexvektoren.\nHäufig liegen Indexvektoren bereits in einer Stichprobe vor.\n\n16.1.1.1 Beispiel bestehende Primär- und Sekundärindizes\nmtcars %&gt;% \n    as_tibble(rownames = \"modell\")  -&gt; mtcarStichprobe\n\nmtcarStichprobe\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodell\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\nValiant\n18.1\n6\n225.0\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\nDuster 360\n14.3\n8\n360.0\n245\n3.21\n3.570\n15.84\n0\n0\n3\n4\n\n\nMerc 240D\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n\n\nMerc 230\n22.8\n4\n140.8\n95\n3.92\n3.150\n22.90\n1\n0\n4\n2\n\n\nMerc 280\n19.2\n6\n167.6\n123\n3.92\n3.440\n18.30\n1\n0\n4\n4\n\n\nMerc 280C\n17.8\n6\n167.6\n123\n3.92\n3.440\n18.90\n1\n0\n4\n4\n\n\nMerc 450SE\n16.4\n8\n275.8\n180\n3.07\n4.070\n17.40\n0\n0\n3\n3\n\n\nMerc 450SL\n17.3\n8\n275.8\n180\n3.07\n3.730\n17.60\n0\n0\n3\n3\n\n\nMerc 450SLC\n15.2\n8\n275.8\n180\n3.07\n3.780\n18.00\n0\n0\n3\n3\n\n\nCadillac Fleetwood\n10.4\n8\n472.0\n205\n2.93\n5.250\n17.98\n0\n0\n3\n4\n\n\nLincoln Continental\n10.4\n8\n460.0\n215\n3.00\n5.424\n17.82\n0\n0\n3\n4\n\n\nChrysler Imperial\n14.7\n8\n440.0\n230\n3.23\n5.345\n17.42\n0\n0\n3\n4\n\n\nFiat 128\n32.4\n4\n78.7\n66\n4.08\n2.200\n19.47\n1\n1\n4\n1\n\n\nHonda Civic\n30.4\n4\n75.7\n52\n4.93\n1.615\n18.52\n1\n1\n4\n2\n\n\nToyota Corolla\n33.9\n4\n71.1\n65\n4.22\n1.835\n19.90\n1\n1\n4\n1\n\n\nToyota Corona\n21.5\n4\n120.1\n97\n3.70\n2.465\n20.01\n1\n0\n3\n1\n\n\nDodge Challenger\n15.5\n8\n318.0\n150\n2.76\n3.520\n16.87\n0\n0\n3\n2\n\n\nAMC Javelin\n15.2\n8\n304.0\n150\n3.15\n3.435\n17.30\n0\n0\n3\n2\n\n\nCamaro Z28\n13.3\n8\n350.0\n245\n3.73\n3.840\n15.41\n0\n0\n3\n4\n\n\nPontiac Firebird\n19.2\n8\n400.0\n175\n3.08\n3.845\n17.05\n0\n0\n3\n2\n\n\nFiat X1-9\n27.3\n4\n79.0\n66\n4.08\n1.935\n18.90\n1\n1\n4\n1\n\n\nPorsche 914-2\n26.0\n4\n120.3\n91\n4.43\n2.140\n16.70\n0\n1\n5\n2\n\n\nLotus Europa\n30.4\n4\n95.1\n113\n3.77\n1.513\n16.90\n1\n1\n5\n2\n\n\nFord Pantera L\n15.8\n8\n351.0\n264\n4.22\n3.170\n14.50\n0\n1\n5\n4\n\n\nFerrari Dino\n19.7\n6\n145.0\n175\n3.62\n2.770\n15.50\n0\n1\n5\n6\n\n\nMaserati Bora\n15.0\n8\n301.0\n335\n3.54\n3.570\n14.60\n0\n1\n5\n8\n\n\nVolvo 142E\n21.4\n4\n121.0\n109\n4.11\n2.780\n18.60\n1\n1\n4\n2\n\n\n\nDer Vektor modell ist der Primärindex, weil dieser Vektor nur Werte enthält, die einen Datensatz eindeutig identifizieren.\nDie Vektoren cyl (Zylinder), vs (Motortyp), am (Automatikschaltung), gear (Anzahl der Gänge), carb (Anzahl der Vergaser) sind Sekundärindizes und Gruppenindizes, die Modelle nach verschiedenen Kriterien zusammenfassen.\n\n\n\n16.1.2 Fehlende Indexvektoren\nGelegentlich liegen in einer Stichprobe keine Primär- oder Sekundärindizes vor oder die vorhandenen Indizes erlauben keine Zusammenfassungen für eine konkrete Fragestellung. In solchen Fällen muss ein entsprechender Index erzeugt werden.\n\nDefinition: Eine Funktion, die Hashes für Indexvektoren erzeugt, heisst Hashing-Funktion.\n\n\nHashing-Funktionen werden in der Industrie als Unterstützung zur Suche von Datensätzen in Datenbanken eingesetzt. Durch die geschickte Berechnung von Hashes beschleunigen diese Funktionen die Suche einzelner Werte um ein Vielfaches, indem sie den Bereich für die Suche einschränken. Deshalb haben viele Hashing-Funktionen ein anderes Anwendungsziel als die hier beschriebenen Hashing-Funktionen.\n\n\n\n16.1.3 Hashing zur Identifikation\nDie einfachste Technik zur eindeutigen Indizierung ist das Durchnummerieren der Datensätze einer Stichprobe. Bei dieser Technik wird jedem Datensatz eine Nummer zugewiesen. In R verwenden wir dazu die Funktion row_number(). Diese Funktion ist einer Sequenz vorzuziehen, weil diese Funktion auch bei leeren Stichproben fehlerfrei arbeitet.\nIn Excel muss zum Durchnummerieren die SEQUENZ()-Funktion verwendet werden. Das erreichen wir mit der folgenden Operation: =SEQUENZ(ZEILEN(StichprobenBereich)), wobei StichprobenBereich eine Excel-Adresse sein muss. Weil mit Excel keine leeren Stichproben erzeugt werden dürfen, gibt es mit Excel nicht das gleiche Problem wie mit R. Wegen dieser Eigenschaft muss ein entsprechender Bereich mindestens einen Stichprobenumfang von eins haben. Diese Eigenschaft gilt auch für Tabellen, die nur aus Überschriften bestehen.\n\nFingerübung: Nummerieren Sie die Stichprobe mtcars und speichern Sie die Nummern im Vektor nr.\n\n\n\n16.1.4 Hashing zum Gruppieren\nBeim Hashing zum Gruppieren müssen wir Werte erzeugen, die eine Zuordnung zu einer Gruppe oder einen Wert in einer anderen Stichprobe ermöglichen. Die Hashing-Funktion orientiert sich dabei an den konkreten Analyseanforderungen.\nVier gängige Techniken können dabei unterschieden werden:\n\nKodieren (alle Datentypen)\nReihenfolgen bilden durch Ganzzahldivision (nur Zahlen)\nReihenfolgen bilden durch Modulo-Operation (nur Zahlen)\nReihenfolgen durch Anfangsbuchstaben (nur Zeichenketten)\n\n\n16.1.4.1 Beispiel Hashing zum Gruppieren.\nDas folgende Beispiel bildet einen Index, um die Motorisierung der Fahrzeugtypen in der Stichprobe mtcars zu bestimmen. Dabei sollen die Modelle in schwach-, mittel-, stark- und sehr starkmotorisierte Typen unterschieden werden. Die Motorisierung richtet sich dabei zum einen nach der Leistung (hp). Zum anderen richtet sich die Motorisierung nach dem Fahrzeuggewicht (wt), weil für ein schweres Fahrzeug mehr Leistung zum Bewegen benötigt wird als für ein leichtes. Um beide Werte zu berücksichtigen, wird das Verhältnis der beiden Werte bestimmt. Ein Verhältnis ist eine Division. In diesem Fall wird das Gewicht als Nenner verwendet und die Leistung als Zähler. So ergeben sich immer Werte grösser als 1, weil die Leistung immer viel grösser als das Gewicht ist.\nIn diesem Beispiel besteht die Hashing-Funktion aus zwei Teilen:\n\nDas Verhältnis zwischen Leistung und Gewicht wird bestimmt und im Vektor verhaeltnis abgelegt.\nDie Leistungsklassen werden durch Kodieren den oben festgelegten Klassen zugewiesen und im Vektor klasse gespeichert.\n\nmtcars %&gt;% \n    as_tibble(rownames = \"modell\") %&gt;% \n    mutate(\n        verhaeltnis = hp/wt, \n        klasse = case_when( \n            verhaeltnis &gt; 60 ~ \"sehr stark\",\n            verhaeltnis &gt; 50 ~ \"stark\", \n            verhaeltnis &gt; 40 ~ \"mittel\", \n            TRUE ~ \"schwach\") \n    )\n\nFingerübung: Bestimmen Sie die Effizienz der Modelle in mtcars indem Sie den Verbrauch (mpg) und den Hubraum (disp) berücksichtigen. Legen Sie Effizienzklassen fest.\n\n\n\n\n16.1.5 Hashing für Querverweise\nBeim Hashing für Querverweise gibt es zwei Stichproben. Die erste Stichprobe ist die Hauptstichprobe mit den eigentlichen Werten. Die zweite Stichprobe ist die Referenzstichprobe, die zusätzliche Informationen enthält. Ein Indexvektor für Querverweise in der ersten Stichprobe bezieht sich immer auf einen Primärindex aus der zweiten Stichprobe.\nDie Hashing-Funktion muss deshalb einen Verweis zur zweiten Stichprobe herstellen. Diese Verbindung kann mit der gleichen Strategie erzeugt werden, wie beim Gruppieren. Dabei muss jedoch darauf geachtet werden, dass alle Zuordnungen des Primärvektors korrekt abgebildet sind."
  },
  {
    "objectID": "kapitel/11-indizieren-gruppieren/kapitel.html#datensätze-randomisieren",
    "href": "kapitel/11-indizieren-gruppieren/kapitel.html#datensätze-randomisieren",
    "title": "16  Indizieren und Gruppieren",
    "section": "16.2 Datensätze randomisieren",
    "text": "16.2 Datensätze randomisieren\nWenn wir mit Teilstichproben arbeiten und diese mit anderen teilen, müssen wir vermeiden, dass zwei Stichproben leicht zusammengesetzt werden können und so Rückschlüsse über die Probanden möglich werden.\n\nSobald personenbezogene Daten statistisch ausgewertet und zur Publikation vorbereitet werden, müssen die Daten randomisiert werden!\nDieses kleine Rezept beschreibt eine Technik zur Anonymisierung von Daten durch Mischen. Entscheidend bei dieser Technik ist, dass wir die Werte für unsere Analyse zusammenhalten möchten, sodass unsere Ergebnisse nachvollziehbar bleiben. Gleichzeitig soll es unmöglich werden, diese Daten mit anderen Teilen unserer Studien in Verbindung zu bringen.\nDie Technik der Anonymisierung durch Mischen besteht aus vier Schritten:\n\nAuswahl der Vektoren, die wir in einer Publikation teilen möchten,\nErzeugung eines eindeutigen Vektors,\nzufälliges Mischen,\nEntfernen der eindeutigen Vektoren und exportieren der Daten.\n\n\n16.2.0.1 Schritt 1: Auswahl der Vektoren\nWie üblich wählen wir die Vektoren mit der select()-Funktion aus.\n\n\n16.2.0.2 Schritt 2: Erzeugung eines eindeutigen Vektors\nAlle unsere Werte müssen zusammengehalten werden, weil unsere Analyse sonst nicht mehr nachvollziehbar ist. Wir nummerieren dazu unsere Datensätze durch.\n\n\n16.2.0.3 Schritt 3: Mischen\nDieser Schritt greift auf die Funktion sample() zurück. Wir erzeugen aus den ursprünglichen Nummerierungen eine neue Nummerierung durch daten %&gt;% mutate( id_neu = sample(id) ). Nach dieser neuen Nummerierung sind unsere Datensätze aber immer noch in der gleichen Reihenfolge und noch nicht gemischt. Wir müssen also die Reihenfolge so anpassen, dass die neue Nummerierung gilt. Das erreichen wir mit dem Funktionsaufruf daten %&gt;% arrange( id_neu ).\n\n\n16.2.0.4 Schritt 4: Entfernen des eindeutigen Vektors und exportieren der Daten\nAbschliessend müssen wir unbedingt die beiden Hilfsvektoren, die wir zum Mischen verwendet haben, aus unserer Stichprobe wieder entfernen. Das erreichen wir mit einer Vektorauswahl: daten %&gt;% select(-c(id, id_neu)).\n\n\n16.2.0.5 Vollständige Lösung\nWir greifen hier auf eine Stichprobe zurück, die Geschlechtsinformationen, Alter und digitale Nutzungsgewohnheiten umfasst. Wir erstellen zwei getrennte Teilstichproben, von denen eine nur die Nutzungsgewohnheiten und das Geschlecht und eine nur die Nutzungsgewohnheiten und das Alter beinhaltet.\n[fa-download] beispielstichprobe.csv\n\nSie müssen die Datei vor dem Einlesen noch in beispielstichprobe.csv umbenennen.\ndaten = read_delim(\"beispielstichprobe.csv\")\n\n# mischen Funktion aus einer Funktionskette erstellen, damit \n#    wir nicht so viel tippen müssen.\nmischen = . %&gt;% \n    mutate( \n        id = row_number(), \n        id_neu = sample(id)\n    ) %&gt;% \n    arrange(id_neu) %&gt;% \n    select(-c(id, id_neu))\n\ndaten %&gt;% \n    select(geschlecht, starts_with(\"technik\")) %&gt;% \n    mischen() %&gt;% \n    write_csv(\"teilstichprobe_geschlecht_technik.csv\")\n\ndaten %&gt;% \n    select(alter, starts_with(\"sozial\")) %&gt;% \n    mischen() %&gt;% \n    write_csv(\"teilstichprobe_alter_sozial.csv\")\nDie zwei Teilstichproben lassen sich nicht mehr zusammenführen. Damit erkennen wir auch die Grenzen dieser Technik: Wenn zwei gemischte Stichproben ausreichend viele gemeinsame oder sehr detaillierte Vektoren haben, die in beiden Teilstichproben vorkommen, dann können diese Stichproben trotz mischen wieder zusammengeführt werden.\nMit den gemischten Daten ist es nun nicht mehr möglich, die Werte mit einem anderen Teil der Stichprobe zu kombinieren und so tiefere Rückschlüsse über die Teilnehmenden (womöglich unwissend) zuzulassen. Nur noch durch den Zugriff auf die ursprünglichen Daten können diese Zusammenhänge hergestellt werden. Daher sind die ursprünglichen Daten oft besonders schützenswert und sollten ohne Randomisierung nicht weitergegeben werden."
  },
  {
    "objectID": "kapitel/12-daten-formen/kapitel.html#pivot",
    "href": "kapitel/12-daten-formen/kapitel.html#pivot",
    "title": "17  Daten formen",
    "section": "17.1 Pivot",
    "text": "17.1 Pivot"
  },
  {
    "objectID": "kapitel/12-daten-formen/kapitel.html#nest---einbetten",
    "href": "kapitel/12-daten-formen/kapitel.html#nest---einbetten",
    "title": "17  Daten formen",
    "section": "17.2 Nest - Einbetten",
    "text": "17.2 Nest - Einbetten\nDas Einbetten von Daten ist eine wichtige Operation, um Daten zu strukturieren und zu organisieren. Es bildet die Grundlage für komplexe Datenstrukturen mit baumartigen Strukturen (s. Kapitel 9.5)."
  },
  {
    "objectID": "kapitel/13-daten-beschreiben/kapitel.html#universelle-kennzahlen",
    "href": "kapitel/13-daten-beschreiben/kapitel.html#universelle-kennzahlen",
    "title": "18  Daten beschreiben",
    "section": "18.1 Universelle Kennzahlen",
    "text": "18.1 Universelle Kennzahlen\nWir haben das Zählen mit R und Excel kennengelernt. Diese Operation wenden wir an, um die zwei universellen Kennzahlen von Stichproben zu bestimmen.\n\nDefinition: Mit universellen Kennzahlen sind abgeleitete Werte gemeint, die wir für alle Stichproben bestimmen können.\n\nDie beiden universellen Kennzahlen für Stichproben sind:\n\nDer Stichprobenumfang, d.h. die Anzahl der Datensätze\nDie Anzahl der Variablen\n\n\nWir erkennen sofort, dass es sich bei der Bestimmung der beiden Kennwerte um ein (Ab-) Zählproblem handelt.\n\n\nIn jeder wissenschaftlichen Arbeit, in der Sie Daten präsentieren, müssen Sie immer die beiden Kennwerte angeben.\n\nFür die Anzahl der Variablen könnten wir im Prinzip auf die Dokumentation einer Stichprobe zurückgreifen. Wir bestimmen trotzdem beide Kennzahlen, um sicherzustellen, dass wir wirklich alle Variablen in einer Stichprobe berichten und nicht versehentlich Variablen unterschlagen, die in der Dokumentation nur implizit festgehalten werden.\n\nKonvention: Stichprobenumfänge werden in wissenschaftlichen Arbeiten mit dem Buchstaben n gekennzeichnet.\n\n\nKonvention: In Fragebogenstudien wird die Anzahl der Vektoren als Anzahl der Items bezeichnet. Damit sind die unabhängig festgehaltenen Antwortmöglichkeiten gemeint.\n\n\nKonvention: In technischen Studien wird die Anzahl der Vektoren als Anzahl der Parameter, Vektoren oder Variablen bezeichnet. Damit sind die unabhängigen, gemessenen Werte gemeint.\n\nBei beiden Kennzahlen müssen wir eine Anzahl bestimmen. Beim Stichprobenumfang bestimmen wir die Anzahl der Datensätze. Für die Anzahl der Variablen müssen wir die Vektoren zählen.\n\nMerke: Stichprobenobjekte sind immer rechteckig. Alle Variablen sind immer in allen Datensätzen vorhanden (horizontaler Umfang) und alle Datensätze haben für jede Variable einen Wert (vertikaler Umfang). Wir erhalten die Kennwerte, indem wir horizontal und vertikal zählen.\n\n\n\nDie Aufgabe der Deskriptivstatistik ist es, Daten prägnant zusammenzufassen.\nSauer, 2019, S. 103.\n\nDie deskriptive Statistik wird oft mit wenigen Sätzen in der Literatur abgehandelt und auf die folgenden Punkte beschränkt.\n\nUmfang\nSkalenniveau\nLagemasse\n\nDas Zitat von Bortz & Schuster deutet bereits an, dass jeder schliessenden Statistik eine Stichprobenbeschrreibung mit Hilfe beschreibender Kennwerte vorangehen muss. Dabei müssen wir für die Beschreibung angemessene Lagemasse für das jeweilige Skalenniveau einer Variable wählen. Hier müssen wir etwas aufpassen und zwischen drei Arten von Vektoren in unseren Stichprobendaten unterscheiden:\n\nKonstanten\nIndikatoren\nVariablen\n\n\nNur die Variablenvektoren können unsere Stichprobe beschreiben, weil Sie gemessene Merkmalsausprägungen unser Entitäten enthalten.\n\nIm folgenden arbeiten wir mit einer Beispielstichprobe. Diese Stichprobe ist ein Ausschnitt aus einer Studie zur Relevanz von digitalen Kompetenzen bei Dozierenden während des ersten COVID-Lockdowns im FS2020."
  },
  {
    "objectID": "kapitel/13-daten-beschreiben/kapitel.html#umfang",
    "href": "kapitel/13-daten-beschreiben/kapitel.html#umfang",
    "title": "18  Daten beschreiben",
    "section": "18.2 Umfang",
    "text": "18.2 Umfang\nMit dem Umfang einer Stichprobe meinen wir die Anzahl der Entitäten, die wir gemessen haben. In R ergibt sich dieser Wert direkt aus dem Stichprobenobjekt: Der Stichprobenumfang entspricht der Anzahl der Datensätze in unserem Stichprobenobjekt. Diese Anzahl bestimmen wir mit Hilfe der count()-Funktion oder innerrhalb einer Transforrmation mit mutate() mit Hilfe der n()-Funktion.\nDer Stichprobenumfang ist einer der drei allgemeinen Kennwerte, die jede Stichprobe beschreiben. Wir bestimmen zuerst die numerischen Kennwerte unserer Beispielstichprobe.\n# Stichprobenumfang\nstichprobe %&gt;% \n    count() %&gt;% \n    pull() -&gt; stichprobenumfang\n\nstichprobenumfang\n\nstichprobe %&gt;% \n    names() %&gt;% \n    length()\nDabei erkennen wir, dass der Stichprobenumfang 27 beträgt. Wir erkennen zusätzlich, dass wir 53 Vektoren in unserem Stichprobenobjekt vorliegen haben.\nNeben dem Stichprobenumfang unterscheiden wir zusätzlich den Variablenumfang. Der Variablenumfang bezeichnet die Anzahl der gemessenen Merkmalsausprägungen. Damit ist die Gesamtzahl der gemessenen Werte für eine Variable gemeint. Für diesen Wert müssen wir für eine Variable nicht vorhandene Werte aus der Variable entfernen. Diese Werte sind in R mit dem Wert NA gekennzeichnet. Wir entfernen die NA-Werte mit Hilfe der drop_na()-Funktion.\nEs ist normal, dass sich der Stichprobenumfang und die Variablenumfänge unterscheiden. Diese Unterschiede entstehen dadurch, dass nicht alle Messungen erfolgreich verlaufen. Zum Beispiel passiert es häufig, dass Teilnehmende bei einem Fragebogen nicht alle Fragen beantworten oder beantworten können. In solchen Fällen ist der Stichprobenumfang grösser als die jeweiligen Variablenumfänge. So kommt es regelmässig vor, dass verschiedene Variablenumfänge sich ebenfalls unterscheiden.\nDie deskriptive Statistik muss daher immer den Stichprobenumfang und die Variablenumfänge anführen."
  },
  {
    "objectID": "kapitel/13-daten-beschreiben/kapitel.html#skalenniveaus-und-lagemasse",
    "href": "kapitel/13-daten-beschreiben/kapitel.html#skalenniveaus-und-lagemasse",
    "title": "18  Daten beschreiben",
    "section": "18.3 Skalenniveaus und Lagemasse",
    "text": "18.3 Skalenniveaus und Lagemasse\nFür Variablen unterscheiden wir nur die folgenden Skalenniveaus:\n\nNominal\nOrdinal\nMetrisch (Intervall- oder Varianzskaliert)\n\nDie Skalenniveaus unserer Variablen müssen wir den Vektoren zuordnen können. Dazu müssen wir sowohl die Variablen und Vektoren unserer Stichprobe kennen. Diese Information erschliesst sich nicht aus den Daten, sondern ist in der Regel separat dokumentiert.\nUnsere Beispielstichprobe hat 53 Vektoren. Diese Vektoren sind vier Variablengruppen zugeordnet. Eine Variablengruppe sind unterschiedliche Merkmalsausprägungen mit dem gleichen Skalennivau, die wir in Beziehung setzen. Das Beispiel umfasst die folgenden Variablengruppen und Skalenniveaus:\n\nq1 ist ein Indikator\nq3, q4 und q16 sind nominalskalierte Variablen\n\n\nq3 hat die Skalierung von F, M, X und O.\nq4 hat die Skalierung von A, G, L, N, P, S, T und W.\nq16 hat die Skalierung von 0 und 1.\n\n\nq10 sind ordinalskalierte Variablen mit der Skalierung von 0-10 in ganzzahligen Schritten. Die Messungen stammen von sog. Likert-Skalen.\n\n\nPraxis: Bestimmen Sie alle Vektorennamen in der Beispielstichprobe.\n\nFür die Variable q10 es 6 Untermerkmale und für die Variable q16 gibt es 19 Untermerkmale. Für alle Merkmale in q10 und q16 wurden jeweils zwei Aspekte (0 und 1) erhoben. Diese Aspekte können für das jeweilige Untermerkmal direkt verglichen werden. Wir haben also im Vektor q16_13_1 den zweiten Aspekt des 13. Untermerkmals der Variable q16 erfasst.\n\n18.3.1 Lagemasse für nominale Skalenniveaus\nFür nominale Variablen dürfen wir als Lagemass für die Verteilung nur den Modus bestimmen. Damit ist die am häufigsten auftretende Merkmalsausprägung gemeint.\nDas zweite “Lagemass” sind die tatsächlich auftretenden Skalenwerte.\nBeide Kennwerte erschliessen sich über die Häufigkeiten der vorkommenden Werte. Dazu bestimmen wir die Häufigkeit des Auftretens einer Merkmalsausprägung in unserer Stichprobe. Das bestimmen der Häufigkeiten ist eine Abzählaufgabe, bei der wir vorher die gleichen Merkmalsausprägungen gruppiert haben.\nDas folgende Beispiel zwei Varianten für das Feststellen der Häufigkeiten von nominalskalierten Variablen. Die erste Variante ist die direkte Umsetzung des gerade beschriebenen Algorithmus.\nstichprobe %&gt;% \n    group_by(q3) %&gt;% \n    summarise(n = n())\n\n\n\n\n\nq3\n\n\nn\n\n\n\n\n&lt;chr&gt;\n\n\n&lt;int&gt;\n\n\n\n\n\n\nF\n\n\n10\n\n\n\n\nM\n\n\n17\n\n\n\n\n\nDie zweite Variante verwendet die count()-Funktion, um das gleiche Ziel zu erreichen. Die Variante mit count() ist etwas leichter zu lesen, weil wir explizit klarstellen, dass wir die Merkmalsausprägungen abzählen.\nstichprobe %&gt;% \n    count(q4)\n\n\n\n\n\nq4\n\n\nn\n\n\n\n\n&lt;chr&gt;\n\n\n&lt;int&gt;\n\n\n\n\n\n\nN\n\n\n17\n\n\n\n\nP\n\n\n10\n\n\n\n\n\nWir können an diesem Beispiel erkennen, dass in unserer Stichprobe nicht alle Ausprägungen der jeweiligen Skalierung in unseren Variablen vorkommen. Uns fällt auch auf, dass die Häufigkeiten für die gemessenen Merkmalsausprägungen der Variablen gleich sind.\nNeben den absoluten Häufigkeiten interessieren uns ebenfalls die relativen Häufigkeiten. Diese müssen bei der Beschreibung von nominalskalierten Variablen mit angegeben werden.\nRelative Häufigkeiten sind nichts anderes als die prozentualen Anteile der absouluten Häufigkeit in der Gesamtstichprobe. Wir können die relativen Häufigkeiten leicht aus den absoluten Häufigkeiten bestimmen.\nstichprobe %&gt;% \n    count(q4) %&gt;%\n    mutate(\n        prozent = n / sum(n)\n    )\nDamit erhalten wir die prozentualen Anteile für alle beobachteten Merkmalsausprägungen.\n\nAchtung: Beachten Sie hier, dass n den Vektor n bezeichnet, der durch den Aufruf der count()-Funktion erzeugt wird. Sie dürfen diesen Vektor nicht mit der Funktion n() verwechseln! Die n()-Funktion liefert die Anzahl der Datensätze einer Stichprobe. Nachdem wir count() aufgerufen haben, ist das Ergebnis von n() in diesem Beispiel gleich 2.\n\nWir können nun leicht den Modus der Variable mit Hilfe der max-Aggregation bestimmen. Anstelle der summerise()-Funktion verwenden wir jedoch besser die filter()-Funktion, um auch das zugehörige Skalenniveau zu erhalten.\n# Bestimmen des Modus von q3\nstichprobe %&gt;% \n    count(q3) %&gt;%\n    filter(n == max(n))\n\n\n\n\n\nq3\n\n\nn\n\n\n\n\n&lt;chr&gt;\n\n\n&lt;int&gt;\n\n\n\n\n\n\nM\n\n\n17\n\n\n\n\n\n\nDer Modus ist in der deskriptiven Statistik nur in Ausnahmefällen von Bedeutung. Eine solche Ausnahme liegt vor, wenn aus mehreren Merkmalsausprägungen der Modus den stark überwiegenden Anteil in der Stichprobe ausmacht. Dieser Anteil ist ungefähr ab einer relativen Häufigkeit von .75 oder grösser gegeben. In solchen Fällen sollten Sie trotzdem die Häufigkeiten der anderen Merkmalsausprägungen berichten.\n\n\n\n18.3.2 Lagemasse für metrische Skalenniveaus\nDie grundlegenden Kennwerte für metrische Skalenniveaus sind die Bandbreite, die sich aus dem kleinsten (Minimum) und grössten gemessenen Wert (Maximum) ergibt.\nFür metrischskalierte Variablen können wir immer den Median und Quantile bestimmen, wobei wir uns in der Regel auf die Quartile beschränken. Bei der Beschreibung der Quartile geben wir immer den Interquartilsabstand mit an. Dieser ist das Gegenstück zur Bandbreite und zeigt uns zwischen welchen Ausprägungen die Hälfte der gemessenen Variablenwerte liegen.\nDas folgende Beispiel zeigt die Berechnung der relevanten Kennwerte für die Variable q10_1_0. Diese Berechnung entspricht der favstats der in Sauer (2019) beschriebenen mosaic-Bibliothek\nstichprobe %&gt;%\n    select(q10_1_0) %&gt;%\n    drop_na() %&gt;%\n    summarise(\n        n = n(),\n        min = min(q10_1_0),\n        max = max(q10_1_0),\n        bw = max - min,\n        \n        iqr = IQR(q10_1_0), # berücksichtigt ausreisser!\n        \n        q1 = quantile(q10_1_0, .25),\n        # q2 = quantile(q10_1_0, .5), # der Median ist die zweite Quartilsgrenze\n        md = median(q10_1_0), \n        q3 = quantile(q10_1_0, .75),\n        # q4 = quantile(q10_1_0, 1) , # Das Maximum ist die vierte Quartilsgrenze.\n\n        mad = mad(q10_1_0, constant = 1) \n    )\n\nDiese Ergebnisse werden nicht interpretiert!\n\n\nEs handelt sich bei diesen Ergebnisse um sog. á priori Fakten. Es sind also Fakten, die sich direkt aus den Messungen und der Definition (der Logik) der Lagemasse ergeben.\n\n\nEs gibt ein Rezept, um schnell alle ordinal- und metrischskalierten Varaiblen zu beschreiben.\n\n\n\n18.3.3 Lagemasse für ordinale Skalenniveaus\nIm Unterschied zu den metrischen Skalenniveaus ist der Mittelwert und die Standardabweichung für ordianle Skalenniveaus nicht definiert. Ausserdem werden Quartilsgrenzen und die davon abhängigen Variablen etwas anders berechnet als bei metrischskalierten Variablen. Damit wir keine Folgefehler für die spätere Analyse erhalten müssen wir für ordinalskalierte Variablen die entsprechenden Kennwerte richtig berechnen.\n\nAchtung! In vielen Fällen ergeben die verschiedenen Berechnungsarten die gleichen Ergebnisse. Das bedeutet nicht, dass die Ergebnisse in allen Fällen gleich und damit austauschbar sind!\n\n\nDie Berechnungsart wird mit dem Parameter type festgelegt. Dieser Parameter können wir die Ganzzahlen von 1 bis 8 übergeben. Der Standardwert für diesen Parameter ist 7. Die Werte 1, 2 und 3 sind für die Berechnung bei ordinalen Skalenniveaus gedacht. Die anderen Werte beschreiben verschiedene Varianten für metrische Skalenniveaus.\n\n\nVerwenden Sie nur die Werte 1 für ordinale Skalenniveaus und 7 für metrische Skalenniveaus. Weil 7 der Vorgabewert ist, wird dieser bei metrischen Skalenniveaus einfach weggelassen.\n\nAlle anderen Werte für den type-Parameter sind für besondere Fälle, wenn Ergebnisse aus anderen Quellen kontrolliert werden müssen.\nDas folgende Codesegment zeigt Berechnung der statistischen Kennwerte für ordinale Skalenniveaus.\nstichprobe %&gt;%\n    select(q10_1_0) %&gt;%\n    drop_na() %&gt;%\n    summarise(\n        n = n(),\n        min = min(q10_1_0),\n        max = max(q10_1_0),\n        bw = max - min,\n        \n        iqr = IQR(q10_1_0, type = 1), # berücksichtigt ausreisser!\n        \n        q1 = quantile(q10_1_0, .25, type = 1),\n        # q2 = quantile(q10_1_0, .5, type = 1), # der Median ist die zweite Quartilsgrenze\n        md = median(q10_1_0, type = 1), \n        q3 = quantile(q10_1_0, .75, type = 1),\n        # q4 = quantile(q10_1_0, 1, type = 1) , # Das Maximum ist die vierte Quartilsgrenze. \n\n       mad = mad(q10_1_0, constant = 1)\n    )"
  },
  {
    "objectID": "kapitel/14-daten-visualisieren/kapitel.html#aufbau-eines-diagramms",
    "href": "kapitel/14-daten-visualisieren/kapitel.html#aufbau-eines-diagramms",
    "title": "19  Daten visualisieren",
    "section": "19.1 Aufbau eines Diagramms",
    "text": "19.1 Aufbau eines Diagramms\nEine Visualisierung ist in ein Diagramm eingebettet. Ein Diagramm enthält meist mehr Elemente als die eigentliche Visualisierung. Abbildung 19.1 zeigt die wichtigsten Elemente eines Diagramms.\nJedes Diagramm umfasst den Darstellungsbereich mit den Datenpunkten (s. Definition 6.5), Achsen für die Hauptdimensionen mit Achsmarkierungen für die Position ausgewählter Werte im Wertebereich der Dimension und Achsbeschriftungen, die die Hauptdimensionen kennzeichnen.\nKomplexe Diagramme erfordern zusätzlich eine Legende für jede dargestellte Nebendimension.\nOptional können Visualisierungen mit einer erklärenden Überschrift versehen werden. Ebenfalls optional sind Hilfslinien, die die Orientierung im Wertebereich der Hauptdimensionen erleichtern.\n\n\n\nAbbildung 19.1: Komponenten eines Diagramms am Beispiel eines Ballondiagramms\n\n\n\n19.1.1 Haupt- und Nebendimensionen\nFür eine Visualisierung müssen immer zuerst die darzustellenden Merkmale ausgewählt werden.\n\nDefinition 19.1 Eine Dimension eines Diagramms entspricht einem dargestellten Merkmal der verwendeten Stichprobe.\n\n\n\n\n\n\n\nWarnung\n\n\n\nDie Merkmale aus unterschiedlichen Stichproben dürfen beim Visualisieren nicht gemischt werden!\n\n\nBeim Visualisieren werden Haupt- und Nebendimensionen unterschieden.\n\nDefinition 19.2 Eine Hauptdimension eines Diagramms bildet den Wertebereich eines Merkmals als eine horizontale oder vertikale Länge ab.\n\nDie Hauptdimensionen legen die Position der Datenpunkte in der Visualisierung fest.\nJede Visualisierung hat mindestens eine Hauptdimension.\n\nDefinition 19.3 Nebendimensionen eines Diagramms bilden den Wertebereich eines Merkmals als visuelle Eigenschaften von Datenpunkten ab.\n\nVisuelle Eigenschaften können Grösse, Form oder Farbe von Datenpunkte sein.\nNebendimensionen werden nicht in allen Diagrammen verwendet.\n\n\n19.1.2 Darstellungsbereich\nDer Darstellungsbereich enthält die eigentliche Visualisierung der Datenpunkte. Dieser Bereich muss für eine korrekte Darstellung alle gemessenen Werte, aber nicht zwingend den gesamten Wertebereich umfassen. Deshalb ist es nicht erlaubt, das Achsintervall des Darstellungsbereich so zu verändern, dass einzelne Werte nicht mehr dargestellt werden.\nDer Darstellungsbereich wird durch die Hauptdimensionen der Visualisierung aufgespannt.\n\n\n19.1.3 Achsen\nDie Achsen markieren die Hauptdimensionen eines Diagramms. Es sollten nicht mehr als zwei Hauptdimensionen in einem Diagramm verwendet werden, weil sich aus der Darstellung nicht mehr erkennen lässt, welche Achse zu welchen visuellen Elementen grhört.\nDie horizontale Achse wird per Konvention x-Achse und die vertikale Achse y-Achse genannt.\nAchsen sollten mit den wichtigsten Werten an Achsmarkierungen beschriftet werden und müssen eine aussagekräftige Achsbeschriftung haben. Die meisten Analyseumgebungen übernehmen standardmässig den Titel des Datenvektors.\nFür nominalskalierte Wertebereiche müssen alle dargestellten Werte über eine Achsmarkierung beschriftet werden. Bei sehr vielen Werten kann es vorkommen, dass diese Markierungen unleserlich werden. In diesem Fall sollten die Werte alphabetisch oder nummerisch sortiert werden und nur markannte Werte (z.B. jeden fünften Wert) hervorgehoben werden. In diesem Fall muss auf den vollständigen Wertebereich verwiesen werden, damit die Datenpunkte eindeutig identifiziert werden können.\nBei ordinalskalierten Wertebereichen müssen die Extreme des Wertebereichs beschriftet werden. Gegebenenfalls sollte auch der Mittelpunkt des Wertebereichs auf der Achse beschriftet werden.\nBei kontinuierlichen Wertebereichen sollten Werte in regelmässigen Abständen markiert und beschriftet werden. Diese genauen Abstände hängen vom Umfang des dargestellten Intervalls ab.\n\n\n19.1.4 Titel\nDer Diagrammtitel ist ein aussagekräftiger Titel über den Inhalt eines Diagramms.\n\n\n\n\n\n\nPraxis\n\n\n\nDer Diagrammtitel wird oft nicht in ein Diagramm aufgenommen, sondern erst später als Abbildungstitel hinzugefügt.\n\n\n\n\n19.1.5 Legende\nEine Legende beschreibt die Wertebereiche der Nebendimensionen einer Visualisierung. Ohne eine Legende lassen sich zusätzliche Kodierungen nicht nachvollziehen und dekodieren. Ein Diagramm muss eine Legende haben, sobald Nebendimensionen abgebildet sind. Fehlt eine Legende sind zusätzliche grafische Elemente als künstlerische Ergänzung ohne inhaltlichen Wert zu interpretieren."
  },
  {
    "objectID": "kapitel/14-daten-visualisieren/kapitel.html#plots-mit-einer-variablen",
    "href": "kapitel/14-daten-visualisieren/kapitel.html#plots-mit-einer-variablen",
    "title": "19  Daten visualisieren",
    "section": "19.2 Plots mit einer Variablen",
    "text": "19.2 Plots mit einer Variablen\n\n19.2.1 Histogramme\n\nDefinition 19.4 Ein Histogramm zeigt die Häufigkeiten einer Variablen mithilfe von Balken an. Umgangssprachlich werden Histogramme auch als Balkendiagramme bezeichnet.\n\nDie Höhe der Balken entspricht der Häufigkeit der Werte. Ein Histogramm macht die Verteilung einer Variable sichtbar.\n\nBei kontinuierlich-skalierten Variablen werden die Werte zu Intervallen zusammengefasst. Die Häufigkeit bezieht sich dann auf Anzahl der Werte im entsprechenden Intervall. Die Breite des Balkens entspricht dann der Breite des Intervalls.\n\n\n\n\n\n\nAbbildung 19.2: Beispiel für ein Histogramm für einen kontinuierlichen Wertebereich\n\n\n\n\n\nBei diskret-skalierten Variablen wird jeder Wert durch einen eigenen Balken repräsentiert. Die Häufigkeit der Werte bezieht sich dann auf die einzelnen Werte. Die Breite der Balken ist dann beliebig.\n\n\n\n\n\n\nAbbildung 19.3: Beispiel für ein Histogramm für einen diskreten Wertebereich\n\n\n\n\nDie Reihenfolge der Balken ist nicht beliebig. Die Balken werden für alle ordinalskalierten Wertebereiche in der Reihenfolge der Werte bzw. der Intervalle angeordnet. Nominalskalierte Wertebereiche haben keine natürliche Reihenfolgen. Deshalb werden die Balken eines Histogramms für nominalskalierte Wertebereiche in der Reihenfolge der Häufigkeiten angeordnet.\nEine Sonderform eines Histogramms ist das sog. Kreis- bzw. Tortendiagramm. Ein Tortendiagramm ist ein Histogramm, bei dem die Balken durch Kreissegmente ersetzt werden. Die Grösse der Kreissegmente entspricht dem Anteil der Häufigkeit an der Gesamthäufigkeit.\n\n\n\n\n\n\nMerke\n\n\n\nEin Histogramm ist einem Kreisdiagramm immer vorzuziehen. Kreisdiagramme sollten nur verwendet werden, wenn wenige Kreissegmente vorhanden sind. Dabei sollten entweder ein Kreissegment besonders hervorstechen oder alle Segmente ungefährt gleichverteilt sein.\n\n\n\n\n19.2.2 Boxplot\n\nDefinition 19.5 Ein Boxplot stellt die Grösse der Verteilungsintervalle von Daten als Rechteck und Linien dar. Aussergewöhneliche Werte (Ausreisser) werden als Punkte dargestellt.\n\nBox-Whisker-Diagramm und Kastengrafik sind gebräuchliche Synonyme für Boxplots.\n\n\n\n\n\n\nMerke\n\n\n\nBoxplots dürfen nur für ordinal- oder kontinuierlichskalierte Wertebereiche verwendet werden.\n\n\nEin Boxplot hat nur eine Achse für den Wertebereich der dargestellten Werte. Die zweite Achse in einem einfachen Boxplot ist nur notwendig, um das Rechteck zeichnen zu können und hat sonst keine Bedeutung.\nEin Boxplot gliedert die vorliegenden Daten in vier gleichgrosse Bereiche. Diese Bereiche heisse Quartile. Jedes Quartil umfasst jeweils ein Viertel der Werte. Die beiden mittleren Quartile werden als zwei Rechtecke dargestellt. Die Länge der beiden Rechtecke heisst Interquartilsabstand. Die Linie die am Übergang zwischen den beiden Rechtecken entsteht markiert den Median der Verteilung. Ausreisser sind Werte, die um mehr als das 1.5-fache des Interquartilsabstands von der nächsten Quartilsgrenze entfernt sind.\n\n\n\n\n\nAbbildung 19.4: Beispiel für einen Boxplot\n\n\n\n\nWeil ein Boxplot die Werte in gleichgrosse Intervalle gliedert, geben sie eine grobe Orientierung über die Verteilung der Werte.\n\n\n19.2.3 Dichtediagramme\nBoxplots und Histogramme fassen die Werte immer zu Intervallen zusammen. Dadurch lässt sich die genaue Verteilung der Daten nicht genau nachvollziehen. Bei kontinuierlichen Wertebereichen zeichen die Intervalle nicht immer ein akkurates Bild der Verteilung. Eine detailliertere Annäherung als ein Histogramm liefert die Dichtefunktion einer Verteilung.\nDie Dichtefunktion liefert die Wahrscheinlichkeiten, mit der Werte in einer Verteilung auftreten, als eine stetige Funktion von Wahrscheinlichkeitswerten. Weil nicht alle Werte in den Daten vorkommen, ist die Dichtefunktion eine Annäherung an die wahrscheinlichste Verteilung der dargestellten Werte.\n\nDefinition 19.6 Dichtediagramme sind eine Visualisierung der Dichtefunktion einer Verteilung und zeigen die Wahrscheinlichkeiten mit denen Werte eines kontinuierlichen Wertebereichs in einer Verteilung vorkommen.\n\n\n\n\n\n\n\nMerke\n\n\n\nDichtediagramme sind nur für kontinuierliche Wertebereiche erlaubt.\n\n\n\n\n\n\n\nAbbildung 19.5: Beispiel eines Dichtediagramms\n\n\n\n\n\n\n19.2.4 Violindiagramm\nEin Violindiagramm verbindet die Idee des Box-Plots mit der Dichtefunktion. Für kontinuierliche Wertebereiche zeigen Violindiagramm mehr Details als ein Boxplot.\n\n\n\n\n\n\nMerke\n\n\n\nViolindiagramme verwenden die Annäherung der Dichtefunktion für die Visualisierung. Entsprechend werden auch nicht gemessene Werte abgebildet.\n\n\n\n\n\n\n\nAbbildung 19.6: Beispiel eines violinplot\n\n\n\n\nDie zweite Achse eines Violindiagramms hat keine Bedeutung, sondern dient nur der Darstellung der Dichtefunktion. Hierbei ist zu beachten, dass die Kurve der Dichtefunktion gespiegelt ist. Deshalb sollten Violindiagramme nie als Grundlage für eine Schnellanalyse dienen, weil die Flächen leicht falsch interpretiert werden können."
  },
  {
    "objectID": "kapitel/14-daten-visualisieren/kapitel.html#plots-mit-zwei-variablen",
    "href": "kapitel/14-daten-visualisieren/kapitel.html#plots-mit-zwei-variablen",
    "title": "19  Daten visualisieren",
    "section": "19.3 Plots mit zwei Variablen",
    "text": "19.3 Plots mit zwei Variablen\n\n19.3.1 Funktionsdiagramme\n\nDefinition 19.7 Ein Funktionsdiagramm stellt die Parameter und die Ergebnisse einer oder mehrerer (mathematischer) Funktionen gegenüber.\n\nIn Funktionsdiagrammen werden die Parameter einer Funktion ihren Ergebnissen gegenübergestellt. Zwischen diesen Werten gibt es eine Beziehung, die durch die verwendete Funktion festgelegt wird.\n\nDefinition 19.8 Die Parametern und den Ergebnissen eine Funktion sind funktional abhängig. Für den Spezialfall einer linearen Funktion sind die Werte linear ahbängig.\n\nFunktionsdiagramme visualisieren also die funktionale Abhängigkeit zwischen Parametern und Ergenissen von Funktionen.\nFür ein Funktionsdiagramm wird neben der Funktion zusätzlich ein Parameterintervall benötigt. Das Parameterintervall bildet die Grundlage für den Darstellungsbereich. Anschliessend wird eine Wertetabelle für das Parameterintervall erstellt. Diese Tabelle enthält zwei Vektoren:\n\nEine Sequenz (s Kapitel 13.1) zwischen der Unter- und der Obergrenze des Parameterintervalls.\nDie Funktionsergebnisse für alle Werte gewählten Parameterintervall.\n\n\n\n\n\n\n\nPraxis\n\n\n\nViele Visualisierungsumgebungen erstellen die Wertetabelle automatich vor der Visualisierung einer Funktion.\n\n\n\n\n\n\n\nAbbildung 19.7: Beispiel eines Funktionsplots mit einer linearen und einer quadratischen Funktionen\n\n\n\n\nBei der Datenvisualisierung werden Funktionsdiagramme zur Vorhersage oder zum Vergleich der Werte eines Vektors durch die Werte eines anderen Vektors verwendet.\n\nDefinition 19.9 Ein Modell ist eine Funktion, die eine Beziehung zwischen Variablen als funktionale Anhängigkeit beschreibt.\n\n\n\n19.3.2 Beziehungen\nWerden die Werte von zwei Variablen gegenübergestellt, dann wird die Beziehung zwischen den Variablen sichtbar.\n\n\n\n\n\n\nAchtung\n\n\n\nGelegentlich werden Beziehungen zwischen Variablen mit Balken dargestellt. Diese Darstellung ist unzulässt. Balken sollten ausschliesslich zur Darstellung von Häufigkeiten verwendet werden.\n\n\nBeziehungen zwischen Variablen können auf verschiedene Arten dargestellt werden.\n\n19.3.2.1 Streudiagramme\nNormalerweise werden Beziehungen zwischen zwei Variablen mit einem sog. Streudiagramm dargestellt.\n\nEin Streudiagramm stellt die Werte aus zwei Variablen als Punkte dar. Umgangssprachlich werden Streudiagramme als Punktdiagramme bezeichnet.\n\nDie Werte der ersten Variablen werden z.B. auf der x-Achse abgetragen, die Werte der zweiten Variablen auf der y-Achse. Die Punkte werden dann an der entsprechenden Stelle im Koordinatensystem dargestellt. Die Wahl der Achse ist beliebig.\n\n\n\n\n\nAbbildung 19.8: Beispiel eines Streudiagramms\n\n\n\n\n\n\n19.3.2.2 Jitter-Diagramme\nWenn beide Variablen diskrete Wertebereiche haben, haben die Punkte im Streudiagramm die Tendenz, dass sich die Punkte zu überlagern, weil es nur eine begrenzte Anzahl möglichen Wertepaaren gibt. Um dieses Problem zu umgehen, wird eine besondere Variante des Streudiagramms eingesetzt: Das sog. Jitter-Diagramm (etwa Zitterdiagramm). Ein Jitter-Diagramm ist eine Variante von Streudiagrammen.\n\n\n\n\n\nAbbildung 19.9: Beispiel eines Streudiagramms mit überlagernden Punkten aus zwei diskreten Variablen\n\n\n\n\nBei einem Jitter-Diagramm wird um die diskreten Werte ein Bereich festgelegt. Der eigentliche Wert liegt im Mittelpunkt dieses Bereichs. Für jeden Messpunkt, wird ein Punkte zufällig innerhalb dieses Bereichs markiert. Durch diese zufällige Positionierung entsteht der Eindruck einer zittrigen Hand.\nDurch das zufällige Positionieren werden die Punkte aufgelockert und die Beziehung der Variablen wird sichtbar. Die Grösse des Bereichs wird so gewählt, dass sich mehrere Bereiche nicht überlappen.\n\n\n\n\n\nAbbildung 19.10: Beispiel eines Jitter-Diagramms mit zwei diskreten Variablen. Jitter-Bereiche sind Rot hervorgehoben.\n\n\n\n\n\n\n\n\n\n\nPraxis\n\n\n\nBei der Grösse des Jitter-Bereichs sollte etwas Abstand zu den umgebenden Bereichen gelassen werden. Dadurcht entsteht ein Leerraum, welcher keine Punkte enthält, so lassen sich die einzelnen Bereiche optisch leichter voneinander abgrenzen.\n\n\nBeim Lesen eines Jitter-Diagramm muss beachtet werden, dass der Bereich für die Punkte dem zugehörigen diskreten Wert entspricht. Durch die Anordnung der Punkte in einem Jitter-Diagramm kann der Eindruck einer Beziehung zwischen zwei Variablen visuell entstehen, ohne dass diese Beziehung tatsächlich existiert.\n\n\n19.3.2.3 Liniendiagramme\n\nDefinition 19.10 Ein Liniendiagramm eine Variante eines Streudiagramms, bei dem aufeinanderfolgende Punkte durch eine Linie verbunden werden.\n\nLiniendiagramme werden verwendet, wenn die Werte einer Variablen in einer bestimmten Reihenfolge zueinander stehen. Die Werte werden dann auf der entsprechenden Achse in der entsprechenden Reihenfolge abgetragen. Die Punkte werden dann durch eine Linie verbunden.\nLiniendiagramme werden häufig verwendet, um die Entwicklung von Variablen über die Zeit darzustellen.\n\n\n\n\n\nAbbildung 19.11: Beispiel eines Liniendiagramms (DAX Index 1991-1998)\n\n\n\n\n\n\n\n\n\n\nAchtung\n\n\n\nWenn die Werte einer Variablen nicht in einer festen Reihenfolge zueinander stehen, dann dürfen die Werte nicht durch eine Linie verbunden werden! In diesem Fall muss ein Streudiagramm verwendet werden.\n\n\n\n\n\n19.3.3 Ausgleichsgeraden\n\nDefinition 19.11 Eine Ausgleichsgerade ist ein Funktionsdiagramm einer Funktion, welche die Ergebnisse einer linearen Funktion zu den tatsächlichen Werten minimiert.\n\nAusgleichsgeraden verwenden lineare Funktionen in der Form ax + c. Die Funktion einer Ausgleichsgeraden minimiert die Funktionsergebnisse mit den tatsächlichen Werten.\nEine Ausgleichsgerade darf nicht willkürlich gezogen werden, sondern muss aus den gemessenen Werten ermittelt werden. Eine Ausgleichsgerade sollte immer gemeinsam mit den tatsächlichen Werten der Variablen dargestellt werden.\nDie Funktion einer Ausgleichsgeraden ist ein einfaches Modell für die gefundenen Daten. Die Beziehung zwischen den Variablen wird in diesem Modell als lineare Abhängigkeit abgebildet.\n\n\n\n\n\nAbbildung 19.12: Beispiel einer Ausgleichsgeraden in einem Streudiagramm\n\n\n\n\n\n\n19.3.4 Zwei unterschiedliche Skalenniveaus kombinieren\nSollen die Werte einer Variable mit diskreten Wertebereich gegen die Werte einer Variablen mit kontinuierlichem Wertebereich abgetragen werden, dann werden die Verteilungen der kontinuierlichen Variablen für die einzelnen Werte eines diskreten Wertebereichs dargestellt. Hierzu werden meist Boxplots oder Violindiagramme verwendet.\nDiese Form von kombinierten Diagrammen tritt sehr häufig in Verbindung mit Sekundärindizes auf. Dabei werden Verteilungen von gruppierten Werten gegenübergestellt.\n\n\n\n\n\nAbbildung 19.13: Beispiel eines Diagramms mit diskreten und kontinuierlichen Variablen"
  },
  {
    "objectID": "kapitel/14-daten-visualisieren/kapitel.html#plots-mit-mehr-als-zwei-variablen",
    "href": "kapitel/14-daten-visualisieren/kapitel.html#plots-mit-mehr-als-zwei-variablen",
    "title": "19  Daten visualisieren",
    "section": "19.4 Plots mit mehr als zwei Variablen",
    "text": "19.4 Plots mit mehr als zwei Variablen\nPlots sind auf zwei Dimensionen beschränkt. Werden mehr als zwei Variablen dargestellt, dann werden die zusätzlichen Variablen durch verschiedene Darstellungsformen repräsentiert. 3D-Koordinatensysteme sollten vermieden werden, weil die Position der Punkte bei der 2D-Darstellung eines 3D-Koordinatensystems mehrdeutig ist und sich schwer interpretieren lässt.\nFür Beziehungen zwischen mehr als zwei Variablen muss für die zusätzlichen Variablen eine andere Darstellungsform gewählt werden. Die wichtigsten Darstellungsformen sind:\n\nFarbliche Kodierung\nGrössenkodierung\nForm-Kodierung\n\nDiese Varianten können kombiniert werden, um zusätzliche Daten in eine Visualisierungzu integrieren.\n\n\n\n\n\n\nWichtig\n\n\n\nAlle zusätzlichen Kodierungen müssen in einer Legende erklärt werden.\n\n\n\n19.4.1 Farbliche Kodierung\nBei der farblichen Kodierung werden die dargestellten Werte in Farben oder Farbtöne übersetzt.\nBei diskreten Wertebereichen sollten für die farbliche Kodierung Farben bzw. Farbtöne verwendet werden, die sich voneinander unterscheiden lassen.\n\n\n\n\n\n\nHinweis\n\n\n\nDie farblichen Kodierung sollte sparsam eingesetzt werden, weil die menschliche Farbwahrnehmung stark variiert. Eine vermeintlich gut gewählter Farbton lässt möglicherweise von den Adressaten einer Visualisierung nicht von anderen verwendeten Farben unterscheinde. Dadurch kann die Darstellung nicht wie vorgesehen dekodiert werden.\n\n\n\n19.4.1.1 Farbliche Kodierung von diskreten Wertebereichen\nBei diskreten Wertebereichen werden Farben verwendet, die einen möglichst grossen Kontrast zueinander haben.\n\n\n\n\n\n\nHinweis\n\n\n\nDiskrete Farben können Menschen nicht beliebig voneinander unterscheiden. Deshalb sollten der Wertebereich einer so kodierter Daten klein sein.\n\n\n\n\n\n\n\nAbbildung 19.14: Beispiel für die Farbkodierung einer dritten diskreten Dimension\n\n\n\n\n\n\n19.4.1.2 Farbliche Kodierung von kontinuierlichen Wertebereichen\nKontinuierliche Wertebereiche werden als sog. Farbgradienten (bzw. Farbverlauf) zwischen zwei Farben kodiert.\nBei Wertebereichen mit einem definierten Mittelpunkt, wird dieser oft mit einem Übergang über weiss dargestellt. In diesem Fall hat der Gradient 3 Farben. Daraus ergibt sich, dass je heller ein Farbton ist, desto näher ist der Wert am Mittelpunkt. Je nach Färbung ist dann ersichtlich, ob ein Wert ober- oder unterhalb des Mittelpunkts liegt.\nFarbgradienten haben den Nachteil, dass die meisten Menschen farbliche Unterschiede nicht stufenlos unterscheiden können. Deshalb sollten Farbgradienten nur verwendet werden, wenn die exakten Werte für die Visualisierung von untergeordneter Rolle sind.\n\n\n\n\n\nAbbildung 19.15: Beispiel für die Farbkodierung mit einem Farbgradienten\n\n\n\n\n\n\n\n19.4.2 Grössenkodierung\nBei der Grössenkodierung werden die Punkte von Streudiagrammen entsprechend eines dritten Werts vergrössert oder verkleinert.\n\n\n\n\n\n\nHinweis\n\n\n\nEine Grössenkodierung eigent sich gut für kontinuierliche Wertebereiche. Obwohl sich ordinalskalierte Wertebereiche ebenfalls so darstellen lassen, sollte das möglichst vermieden werden, weil bei dieser Darstellungsform verborgen wird, dass es sich um diskrete Daten handelt.\n\n\n\n\n\n\n\nAbbildung 19.16: Beispiel für die Grössenkodierung einer dritten diskreten Dimension\n\n\n\n\n\nDefinition 19.12 Ein Bubble-Chart oder Ballondiagramm ist ein Streudiagramm mit zusätzlichen grössenkodierten Werten.\n\n\n\n19.4.3 Form-Kodierung\nÜber die Form von Punkten oder Linien können zuätzliche Werte in Diagrammen abgebildet werden. Formen eignen sich nur für diskrete Wertebereiche.\nNormalerweise wird die Kodierung für Punkte oder für Linien verwendet.\n\n\n\n\n\n\nHinweis\n\n\n\nBei der Formkodierung muss auf die Mindestgrösse geachtet werden, weil sehr kleine Formen nur schwer voneinander unterscheidbar sind.\n\n\n\n\n\n\n\nAbbildung 19.17: Beispiel für die Formkodierung für Punkte und Linien\n\n\n\n\n\n\n19.4.4 Teildiagramme\nMit Teildiagrammen werden die Werte entlang einer Variablen in Daten-Segmente getrennt und anschliessend werden die die restlichen Variablen für jedes Segment einzeln visualisiert. Diese Teildiagramme heissen Facetten.\nSolche Facetten können nur mithilfe diskreter Daten gebildet werden. Jede Facette muss eine Überschrift haben, die den Wert der Nebendimension zeigt, der die dargestellten Datenpunkte zusammenfasst.\n\n\n\n\n\nAbbildung 19.18: Beispiel die Gliederung in Teildiagramme mithilfe einer dritten diskreten Dimension\n\n\n\n\nTeildiagramme haben den Nachteil, dass die Daten über verschiedene Diagramme verteilt dargestellt werden. Das erschwert den direkten Vergleich der dargestellten Werte. Deshalb sollten Teildiagramme gewählt werden, wenn durch die isolierte Darstellung bestimmte Aspekte einer Analyse besser hervorgehoben werden. Dazu gehören beispielsweise Beziehungen von Variablen in Gruppen, die mit trotz visueller Kodierungen leicht übersehen werden können."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referenzen",
    "section": "",
    "text": "American National Standards Institute. (1977). Code for information\ninterchange (ANSI X3.4-1977). https://nvlpubs.nist.gov/nistpubs/Legacy/FIPS/fipspub1-2-1977.pdf\n\n\nAmerican Psychological Association. (2020). Publication manual of\nthe american psychological association (7th ed.). American\nPsychological Association. https://doi.org/10.1037/0000165-000\n\n\nBen-Kiki, O., Evans, C., & Net, I. döt. (2021).\nYAML ain’t markup language (Version v1.2.2). https://yaml.org/spec/1.2.2/\n\n\nBoole, G. (1847). The mathematical analysis of logic,being an essay\ntowards a calculus of deductive reasoning. https://www.gutenberg.org/files/36884/36884-pdf.pdf\n\n\nBray, T. (2017). The JavaScript object notation\n(JSON) data interchange format (RFC\n8259). https://datatracker.ietf.org/doc/html/rfc8259\n\n\nBray, T., Paoli, J., Sperberg-McQueen, C. M., Maler, E., & Yergeau,\nF. (2008). Extensible markup language (XML) 1.0 (fifth\nedition) (Version 1.0). https://www.w3.org/TR/xml/\n\n\nCarpenter, M. (2023). [MS-XLSX]: Excel\n(.xlsx) extensions to the office open XML\nSpreadsheetML file format (Version v23.4). https://learn.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/2c5dee00-eff2-4b22-92b6-0738acd4475e\n\n\nChurch, A. (1940). A formulation of the simple theory of types.\nJournal of Symbolic Logic, 5(2), 56–68. https://doi.org/10.2307/2266170\n\n\nGitHub Inc. (n.d.). GitHub flow. https://docs.github.com/en/get-started/quickstart/github-flow\n\n\nHickson, I., Pieters, S., Kesteren, A. van, Jägenstedt, P., &\nDenicola, D. (n.d.). HTML (Version 5). https://html.spec.whatwg.org/multipage/\n\n\nIEEE. (2018). IEEE reference guide. https://ieeeauthorcenter.ieee.org/wp-content/uploads/IEEE-Reference-Guide.pdf\n\n\nISO/IEC JTC 1/SC 2. (2020). Information technology — universal coded\ncharacter set (UCS) (ISO/IEC\n10646:2020). https://www.iso.org/standard/76835.html\n\n\nISO/IEC JTC 1/SC 2/WG 3. (1998a). DIS 8859-1, 8-bit\nsingle-byte coded graphic character sets – part 1: Latin alphabet\nno.1 (N 411). https://www.open-std.org/JTC1/sc2/wg3/docs/n411.pdf\n\n\nISO/IEC JTC 1/SC 2/WG 3. (1998b). ISO/IEC\nFCD 8859-15 information technology – 8 –bit singlebyte\ncoded graphic character sets – part 15 : Latin alphabet 0 (covering the\nEURO symbol and full support for the french and finish\nlanguages (N 404). https://www.open-std.org/JTC1/SC2/WG3/docs/n404.pdf\n\n\nISO/IEC JTC 1/SC 34. (1999). Information processing — text and\noffice systems — standard generalized markup language\n(SGML) (ISO 8879:1986). https://www.iso.org/standard/16387.html\n\n\nISO/TC 68/SC 8. (2020). Financial services — international bank\naccount number (IBAN) — part 1: Structure of the\nIBAN (ISO 13616-1:2020). https://www.iso.org/standard/81090.html\n\n\nKnuth, D. E. (1968). Semantics of context-free languages.\nMathematical Systems Theory, 2(2), 127–145. https://doi.org/10.1007/BF01692511\n\n\nLindner, P. (1993). Definition of tab-separated-values (tsv).\nhttps://www.iana.org/assignments/media-types/text/tab-separated-values\n\n\nPython Software Foundation. (2013, July 6). Bitwise operators.\nhttps://wiki.python.org/moin/BitwiseOperators\n\n\nRautenberg, W. (2008). Einführung in die mathematische Logik: ein\nLehrbuch (3., überarb. Aufl). Vieweg + Teubner.\n\n\nRodkin, C. (2023). ACM citation style and reference\nformats. https://www.acm.org/publications/authors/reference-formatting\n\n\nShafranovich, Y. (2005). Common format and MIME type\nfor comma-separated values (CSV) files\n(RFC 4180). https://datatracker.ietf.org/doc/html/rfc4180\n\n\nShannon, C. E. (1948). A mathematical theory of communication. The\nBell System Technical Journal, 27, 379–423. https://doi.org/10.1002/j.1538-7305.1948.tb01338.x\n\n\nShannon, C. E. (1949). Communication theory of secrecy systems. Bell\nSystem Technical Journal, 28(4), 656–715. https://doi.org/10.1002/j.1538-7305.1949.tb00928.x\n\n\nThe Unicode Consortium. (2022). Unicode. https://www.unicode.org/versions/latest/\n\n\nThe University Of Chicago Press Editorial Staff. (2017). The chicago\nmanual of style, 17th edition. University of Chicago Press. https://doi.org/10.7208/cmos17\n\n\nZHAW. (2023). ZHAW Meldung vom 24.8.2023. https://twitter.com/ZHAW/status/1694731482051309775"
  }
]